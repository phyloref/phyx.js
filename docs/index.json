[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/index.js",
    "content": "/**\n * PHYX Library\n * Copyright (c) The Phyloreferencing Project, 2018-19\n *\n * PHYloreference eXchange (PHYX) files store phyloreferences along with\n * annotated phylogenies that allow their expected resolution to be curated\n * and tested. This library provides classes and methods that help read and\n * manipulate components of PHYX files.\n *\n * Note that our goal here isn't to provide a library for modeling an entire\n * PHYX file in Javascript. The Curation Tool can mostly access and edit\n * components of the PHYX file as text strings or JSON objects, and the terms\n * used in the PHYX file should be clearly defined on their own. This library\n * contains convenience classes and methods that make accessing those components\n * easier.\n *\n * Most of these classes are wrappers. Because the object they wrap may be\n * unexpectedly modified through the UI, wrapper constructors should be extremely\n * lightweight so that the wrapper can be created quickly. Individual methods\n * can be complex and slow if necessary.\n */\n\n/** The Phyx Cache Manager -- used to manage caches across this library. */\nconst { PhyxCacheManager } = require('./utils/PhyxCacheManager');\n\n/** A ScientificNameWrapper for wrapping scientific names. */\nconst { ScientificNameWrapper } = require('./wrappers/ScientificNameWrapper');\n\n/** A SpecimenWrapper for wrapping specimens. */\nconst { SpecimenWrapper } = require('./wrappers/SpecimenWrapper');\n\n/** A TaxonomicUnitWrapper for wrapping taxonomic units. */\nconst { TaxonomicUnitWrapper } = require('./wrappers/TaxonomicUnitWrapper');\n\n/** A TaxonomicUnitMatcher for matching taxonomic units. */\nconst { TaxonomicUnitMatcher } = require('./matchers/TaxonomicUnitMatcher');\n\n/** A PhylogenyWrapper for wrapping phylogenies. */\nconst { PhylogenyWrapper } = require('./wrappers/PhylogenyWrapper');\n\n/** A PhylorefWrapper for wrapping phyloreferences. */\nconst { PhylorefWrapper } = require('./wrappers/PhylorefWrapper');\n\n/** A PhyxWrapper for wrapping an entire Phyx document. */\nconst { PhyxWrapper } = require('./wrappers/PhyxWrapper');\n\n/* Exports */\nmodule.exports = {\n  ScientificNameWrapper,\n  SpecimenWrapper,\n  TaxonomicUnitWrapper,\n  TaxonomicUnitMatcher,\n  PhylogenyWrapper,\n  PhylorefWrapper,\n  PhyxWrapper,\n  PhyxCacheManager,\n  clearCaches() {\n    // Clear the caches in the PhyxCacheManager.\n    PhyxCacheManager.clear();\n  },\n};\n",
    "static": true,
    "longname": "/home/vaidyagi/code/phyloref/phyx.js/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "variable",
    "name": "PhyxCacheManager",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~PhyxCacheManager",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": "The Phyx Cache Manager -- used to manage caches across this library.",
    "lineNumber": 24,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 50,
    "kind": "variable",
    "name": "ScientificNameWrapper",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~ScientificNameWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": "A ScientificNameWrapper for wrapping scientific names.",
    "lineNumber": 27,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 51,
    "kind": "variable",
    "name": "SpecimenWrapper",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~SpecimenWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": "A SpecimenWrapper for wrapping specimens.",
    "lineNumber": 30,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 52,
    "kind": "variable",
    "name": "TaxonomicUnitWrapper",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~TaxonomicUnitWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": "A TaxonomicUnitWrapper for wrapping taxonomic units.",
    "lineNumber": 33,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 53,
    "kind": "variable",
    "name": "TaxonomicUnitMatcher",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~TaxonomicUnitMatcher",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": "A TaxonomicUnitMatcher for matching taxonomic units.",
    "lineNumber": 36,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 54,
    "kind": "variable",
    "name": "PhylogenyWrapper",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~PhylogenyWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": "A PhylogenyWrapper for wrapping phylogenies.",
    "lineNumber": 39,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 55,
    "kind": "variable",
    "name": "PhylorefWrapper",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~PhylorefWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": "A PhylorefWrapper for wrapping phyloreferences.",
    "lineNumber": 42,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 56,
    "kind": "variable",
    "name": "PhyxWrapper",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~PhyxWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": "A PhyxWrapper for wrapping an entire Phyx document.",
    "lineNumber": 45,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 57,
    "kind": "file",
    "name": "src/matchers/TaxonomicUnitMatcher.js",
    "content": "const { has } = require('lodash');\nconst { ScientificNameWrapper } = require('../wrappers/ScientificNameWrapper');\nconst { SpecimenWrapper } = require('../wrappers/SpecimenWrapper');\n\n/* Taxonomic unit matching */\n\nclass TaxonomicUnitMatcher {\n  // A taxonomic unit matcher tests for taxonomic matches between pairs of\n  // taxonomic units.\n\n  constructor(tunit1, tunit2) {\n    // Construct a Taxonomic Unit Matcher to compare the two provided\n    // taxonomic units.\n    this.tunit1 = tunit1;\n    this.tunit2 = tunit2;\n\n    // Set up places to store the match results.\n    this.matched = undefined; // Boolean variable for storing whether these TUnits matched.\n    this.matchReason = undefined; // The reason provided for this match.\n\n    // Execute the match.\n    this.match();\n  }\n\n  asJSONLD(idURI) {\n    // Return this TUMatch as a JSON object for insertion into the PHYX file.\n    if (!this.matched) return undefined;\n\n    return {\n      '@id': idURI,\n      '@type': 'testcase:TUMatch',\n      reason: this.matchReason,\n      matchesTaxonomicUnits: [\n        { '@id': this.tunit1['@id'] },\n        { '@id': this.tunit2['@id'] },\n      ],\n    };\n  }\n\n  match() {\n    // Try to match the two taxonomic units using a number of matching methods.\n    if (\n      this.matchByBinomialName()\n      || this.matchByExternalReferences()\n      || this.matchBySpecimenIdentifier()\n    ) {\n      this.matched = true;\n    } else {\n      this.matched = false;\n      this.matchReason = undefined;\n    }\n  }\n\n  matchByBinomialName() {\n    // Try to match by binomial name, and return true if it could be matched.\n\n    // Do both TUnits have scientificNames?\n    if (!has(this.tunit1, 'scientificNames') || !has(this.tunit2, 'scientificNames')) return false;\n\n    return this.tunit1.scientificNames.some((scname1) => {\n      const scname1wrapped = new ScientificNameWrapper(scname1);\n      return this.tunit2.scientificNames.some((scname2) => {\n        const scname2wrapped = new ScientificNameWrapper(scname2);\n\n        const result = scname1wrapped.binomialName !== undefined\n          && scname2wrapped.binomialName !== undefined\n          && scname1wrapped.binomialName.trim().length > 0\n          && scname1wrapped.binomialName.trim() === scname2wrapped.binomialName.trim();\n\n        if (result) {\n          this.matchReason = `Scientific name '${scname1wrapped.scientificName}' and scientific name '${scname2wrapped.scientificName}' share the same binomial name`;\n        }\n\n        return result;\n      });\n    });\n  }\n\n  matchByExternalReferences() {\n    // Try to match by external references.\n\n    if (has(this.tunit1, 'externalReferences') && has(this.tunit2, 'externalReferences')) {\n      // Each external reference is a URL as a string. We will lowercase it,\n      // but do no other transformation.\n      return this.tunit1.externalReferences.some(\n        extref1 => this.tunit2.externalReferences.some((extref2) => {\n          const result = (\n            // Make sure that the external reference isn't blank\n            extref1.trim() !== ''\n\n              // And that it is identical after trimming\n              && extref1.toLowerCase().trim() === extref2.toLowerCase().trim()\n          );\n\n          if (result) {\n            this.matchReason = `External reference '${extref1}' is shared by taxonomic unit ${this.tunit1} and ${this.tunit2}`;\n          }\n\n          return result;\n        })\n      );\n    }\n\n    return false;\n  }\n\n  matchBySpecimenIdentifier() {\n    // Try to match by specimen identifier (i.e. occurrence ID).\n\n    if (has(this.tunit1, 'includesSpecimens') && has(this.tunit2, 'includesSpecimens')) {\n      // Convert specimen identifiers (if present) into a standard format and compare those.\n      return this.tunit1.includesSpecimens.some((specimen1) => {\n        const specimenURN1 = new SpecimenWrapper(specimen1).occurrenceID;\n        return this.tunit2.includesSpecimens.some((specimen2) => {\n          const specimenURN2 = new SpecimenWrapper(specimen2).occurrenceID;\n\n          const result = (specimenURN1 === specimenURN2);\n\n          if (result) {\n            this.matchReason = `Specimen identifier '${specimenURN1}' is shared by taxonomic units`;\n          }\n\n          return result;\n        });\n      });\n    }\n\n    return false;\n  }\n}\n\nmodule.exports = {\n  TaxonomicUnitMatcher,\n};\n",
    "static": true,
    "longname": "/home/vaidyagi/code/phyloref/phyx.js/src/matchers/TaxonomicUnitMatcher.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 58,
    "kind": "variable",
    "name": "has",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js",
    "static": true,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~has",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/matchers/TaxonomicUnitMatcher.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 59,
    "kind": "variable",
    "name": "ScientificNameWrapper",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js",
    "static": true,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~ScientificNameWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/matchers/TaxonomicUnitMatcher.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 60,
    "kind": "variable",
    "name": "SpecimenWrapper",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js",
    "static": true,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~SpecimenWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/matchers/TaxonomicUnitMatcher.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 61,
    "kind": "class",
    "name": "TaxonomicUnitMatcher",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js",
    "static": true,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/matchers/TaxonomicUnitMatcher.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 62,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true
  },
  {
    "__docId__": 63,
    "kind": "member",
    "name": "tunit1",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher",
    "static": false,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher#tunit1",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "member",
    "name": "tunit2",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher",
    "static": false,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher#tunit2",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 65,
    "kind": "member",
    "name": "matched",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher",
    "static": false,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher#matched",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 66,
    "kind": "member",
    "name": "matchReason",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher",
    "static": false,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher#matchReason",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 67,
    "kind": "method",
    "name": "asJSONLD",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher#asJSONLD",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "params": [
      {
        "name": "idURI",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"@id\": *, \"@type\": string, \"reason\": *, \"matchesTaxonomicUnits\": *}"
      ]
    }
  },
  {
    "__docId__": 68,
    "kind": "method",
    "name": "match",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher#match",
    "access": "public",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 72,
    "kind": "method",
    "name": "matchByBinomialName",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher#matchByBinomialName",
    "access": "public",
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "method",
    "name": "matchByExternalReferences",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher#matchByExternalReferences",
    "access": "public",
    "description": null,
    "lineNumber": 79,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 76,
    "kind": "method",
    "name": "matchBySpecimenIdentifier",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher#matchBySpecimenIdentifier",
    "access": "public",
    "description": null,
    "lineNumber": 107,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 78,
    "kind": "file",
    "name": "src/utils/PhyxCacheManager.js",
    "content": "const { has } = require('lodash');\n\n/**\n * phyx.js needs to cache several kinds of data to avoid reparsing them over and\n * over again, such as scientific names. This CacheManager provides that facility,\n * and allows users of this library to clear the cache as needed.\n *\n * We might want to replace this with a cache that limits the amount of memory,\n * such as https://www.npmjs.com/package/safe-memory-cache.\n */\n\nclass CacheManager {\n  /** Construct a new cache manager. */\n  constructor() {\n    this.clear();\n  }\n\n  /** Clear all current caches. */\n  clear() {\n    this.caches = {};\n  }\n\n  /** Return true if we have a value for this particular cache key. */\n  has(cacheName, cacheKey) {\n    return has(this.caches, cacheName)\n      && has(this.caches[cacheName], cacheKey);\n  }\n\n  /** Look up the value of a key in a particular cache. */\n  get(cacheName, cacheKey) {\n    if (!has(this.caches, cacheName)) this.caches[cacheName] = {};\n    if (!has(this.caches[cacheName], cacheKey)) return undefined;\n    return this.caches[cacheName][cacheKey];\n  }\n\n  /** Set the value of a key in a particular cache. */\n  put(cacheName, cacheKey, value) {\n    if (!has(this.caches, cacheName)) this.caches[cacheName] = {};\n    if (!has(this.caches[cacheName], cacheKey)) this.caches[cacheName][cacheKey] = {};\n    this.caches[cacheName][cacheKey] = value;\n  }\n}\n\n/*\n * Unless you meddle with require.cache, this should always return the same instance\n * of the cache manager. See the following link for a discussion of this approach:\n * https://derickbailey.com/2016/03/09/creating-a-true-singleton-in-node-js-with-es6-symbols/\n */\nmodule.exports = {\n  PhyxCacheManager: new CacheManager(),\n};\n",
    "static": true,
    "longname": "/home/vaidyagi/code/phyloref/phyx.js/src/utils/PhyxCacheManager.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 79,
    "kind": "variable",
    "name": "has",
    "memberof": "src/utils/PhyxCacheManager.js",
    "static": true,
    "longname": "src/utils/PhyxCacheManager.js~has",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/utils/PhyxCacheManager.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 80,
    "kind": "class",
    "name": "CacheManager",
    "memberof": "src/utils/PhyxCacheManager.js",
    "static": true,
    "longname": "src/utils/PhyxCacheManager.js~CacheManager",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/utils/PhyxCacheManager.js",
    "importStyle": null,
    "description": "phyx.js needs to cache several kinds of data to avoid reparsing them over and\nover again, such as scientific names. This CacheManager provides that facility,\nand allows users of this library to clear the cache as needed.\n\nWe might want to replace this with a cache that limits the amount of memory,\nsuch as https://www.npmjs.com/package/safe-memory-cache.",
    "lineNumber": 12,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 81,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/utils/PhyxCacheManager.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/utils/PhyxCacheManager.js~CacheManager#constructor",
    "access": "public",
    "description": "Construct a new cache manager.",
    "lineNumber": 14
  },
  {
    "__docId__": 82,
    "kind": "method",
    "name": "clear",
    "memberof": "src/utils/PhyxCacheManager.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/utils/PhyxCacheManager.js~CacheManager#clear",
    "access": "public",
    "description": "Clear all current caches.",
    "lineNumber": 19,
    "params": [],
    "return": null
  },
  {
    "__docId__": 83,
    "kind": "member",
    "name": "caches",
    "memberof": "src/utils/PhyxCacheManager.js~CacheManager",
    "static": false,
    "longname": "src/utils/PhyxCacheManager.js~CacheManager#caches",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 84,
    "kind": "method",
    "name": "has",
    "memberof": "src/utils/PhyxCacheManager.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/utils/PhyxCacheManager.js~CacheManager#has",
    "access": "public",
    "description": "Return true if we have a value for this particular cache key.",
    "lineNumber": 24,
    "params": [
      {
        "name": "cacheName",
        "types": [
          "*"
        ]
      },
      {
        "name": "cacheKey",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 85,
    "kind": "method",
    "name": "get",
    "memberof": "src/utils/PhyxCacheManager.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/utils/PhyxCacheManager.js~CacheManager#get",
    "access": "public",
    "description": "Look up the value of a key in a particular cache.",
    "lineNumber": 30,
    "params": [
      {
        "name": "cacheName",
        "types": [
          "*"
        ]
      },
      {
        "name": "cacheKey",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "method",
    "name": "put",
    "memberof": "src/utils/PhyxCacheManager.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/utils/PhyxCacheManager.js~CacheManager#put",
    "access": "public",
    "description": "Set the value of a key in a particular cache.",
    "lineNumber": 37,
    "params": [
      {
        "name": "cacheName",
        "types": [
          "*"
        ]
      },
      {
        "name": "cacheKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 87,
    "kind": "file",
    "name": "src/utils/owlterms.js",
    "content": "\n// Some OWL constants to be used.\nmodule.exports = {\n  CDAO_HAS_CHILD: 'obo:CDAO_0000149',\n  CDAO_HAS_DESCENDANT: 'obo:CDAO_0000174',\n  PHYLOREF_EXCLUDES_LINEAGE_TO: 'phyloref:excludes_lineage_to',\n  PHYLOREFERENCE_TEST_CASE: 'testcase:PhyloreferenceTestCase',\n  PHYLOREFERENCE_PHYLOGENY: 'testcase:PhyloreferenceTestPhylogeny',\n  TESTCASE_SPECIFIER: 'testcase:Specifier',\n};\n",
    "static": true,
    "longname": "/home/vaidyagi/code/phyloref/phyx.js/src/utils/owlterms.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 88,
    "kind": "file",
    "name": "src/wrappers/PhylogenyWrapper.js",
    "content": "/**\n * PhylogenyWrapper\n */\n\nconst { has } = require('lodash');\n\n/** Used to parse Newick strings. */\nconst { parse: parseNewick } = require('newick-js');\n\n/** OWL terms to be used here. */\nconst owlterms = require('../utils/owlterms');\n\nconst { TaxonomicUnitWrapper } = require('./TaxonomicUnitWrapper');\nconst { TaxonomicUnitMatcher } = require('../matchers/TaxonomicUnitMatcher');\n\nclass PhylogenyWrapper {\n  // Wraps a Phylogeny in a PHYX file and provides access to node, node labels\n  // and other information. Remember that a Phylogeny also has the\n  // additionalNodeProperties object which provides additional properties for\n  // nodes.\n\n  constructor(phylogeny) {\n    // Construct a phylogeny based on a Phylogeny object in a PHYX phylogeny.\n    // Note that this version ONLY uses the `newick` property to determine the\n    // phylogeny: if other representations are included (such as a node-based\n    // format, as used in JSON-LD), they will be ignored and possibly overwritten\n    // during export. So, to update the phylogeny, please only update the newick\n    // string!\n    //\n    // This ensures that we don't need to reconcile between different\n    // possible representations of a phylogeny.\n    this.phylogeny = phylogeny;\n  }\n\n  static getErrorsInNewickString(newick) {\n    // Given a Newick string, return a list of errors found in parsing this\n    // string. The errors are returned as a list of objects, each of which\n    // has two properties:\n    //  - title: A short title of the error, distinct for each type of error.\n    //  - message: A longer description of the error, which might include\n    //    information specific to a particular error.\n    //\n    // We try to order errors from most helpful ('Unbalanced parentheses in\n    // Newick string') to least helpful ('Error parsing phylogeny').\n    const newickTrimmed = newick.trim();\n    const errors = [];\n\n    // Look for an empty Newick string.\n    if (newickTrimmed === '' || newickTrimmed === '()' || newickTrimmed === '();') {\n      // None of the later errors are relevant here, so bail out now.\n      return [{\n        title: 'No phylogeny entered',\n        message: 'Click on \"Edit as Newick\" to enter a phylogeny below.',\n      }];\n    }\n\n    // Look for an unbalanced Newick string.\n    let parenLevels = 0;\n    for (let x = 0; x < newickTrimmed.length; x += 1) {\n      if (newickTrimmed[x] === '(') parenLevels += 1;\n      if (newickTrimmed[x] === ')') parenLevels -= 1;\n    }\n\n    if (parenLevels !== 0) {\n      errors.push({\n        title: 'Unbalanced parentheses in Newick string',\n        message: (parenLevels > 0\n          ? `You have ${parenLevels} too many open parentheses`\n          : `You have ${-parenLevels} too few open parentheses`\n        ),\n      });\n    }\n\n    // Finally, try parsing it with parseNewick and see if we get an error.\n    try {\n      parseNewick(newickTrimmed);\n    } catch (ex) {\n      errors.push({\n        title: 'Error parsing phylogeny',\n        message: `An error occured while parsing this phylogeny: ${ex.message}`,\n      });\n    }\n\n    return errors;\n  }\n\n  static recurseNodes(node, func, nodeCount = 0, parentCount = undefined) {\n    // Recurse through PhyloTree nodes, executing function on each node.\n    //  - node: The node to recurse from. The function will be called on node\n    //          *before* being called on its children.\n    //  - func: The function to call on `node` and all of its children.\n    //  - nodeCount: `node` will be called with this nodeCount. All of its\n    //          children will be called with consecutively increasing nodeCounts.\n    //  - parentCount: The nodeCount associated with the parent of this node\n    //          within this run of recurseNodes. For instance, immediate children\n    //          of `node` will have a parentCount of 0. By default, `node` itself\n    //          will have a parentCount of `undefined`.\n    // When the function `func` is called, it is given three arguments:\n    //  - The current node object (initially: `node`)\n    //  - The count of the current node object (initially: `nodeCount`)\n    //  - The parent count of the current node object (initially: `parentCount`)\n    func(node, nodeCount, parentCount);\n\n    let nextID = nodeCount + 1;\n\n    // Recurse through all children of this node.\n    if (has(node, 'children')) {\n      node.children.forEach((child) => {\n        nextID = PhylogenyWrapper.recurseNodes(\n          child,\n          func,\n          nextID,\n          nodeCount\n        );\n      });\n    }\n\n    return nextID;\n  }\n\n  getTaxonomicUnits(nodeType = 'both') {\n    // Return a list of all taxonomic units in this phylogeny.\n    // Node labels will be extracted from:\n    //  - internal nodes only (if nodeType == 'internal')\n    //  - terminal nodes only (if nodeType == 'terminal')\n    //  - both internal and terminal nodes (if nodeType == 'both')\n    //\n    // See `getTaxonomicUnitsForNodeLabel` to see how node labels are converted\n    // into node labels, but in brief:\n    //  1. We look for taxonomic units in the additionalNodeProperties.\n    //  2. If none are found, we attempt to parse the node label as a scientific name.\n    //\n    const nodeLabels = this.getNodeLabels(nodeType);\n    const tunits = new Set();\n\n    nodeLabels.forEach(\n      nodeLabel => this.getTaxonomicUnitsForNodeLabel(nodeLabel)\n        .forEach(tunit => tunits.add(tunit))\n    );\n\n    return tunits;\n  }\n\n  getNodeLabels(nodeType = 'both') {\n    // Return a list of all the node labels in this phylogeny.\n    //\n    // nodeType can be one of:\n    // - 'internal': Return node labels on internal nodes.\n    // - 'terminal': Return node labels on terminal nodes.\n    // - 'both': Return node labels on both internal and terminal nodes.\n\n    // Parse the phylogeny (will throw an exception if parsing failed).\n    const { graph } = parseNewick(this.phylogeny.newick || '()');\n    const [vertices, arcs] = graph;\n\n    if (nodeType === 'both') {\n      // Return all node labels.\n      return Array.from(\n        new Set(\n          Array.from(vertices)\n            .map(vertex => vertex.label)\n            .filter(label => label !== undefined)\n        )\n      );\n    }\n\n    if (nodeType === 'internal') {\n      // Return the internal nodes (those with atleast one child).\n      return Array.from(new Set(\n        Array.from(arcs)\n          .map(arc => arc[0].label) // Retrieve the label of the parent vertex in this arc.\n          .filter(label => label !== undefined)\n      ));\n    }\n\n    if (nodeType === 'terminal') {\n      // Return the terminal nodes. This would require calculating the children\n      // of every vertex in the graph and then identifying vertices without any\n      // children.\n      //\n      // A quicker and dirtier way to do this is by removing internal labels\n      // from the list of all node labels. This will report an incorrect result\n      // if an internal node has the same label as a terminal node, but at that\n      // point a lot of other assumptions are going to fail, too, so this is\n      // probably good enough for now.\n      const allLabels = this.getNodeLabels('both');\n      const internalLabels = new Set(this.getNodeLabels('internal'));\n\n      return allLabels.filter(label => !internalLabels.has(label));\n    }\n\n    throw new Error(`Unknown nodeType: '${nodeType}'`);\n  }\n\n  getTaxonomicUnitsForNodeLabel(nodeLabel) {\n    // Return a list of taxonomic units for a node label.\n\n    // Look up additional node properties.\n    let additionalNodeProperties = {};\n    if (\n      has(this.phylogeny, 'additionalNodeProperties')\n      && has(this.phylogeny.additionalNodeProperties, nodeLabel)\n    ) {\n      additionalNodeProperties = this.phylogeny.additionalNodeProperties[nodeLabel];\n    }\n\n    // If there are explicit taxonomic units in the\n    // representsTaxonomicUnits property, we need to use those.\n    if (has(additionalNodeProperties, 'representsTaxonomicUnits')) {\n      return additionalNodeProperties.representsTaxonomicUnits;\n    }\n\n    // If that doesn't work, we can try to extract scientific names from\n    // the node label. Note that taxonomic units will NOT be extracted from\n    // the label if there is a taxonomic unit present!\n    return TaxonomicUnitWrapper.getTaxonomicUnitsFromNodeLabel(nodeLabel.trim());\n  }\n\n  getNodeLabelsMatchedBySpecifier(specifier) {\n    // Return a list of node labels matched by a given specifier on\n    // a given phylogeny.\n\n    // Does the specifier have any taxonomic units? If not, we can't\n    // match anything!\n    if (!has(specifier, 'referencesTaxonomicUnits')) { return []; }\n    const specifierTUnits = specifier.referencesTaxonomicUnits;\n\n    return this.getNodeLabels().filter((nodeLabel) => {\n      // Find all the taxonomic units associated with the specifier and\n      // with the node.\n      const nodeTUnits = this.getTaxonomicUnitsForNodeLabel(nodeLabel);\n\n      // Attempt pairwise matches between taxonomic units in the specifier\n      // and associated with the node.\n      return specifierTUnits.some(\n        tunit1 => nodeTUnits.some(\n          tunit2 => new TaxonomicUnitMatcher(tunit1, tunit2).matched\n        )\n      );\n    });\n  }\n\n  static getParsedNewick(newick) {\n    // We previously used phylotree.js's Newick parser to parse Newick into a\n    // tree-like structure. However, this is difficult to integrate using NPM.\n    // This method provides a similar facility using the newick-js library.\n    //\n    // Throws an exception if the Newick could not be parsed.\n    const { graph, root, rootWeight } = parseNewick(newick);\n    const [, arcs] = graph;\n\n    // Go through the arcs, assigning 'children' to the appropriate parent node.\n    arcs.forEach((arc) => {\n      const [parent, child, weight] = arc;\n\n      // Add child to parent.children.\n      if (!has(parent, 'children')) parent.children = [];\n      parent.children.push(child);\n\n      // Phylotree.js uses 'name' instead of 'label'.\n      if (has(parent, 'label')) { parent.name = parent.label; }\n      if (has(child, 'label')) { child.name = child.label; }\n\n      // Phylotree.js uses 'attribute' to store weights, so we'll store it there as well.\n      if (!has(child, 'attribute') && !Number.isNaN(weight)) child.attribute = weight;\n    });\n\n    // Set root 'attribute' to root weight.\n    if (!has(root, 'attribute') && !Number.isNaN(rootWeight)) root.attribute = rootWeight;\n\n    return { json: root };\n  }\n\n  getParsedNewickWithIRIs(baseURI, newickParser = PhylogenyWrapper.getParsedNewick) {\n    // Return the parsed Newick string, but with EVERY node given an IRI.\n    // parsedNewick: A Newick tree represented as a tree produced by Phylotree.\n    // baseURI: The base URI to use for node elements (e.g. ':phylogeny1').\n\n    const parsed = newickParser(this.phylogeny.newick || '()');\n    if (has(parsed, 'json')) {\n      PhylogenyWrapper.recurseNodes(parsed.json, (node, nodeCount) => {\n        // Start with the additional node properties.\n        const nodeAsJSONLD = node;\n\n        // Set @id and @type.\n        const nodeURI = `${baseURI}_node${nodeCount}`;\n        nodeAsJSONLD['@id'] = nodeURI;\n      });\n    }\n\n    return parsed;\n  }\n\n  getNodesAsJSONLD(baseURI, newickParser) {\n    // Returns a list of all nodes in this phylogeny as a series of nodes.\n    // - parsedNewick: A Newick tree parsed into a tree structure by Phylotree.\n    // - baseURI: The base URI to use for node elements (e.g. ':phylogeny1').\n\n    // List of nodes we have identified.\n    const nodes = [];\n\n    // We need to track the identifiers we give each node as we go.\n    const nodesById = {};\n    const nodeIdsByParentId = {};\n\n    // Extract the newick string.\n    const { additionalNodeProperties } = this.phylogeny;\n\n    // Parse the Newick string; if parseable, recurse through the nodes,\n    // added them to the list of JSON-LD nodes as we go.\n\n    const parsed = this.getParsedNewickWithIRIs(baseURI, newickParser);\n    if (has(parsed, 'json')) {\n      PhylogenyWrapper.recurseNodes(parsed.json, (node, nodeCount, parentCount) => {\n        // Start with the additional node properties.\n        const nodeAsJSONLD = {};\n\n        // Set @id and @type. '@id' should already be set by getParsedNewickWithIRIs()!\n        const nodeURI = node['@id'];\n        nodeAsJSONLD['@id'] = nodeURI;\n        nodeAsJSONLD['@type'] = 'http://purl.obolibrary.org/obo/CDAO_0000140';\n\n        // Add labels, additional node properties and taxonomic units.\n        if (has(node, 'name') && node.name !== '') {\n          // Add node label.\n          nodeAsJSONLD.labels = [node.name];\n\n          // Add additional node properties, if any.\n          if (additionalNodeProperties && has(additionalNodeProperties, node.name)) {\n            Object.keys(additionalNodeProperties[node.name]).forEach((key) => {\n              nodeAsJSONLD[key] = additionalNodeProperties[node.name][key];\n            });\n          }\n\n          // Add taxonomic units.\n          nodeAsJSONLD.representsTaxonomicUnits = this.getTaxonomicUnitsForNodeLabel(node.name);\n\n          // Apply @id and @type to each taxonomic unit.\n          let countTaxonomicUnits = 0;\n          nodeAsJSONLD.representsTaxonomicUnits.forEach((tunitToChange) => {\n            const tunit = tunitToChange;\n\n            tunit['@id'] = `${nodeURI}_taxonomicunit${countTaxonomicUnits}`;\n            tunit['@type'] = 'http://purl.obolibrary.org/obo/CDAO_0000138';\n            countTaxonomicUnits += 1;\n          });\n        }\n\n        // Add references to parents and siblings.\n        if (parentCount !== undefined) {\n          const parentURI = `${baseURI}_node${parentCount}`;\n          nodeAsJSONLD.parent = parentURI;\n\n          // Update list of nodes by parent IDs.\n          if (!has(nodeIdsByParentId, parentURI)) {\n            nodeIdsByParentId[parentURI] = new Set();\n          }\n          nodeIdsByParentId[parentURI].add(nodeURI);\n        }\n\n        // Add nodeAsJSONLD to list\n        if (has(nodesById, nodeURI)) {\n          throw new Error('Error in programming: duplicate node URI generated');\n        }\n        nodesById[nodeURI] = nodeAsJSONLD;\n        nodes.push(nodeAsJSONLD);\n      });\n    }\n\n    // Go through nodes again and set children and sibling relationships.\n    Object.keys(nodeIdsByParentId).forEach((parentId) => {\n      // What are the children of this parentId?\n      const childrenIDs = Array.from(nodeIdsByParentId[parentId]);\n      const children = childrenIDs.map(childId => nodesById[childId]);\n\n      // Is this the root node?\n      if (has(nodesById, parentId)) {\n        const parent = nodesById[parentId];\n        parent.children = childrenIDs;\n      }\n\n      children.forEach((child) => {\n        const childToModify = child;\n        // Add all other sibling to node.siblings, but don't add this node itself!\n        childToModify.siblings = childrenIDs.filter(childId => childId !== child['@id']);\n      });\n    });\n\n    return nodes;\n  }\n\n  asJSONLD(baseURI, newickParser) {\n    // Export this phylogeny as JSON-LD.\n\n    // Create a copy to export.\n    const phylogenyAsJSONLD = JSON.parse(JSON.stringify(this.phylogeny));\n\n    // Set name and class for phylogeny.\n    phylogenyAsJSONLD['@id'] = baseURI;\n    phylogenyAsJSONLD['@type'] = owlterms.PHYLOREFERENCE_PHYLOGENY;\n\n    // Translate nodes into JSON-LD objects.\n    phylogenyAsJSONLD.nodes = this.getNodesAsJSONLD(baseURI, newickParser);\n    if (phylogenyAsJSONLD.nodes.length > 0) {\n      // We don't have a better way to identify the root node, so we just\n      // default to the first one.\n      phylogenyAsJSONLD.hasRootNode = {\n        '@id': phylogenyAsJSONLD.nodes[0]['@id'],\n      };\n    }\n\n    return phylogenyAsJSONLD;\n  }\n}\n\nmodule.exports = {\n  PhylogenyWrapper,\n};\n",
    "static": true,
    "longname": "/home/vaidyagi/code/phyloref/phyx.js/src/wrappers/PhylogenyWrapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 89,
    "kind": "variable",
    "name": "has",
    "memberof": "src/wrappers/PhylogenyWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhylogenyWrapper.js~has",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhylogenyWrapper.js",
    "importStyle": null,
    "description": "PhylogenyWrapper",
    "lineNumber": 5,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 90,
    "kind": "variable",
    "name": "parse",
    "memberof": "src/wrappers/PhylogenyWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhylogenyWrapper.js~parse",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhylogenyWrapper.js",
    "importStyle": null,
    "description": "Used to parse Newick strings.",
    "lineNumber": 8,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 91,
    "kind": "variable",
    "name": "owlterms",
    "memberof": "src/wrappers/PhylogenyWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhylogenyWrapper.js~owlterms",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhylogenyWrapper.js",
    "importStyle": null,
    "description": "OWL terms to be used here.",
    "lineNumber": 11,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 92,
    "kind": "variable",
    "name": "TaxonomicUnitWrapper",
    "memberof": "src/wrappers/PhylogenyWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhylogenyWrapper.js~TaxonomicUnitWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhylogenyWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 93,
    "kind": "variable",
    "name": "TaxonomicUnitMatcher",
    "memberof": "src/wrappers/PhylogenyWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhylogenyWrapper.js~TaxonomicUnitMatcher",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhylogenyWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 94,
    "kind": "class",
    "name": "PhylogenyWrapper",
    "memberof": "src/wrappers/PhylogenyWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhylogenyWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 95,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true
  },
  {
    "__docId__": 96,
    "kind": "member",
    "name": "phylogeny",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "static": false,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper#phylogeny",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 97,
    "kind": "method",
    "name": "getErrorsInNewickString",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper.getErrorsInNewickString",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "params": [
      {
        "name": "newick",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 98,
    "kind": "method",
    "name": "recurseNodes",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper.recurseNodes",
    "access": "public",
    "description": null,
    "lineNumber": 87,
    "undocument": true,
    "params": [
      {
        "name": "node",
        "types": [
          "*"
        ]
      },
      {
        "name": "func",
        "types": [
          "*"
        ]
      },
      {
        "name": "nodeCount",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      },
      {
        "name": "parentCount",
        "optional": true,
        "types": [
          "*"
        ],
        "defaultRaw": "undefined",
        "defaultValue": "undefined"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 99,
    "kind": "method",
    "name": "getTaxonomicUnits",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper#getTaxonomicUnits",
    "access": "public",
    "description": null,
    "lineNumber": 121,
    "undocument": true,
    "params": [
      {
        "name": "nodeType",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "both",
        "defaultValue": "both"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 100,
    "kind": "method",
    "name": "getNodeLabels",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper#getNodeLabels",
    "access": "public",
    "description": null,
    "lineNumber": 144,
    "undocument": true,
    "params": [
      {
        "name": "nodeType",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "both",
        "defaultValue": "both"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 101,
    "kind": "method",
    "name": "getTaxonomicUnitsForNodeLabel",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper#getTaxonomicUnitsForNodeLabel",
    "access": "public",
    "description": null,
    "lineNumber": 195,
    "undocument": true,
    "params": [
      {
        "name": "nodeLabel",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 102,
    "kind": "method",
    "name": "getNodeLabelsMatchedBySpecifier",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper#getNodeLabelsMatchedBySpecifier",
    "access": "public",
    "description": null,
    "lineNumber": 219,
    "undocument": true,
    "params": [
      {
        "name": "specifier",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 103,
    "kind": "method",
    "name": "getParsedNewick",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper.getParsedNewick",
    "access": "public",
    "description": null,
    "lineNumber": 243,
    "undocument": true,
    "params": [
      {
        "name": "newick",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"json\": *}"
      ]
    }
  },
  {
    "__docId__": 104,
    "kind": "method",
    "name": "getParsedNewickWithIRIs",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper#getParsedNewickWithIRIs",
    "access": "public",
    "description": null,
    "lineNumber": 274,
    "undocument": true,
    "params": [
      {
        "name": "baseURI",
        "types": [
          "*"
        ]
      },
      {
        "name": "newickParser",
        "optional": true,
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 105,
    "kind": "method",
    "name": "getNodesAsJSONLD",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper#getNodesAsJSONLD",
    "access": "public",
    "description": null,
    "lineNumber": 294,
    "undocument": true,
    "params": [
      {
        "name": "baseURI",
        "types": [
          "*"
        ]
      },
      {
        "name": "newickParser",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 106,
    "kind": "method",
    "name": "asJSONLD",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper#asJSONLD",
    "access": "public",
    "description": null,
    "lineNumber": 392,
    "undocument": true,
    "params": [
      {
        "name": "baseURI",
        "types": [
          "*"
        ]
      },
      {
        "name": "newickParser",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 107,
    "kind": "file",
    "name": "src/wrappers/PhylorefWrapper.js",
    "content": "/** Used to parse timestamps for phyloref statuses. */\nconst moment = require('moment');\nconst { has } = require('lodash');\n\nconst owlterms = require('../utils/owlterms');\nconst { TaxonomicUnitWrapper } = require('./TaxonomicUnitWrapper');\nconst { PhylogenyWrapper } = require('./PhylogenyWrapper');\n\n/**\n * PhylorefWrapper\n *\n */\n\nclass PhylorefWrapper {\n  // Wraps a phyloreference in a PHYX model.\n\n  constructor(phyloref) {\n    // Wraps the provided phyloreference\n    this.phyloref = phyloref;\n\n    // Reset internal and external specifiers if needed.\n    // if (!has(this.phyloref, 'internalSpecifiers'))\n    //  Vue.set(this.phyloref, 'internalSpecifiers', []);\n    if (!has(this.phyloref, 'internalSpecifiers')) {\n      this.phyloref.internalSpecifiers = [];\n    }\n    // if (!has(this.phyloref, 'externalSpecifiers'))\n    //  Vue.set(this.phyloref, 'externalSpecifiers', []);\n    if (!has(this.phyloref, 'externalSpecifiers')) {\n      this.phyloref.externalSpecifiers = [];\n    }\n  }\n\n  get label() {\n    // Return a label for this phyloreference.\n    if (has(this.phyloref, 'label')) return this.phyloref.label;\n    if (has(this.phyloref, 'labels') && this.phyloref.labels.length > 0) return this.phyloref.labels[0];\n    if (has(this.phyloref, 'title')) return this.phyloref.title;\n\n    return undefined;\n  }\n\n  set label(newLabel) {\n    // Set a label for this phyloreference.\n    if (has(this.phyloref, 'label')) {\n      this.phyloref.label = newLabel;\n    } else {\n      // Vue.set(this.phyloref, 'label', newLabel);\n      this.phyloref.label = newLabel;\n    }\n  }\n\n  get specifiers() {\n    // Returns a list of all specifiers by combining the internal and external\n    // specifiers into a single list, with internal specifiers before\n    // external specifiers.\n    let specifiers = this.phyloref.internalSpecifiers;\n    specifiers = specifiers.concat(this.phyloref.externalSpecifiers);\n    return specifiers;\n  }\n\n  getSpecifierType(specifier) {\n    // For a given specifier, return a string indicating whether it is\n    // an 'Internal' or 'External' specifier.\n\n    if (this.phyloref.internalSpecifiers.includes(specifier)) return 'Internal';\n    if (this.phyloref.externalSpecifiers.includes(specifier)) return 'External';\n    return 'Specifier';\n  }\n\n  setSpecifierType(specifier, specifierType) {\n    // Change the type of a given specifier. To do this, we first need\n    // to determine if it was originally an internal or external\n    // specifier, then move it into the other list.\n\n    let index;\n    if (specifierType === 'Internal') {\n      // To set a specifier to 'Internal', we might need to delete it from the\n      // list of external specifiers first.\n      index = this.phyloref.externalSpecifiers.indexOf(specifier);\n      if (index !== -1) this.phyloref.externalSpecifiers.splice(index, 1);\n\n      // Don't add it to the list of internal specifiers if it's already there.\n      if (!this.phyloref.internalSpecifiers.includes(specifier)) {\n        this.phyloref.internalSpecifiers.unshift(specifier);\n      }\n    } else if (specifierType === 'External') {\n      // To set a specifier to 'External', we might need to delete it from the\n      // list of internal specifiers first.\n      index = this.phyloref.internalSpecifiers.indexOf(specifier);\n      if (index !== -1) this.phyloref.internalSpecifiers.splice(index, 1);\n\n      // Don't add it to the list of internal specifiers if it's already there.\n      if (!this.phyloref.externalSpecifiers.includes(specifier)) {\n        this.phyloref.externalSpecifiers.unshift(specifier);\n      }\n    } else {\n      // Neither internal nor external? Ignore.\n    }\n  }\n\n  deleteSpecifier(specifier) {\n    // Since the user interface combines specifiers into a single list,\n    // it doesn't remember if the specifier to be deleted is internal\n    // or external. We delete the intended specifier from both arrays.\n\n    let index = this.phyloref.internalSpecifiers.indexOf(specifier);\n    if (index !== -1) this.phyloref.internalSpecifiers.splice(index, 1);\n\n    index = this.phyloref.externalSpecifiers.indexOf(specifier);\n    if (index !== -1) this.phyloref.externalSpecifiers.splice(index, 1);\n  }\n\n  static getSpecifierLabel(specifier) {\n    // Try to determine the label of a specifier. This checks the\n    // 'label' and 'description' properties, and then tries to create a\n    // descriptive label by using the list of referenced taxonomic units.\n    //\n    // This logically belongs in PhylorefWrapper, but we don't actually need to\n    // know the phyloreference to figure out the specifier label, which is why\n    // this is a static method.\n\n    // Is this specifier even non-null?\n    if (specifier === undefined) return undefined;\n    if (specifier === null) return undefined;\n\n    // Maybe there is a label or description right there?\n    if (has(specifier, 'label')) return specifier.label;\n    if (has(specifier, 'description')) return specifier.description;\n\n    // Look at the individual taxonomic units.\n    if (has(specifier, 'referencesTaxonomicUnits')) {\n      const labels = specifier.referencesTaxonomicUnits\n        .map(tu => new TaxonomicUnitWrapper(tu).label)\n        .filter(label => (label !== undefined));\n      if (labels.length > 0) return labels.join('; ');\n    }\n\n    // No idea!\n    return undefined;\n  }\n\n  getExpectedNodeLabels(phylogeny) {\n    // Given a phylogeny, determine which node labels we expect this phyloref to\n    // resolve to. To do this, we:\n    //  1. Find all node labels that are case-sensitively identical\n    //     to the phyloreference.\n    //  2. Find all node labels that have additionalNodeProperties with\n    //     expectedPhyloreferenceNamed case-sensitively identical to\n    //     the phyloreference.\n    const phylorefLabel = this.label;\n    const nodeLabels = new Set();\n\n    new PhylogenyWrapper(phylogeny).getNodeLabels().forEach((nodeLabel) => {\n      // Is this node label identical to the phyloreference name?\n      if (nodeLabel === phylorefLabel) {\n        nodeLabels.add(nodeLabel);\n      } else if (\n        has(phylogeny, 'additionalNodeProperties')\n        && has(phylogeny.additionalNodeProperties, nodeLabel)\n        && has(phylogeny.additionalNodeProperties[nodeLabel], 'expectedPhyloreferenceNamed')\n      ) {\n        // Does this node label have an expectedPhyloreferenceNamed that\n        // includes this phyloreference name?\n\n        const expectedPhylorefs = phylogeny\n          .additionalNodeProperties[nodeLabel]\n          .expectedPhyloreferenceNamed;\n\n        if (expectedPhylorefs.includes(phylorefLabel)) {\n          nodeLabels.add(nodeLabel);\n        }\n      }\n    });\n\n    // Return node labels sorted alphabetically.\n    return Array.from(nodeLabels).sort();\n  }\n\n  static getStatusCURIEsInEnglish() {\n    // Return dictionary of all phyloref statuses in English\n    return {\n      'pso:draft': 'Draft',\n      'pso:final-draft': 'Final draft',\n      'pso:under-review': 'Under review',\n      'pso:submitted': 'Tested',\n      'pso:published': 'Published',\n      'pso:retracted-from-publication': 'Retracted',\n    };\n  }\n\n  getCurrentStatus() {\n    // Return a result object that contains:\n    //  - status: phyloreference status as a short URI (CURIE)\n    //  - statusInEnglish: an English representation of the phyloref status\n    //  - intervalStart: the start of the interval\n    //  - intervalEnd: the end of the interval\n\n    if (\n      has(this.phyloref, 'pso:holdsStatusInTime')\n      && Array.isArray(this.phyloref['pso:holdsStatusInTime'])\n      && this.phyloref['pso:holdsStatusInTime'].length > 0\n    ) {\n      // If we have any pso:holdsStatusInTime entries, pick the first one and\n      // extract the CURIE and time interval information from it.\n      const lastStatusInTime = this.phyloref['pso:holdsStatusInTime'][this.phyloref['pso:holdsStatusInTime'].length - 1];\n      const statusCURIE = lastStatusInTime['pso:withStatus']['@id'];\n\n      // Look for time interval information\n      let intervalStart;\n      let intervalEnd;\n\n      if (has(lastStatusInTime, 'tvc:atTime')) {\n        const atTime = lastStatusInTime['tvc:atTime'];\n        if (has(atTime, 'timeinterval:hasIntervalStartDate')) intervalStart = atTime['timeinterval:hasIntervalStartDate'];\n        if (has(atTime, 'timeinterval:hasIntervalEndDate')) intervalEnd = atTime['timeinterval:hasIntervalEndDate'];\n      }\n\n      // Return result object\n      return {\n        statusCURIE,\n        statusInEnglish: PhylorefWrapper.getStatusCURIEsInEnglish()[statusCURIE],\n        intervalStart,\n        intervalEnd,\n      };\n    }\n\n    // If we couldn't figure out a status for this phyloref, assume it's a draft.\n    return {\n      statusCURIE: 'pso:draft',\n      statusInEnglish: PhylorefWrapper.getStatusCURIEsInEnglish()['pso:draft'],\n    };\n  }\n\n  getStatusChanges() {\n    // Return a list of status changes for a particular phyloreference\n    if (has(this.phyloref, 'pso:holdsStatusInTime')) {\n      return this.phyloref['pso:holdsStatusInTime'].map((entry) => {\n        const result = {};\n\n        // Create a statusCURIE convenience field.\n        if (has(entry, 'pso:withStatus')) {\n          result.statusCURIE = entry['pso:withStatus']['@id'];\n          result.statusInEnglish = PhylorefWrapper.getStatusCURIEsInEnglish()[result.statusCURIE];\n        }\n\n        // Create intervalStart/intervalEnd convenient fields\n        if (has(entry, 'tvc:atTime')) {\n          const atTime = entry['tvc:atTime'];\n          if (has(atTime, 'timeinterval:hasIntervalStartDate')) {\n            result.intervalStart = atTime['timeinterval:hasIntervalStartDate'];\n            result.intervalStartAsCalendar = moment(result.intervalStart).calendar();\n          }\n\n          if (has(atTime, 'timeinterval:hasIntervalEndDate')) {\n            result.intervalEnd = atTime['timeinterval:hasIntervalEndDate'];\n            result.intervalEndAsCalendar = moment(result.intervalEnd).calendar();\n          }\n        }\n\n        return result;\n      });\n    }\n\n    // No changes? Return an empty list.\n    return [];\n  }\n\n  setStatus(status) {\n    // Set the status of a phyloreference\n    //\n    // Check whether we have a valid status CURIE.\n    if (!has(PhylorefWrapper.getStatusCURIEsInEnglish(), status)) {\n      throw new TypeError(`setStatus() called with invalid status CURIE '${status}'`);\n    }\n\n    // See if we can end the previous interval.\n    const currentTime = new Date(Date.now()).toISOString();\n\n    if (!has(this.phyloref, 'pso:holdsStatusInTime')) {\n      // Vue.set(this.phyloref, 'pso:holdsStatusInTime', []);\n      this.phyloref['pso:holdsStatusInTime'] = [];\n    }\n\n    // Check to see if there's a previous time interval we should end.\n    if (\n      Array.isArray(this.phyloref['pso:holdsStatusInTime'])\n      && this.phyloref['pso:holdsStatusInTime'].length > 0\n    ) {\n      const lastStatusInTime = this.phyloref['pso:holdsStatusInTime'][this.phyloref['pso:holdsStatusInTime'].length - 1];\n\n      // if (!has(lastStatusInTime, 'tvc:atTime'))\n      //  Vue.set(lastStatusInTime, 'tvc:atTime', {});\n      if (!has(lastStatusInTime, 'tvc:atTime')) {\n        lastStatusInTime['tvc:atTime'] = {};\n      }\n      if (!has(lastStatusInTime['tvc:atTime'], 'timeinterval:hasIntervalEndDate')) {\n        // If the last time entry doesn't already have an interval end date, set it to now.\n        lastStatusInTime['tvc:atTime']['timeinterval:hasIntervalEndDate'] = currentTime;\n      }\n    }\n\n    // Create new entry.\n    this.phyloref['pso:holdsStatusInTime'].push({\n      '@type': 'http://purl.org/spar/pso/StatusInTime',\n      'pso:withStatus': { '@id': status },\n      'tvc:atTime': {\n        'timeinterval:hasIntervalStartDate': currentTime,\n      },\n    });\n  }\n\n  asJSONLD(phylorefURI) {\n    // Export this phyloreference in JSON-LD.\n\n    // Keep all currently extant data.\n    // - baseURI: the base URI for this phyloreference\n    const phylorefAsJSONLD = JSON.parse(JSON.stringify(this.phyloref));\n\n    // Set the @id and @type.\n    phylorefAsJSONLD['@id'] = phylorefURI;\n\n    phylorefAsJSONLD['@type'] = [\n      // We pun this as an instance that is a Phyloreference.\n      // (We need this to ensure that the object properties that store\n      // information on specifiers will work correctly)\n      'phyloref:Phyloreference',\n      // Since we're writing this in RDF, just adding a '@type' of\n      // phyloref:Phyloreference would imply that phylorefURI is a named\n      // individual of class phyloref:Phyloreference. We need to explicitly\n      // let OWL know that this phylorefURI is an owl:Class.\n      //\n      // (This is implied by some of the properties that we apply to phylorefURI,\n      // such as by the domain of owl:equivalentClass. But it's nice to make that\n      // explicit as well!)\n      'owl:Class',\n    ];\n\n    // Add identifiers for each internal specifier.\n    let internalSpecifierCount = 0;\n    phylorefAsJSONLD.internalSpecifiers.forEach((internalSpecifierToChange) => {\n      internalSpecifierCount += 1;\n\n      const internalSpecifier = internalSpecifierToChange;\n      const specifierId = `${phylorefURI}_specifier_internal${internalSpecifierCount}`;\n\n      internalSpecifier['@id'] = specifierId;\n      internalSpecifier['@type'] = [\n        owlterms.TESTCASE_SPECIFIER,\n      ];\n\n      // Add identifiers to all taxonomic units.\n      let countTaxonomicUnits = 0;\n      if (has(internalSpecifier, 'referencesTaxonomicUnits')) {\n        internalSpecifier.referencesTaxonomicUnits.forEach((tunitToChange) => {\n          const tunit = tunitToChange;\n\n          tunit['@id'] = `${specifierId}_tunit${countTaxonomicUnits}`;\n          tunit['@type'] = 'http://purl.obolibrary.org/obo/CDAO_0000138';\n          countTaxonomicUnits += 1;\n        });\n      }\n    });\n\n    // Add identifiers for each external specifier.\n    let externalSpecifierCount = 0;\n    phylorefAsJSONLD.externalSpecifiers.forEach((externalSpecifierToChange) => {\n      externalSpecifierCount += 1;\n\n      const externalSpecifier = externalSpecifierToChange;\n      const specifierId = `${phylorefURI}_specifier_external${externalSpecifierCount}`;\n\n      externalSpecifier['@id'] = specifierId;\n      externalSpecifier['@type'] = [\n        owlterms.TESTCASE_SPECIFIER,\n      ];\n\n      // Add identifiers to all taxonomic units.\n      let countTaxonomicUnits = 0;\n      if (has(externalSpecifier, 'referencesTaxonomicUnits')) {\n        externalSpecifier.referencesTaxonomicUnits.forEach((tunitToChange) => {\n          const tunit = tunitToChange;\n\n          tunit['@id'] = `${specifierId}_tunit${countTaxonomicUnits}`;\n          tunit['@type'] = 'http://purl.obolibrary.org/obo/CDAO_0000138';\n          countTaxonomicUnits += 1;\n        });\n      }\n    });\n\n    // For historical reasons, the Clade Ontology uses 'hasInternalSpecifier' to\n    // store the specifiers as OWL classes and 'internalSpecifiers' to store them\n    // as RDF annotations. We simplify that here by duplicating them here, but\n    // this should really be fixed in the Clade Ontology and in phyx.json.\n    phylorefAsJSONLD.hasInternalSpecifier = phylorefAsJSONLD.internalSpecifiers;\n    phylorefAsJSONLD.hasExternalSpecifier = phylorefAsJSONLD.externalSpecifiers;\n\n    if (internalSpecifierCount === 0 && externalSpecifierCount === 0) {\n      phylorefAsJSONLD.malformedPhyloreference = 'No specifiers provided';\n    } else if (externalSpecifierCount > 1) {\n      phylorefAsJSONLD.malformedPhyloreference = 'Multiple external specifiers are not yet supported';\n    } else if (internalSpecifierCount === 1 && externalSpecifierCount === 0) {\n      phylorefAsJSONLD.malformedPhyloreference = 'Only a single internal specifier was provided';\n    } else if (externalSpecifierCount === 0) {\n      // This phyloreference is made up entirely of internal specifiers.\n\n      // We can write this in an accumulative manner by creating class expressions\n      // in the form:\n      //  mrca(mrca(mrca(node1, node2), node3), node4)\n\n      // We could write this as a single giant expression, but this tends to\n      // slow down the reasoner dramatically. So instead, we break it up into a\n      // series of \"additional classes\", each of which represents a part of the\n      // overall expression.\n      phylorefAsJSONLD.hasAdditionalClass = [];\n\n      let equivalentClassAccumulator = PhylorefWrapper.getClassExpressionForMRCA(\n        phylorefURI,\n        phylorefAsJSONLD.hasAdditionalClass,\n        phylorefAsJSONLD.internalSpecifiers[0],\n        phylorefAsJSONLD.internalSpecifiers[1]\n      );\n\n      for (let index = 2; index < internalSpecifierCount; index += 1) {\n        equivalentClassAccumulator = PhylorefWrapper.getClassExpressionForMRCA(\n          phylorefURI,\n          phylorefAsJSONLD.hasAdditionalClass,\n          equivalentClassAccumulator,\n          phylorefAsJSONLD.internalSpecifiers[index]\n        );\n      }\n\n      phylorefAsJSONLD.equivalentClass = equivalentClassAccumulator;\n    } else {\n      // This phyloreference is made up of one external specifier and some number\n      // of internal specifiers.\n\n      const internalSpecifierRestrictions = phylorefAsJSONLD.internalSpecifiers\n        .map(specifier => PhylorefWrapper\n          .wrapInternalOWLRestriction(PhylorefWrapper.getOWLRestrictionForSpecifier(specifier)));\n\n      const externalSpecifierRestrictions = phylorefAsJSONLD.externalSpecifiers\n        .map(specifier => PhylorefWrapper\n          .wrapExternalOWLRestriction(PhylorefWrapper.getOWLRestrictionForSpecifier(specifier)));\n\n      phylorefAsJSONLD.equivalentClass = {\n        '@type': 'owl:Class',\n        intersectionOf: internalSpecifierRestrictions.concat(externalSpecifierRestrictions),\n      };\n    }\n\n    return phylorefAsJSONLD;\n  }\n\n  static getOWLRestrictionForSpecifier(specifier) {\n    // Return an OWL restriction corresponding to a specifier.\n    return {\n      '@type': 'owl:Restriction',\n      onProperty: 'testcase:matches_specifier',\n      hasValue: {\n        '@id': specifier['@id'],\n      },\n    };\n  }\n\n  static wrapInternalOWLRestriction(restriction) {\n    // Wraps a restriction to act as an internal specifier.\n    // Mainly, we just need to extend the restriction to match:\n    //  restriction or cdao:has_Descendant some restriction\n    return {\n      '@type': 'owl:Restriction',\n      unionOf: [\n        restriction,\n        {\n          '@type': 'owl:Restriction',\n          onProperty: owlterms.CDAO_HAS_DESCENDANT,\n          someValuesFrom: restriction,\n        },\n      ],\n    };\n  }\n\n  static wrapExternalOWLRestriction(restriction) {\n    // Wraps a restriction to act as an external specifier.\n    // This needs to match:\n    //  cdao:has_Sibling some (restriction or cdao:has_Descendant some restriction)\n    // Since that second part is just an internal specifier restriction, we can\n    // incorporate that in here.\n    return {\n      '@type': 'owl:Restriction',\n      // onProperty: PHYLOREF_HAS_SIBLING,\n      onProperty: owlterms.PHYLOREF_EXCLUDES_LINEAGE_TO,\n      someValuesFrom: restriction,\n    };\n  }\n\n  static getClassExpressionForMRCA(baseURI, additionalClasses, specifier1, specifier2) {\n    // Create an OWL restriction for the most recent common ancestor (MRCA)\n    // of the nodes matched by two specifiers.\n    const additionalClassesIds = new Set(additionalClasses.map(cl => cl['@id']));\n\n    // Specifiers might be either a real specifier or an additional class.\n    // We can check their @ids here and translate specifiers into class expressions.\n    let owlRestriction1;\n    if (additionalClassesIds.has(specifier1['@id'])) {\n      owlRestriction1 = specifier1;\n    } else {\n      owlRestriction1 = PhylorefWrapper.getOWLRestrictionForSpecifier(specifier1);\n    }\n\n    let owlRestriction2;\n    if (additionalClassesIds.has(specifier2['@id'])) {\n      owlRestriction2 = specifier2;\n    } else {\n      owlRestriction2 = PhylorefWrapper.getOWLRestrictionForSpecifier(specifier2);\n    }\n\n    // Construct OWL expression.\n    const mrcaAsOWL = {\n      '@type': 'owl:Class',\n      unionOf: [\n        {\n          // What if specifier2 is a descendant of specifier1? If so, the MRCA\n          // is specifier1!\n          '@type': 'owl:Class',\n          intersectionOf: [\n            owlRestriction1,\n            {\n              '@type': 'owl:Restriction',\n              onProperty: owlterms.CDAO_HAS_DESCENDANT,\n              someValuesFrom: owlRestriction2,\n            },\n          ],\n        },\n        {\n          // What if specifier1 is a descendant of specifier2? If so, the MRCA\n          // is specifier2!\n          '@type': 'owl:Class',\n          intersectionOf: [\n            owlRestriction2,\n            {\n              '@type': 'owl:Restriction',\n              onProperty: owlterms.CDAO_HAS_DESCENDANT,\n              someValuesFrom: owlRestriction1,\n            },\n          ],\n        },\n        {\n          // If neither specifier is a descendant of the other, we can use our\n          // standard formula.\n          '@type': 'owl:Class',\n          intersectionOf: [{\n            '@type': 'owl:Restriction',\n            onProperty: owlterms.CDAO_HAS_CHILD,\n            someValuesFrom: {\n              '@type': 'owl:Class',\n              intersectionOf: [\n                PhylorefWrapper.wrapInternalOWLRestriction(owlRestriction1),\n                PhylorefWrapper.wrapExternalOWLRestriction(owlRestriction2),\n              ],\n            },\n          }, {\n            '@type': 'owl:Restriction',\n            onProperty: owlterms.CDAO_HAS_CHILD,\n            someValuesFrom: {\n              '@type': 'owl:Class',\n              intersectionOf: [\n                PhylorefWrapper.wrapInternalOWLRestriction(owlRestriction2),\n                PhylorefWrapper.wrapExternalOWLRestriction(owlRestriction1),\n              ],\n            },\n          }],\n        },\n      ],\n    };\n\n    // Instead of building a single, large, complex expression, reasoners appear\n    // to prefer smaller expressions for classes that are assembled together.\n    // To help with that, we'll store the class expression in the additionalClasses\n    // list, and return a reference to this class.\n    const additionalClassId = `${baseURI}_additional${additionalClasses.length}`;\n    additionalClasses.push({\n      '@id': additionalClassId,\n      '@type': 'owl:Class',\n      equivalentClass: mrcaAsOWL,\n    });\n\n    return { '@id': additionalClassId };\n  }\n}\n\nmodule.exports = {\n  PhylorefWrapper,\n};\n",
    "static": true,
    "longname": "/home/vaidyagi/code/phyloref/phyx.js/src/wrappers/PhylorefWrapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 108,
    "kind": "variable",
    "name": "moment",
    "memberof": "src/wrappers/PhylorefWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~moment",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhylorefWrapper.js",
    "importStyle": null,
    "description": "Used to parse timestamps for phyloref statuses.",
    "lineNumber": 2,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 109,
    "kind": "variable",
    "name": "has",
    "memberof": "src/wrappers/PhylorefWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~has",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhylorefWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 110,
    "kind": "variable",
    "name": "owlterms",
    "memberof": "src/wrappers/PhylorefWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~owlterms",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhylorefWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 111,
    "kind": "variable",
    "name": "TaxonomicUnitWrapper",
    "memberof": "src/wrappers/PhylorefWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~TaxonomicUnitWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhylorefWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 112,
    "kind": "variable",
    "name": "PhylogenyWrapper",
    "memberof": "src/wrappers/PhylorefWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylogenyWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhylorefWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 113,
    "kind": "class",
    "name": "PhylorefWrapper",
    "memberof": "src/wrappers/PhylorefWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhylorefWrapper.js",
    "importStyle": null,
    "description": "PhylorefWrapper",
    "lineNumber": 14,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 114,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true
  },
  {
    "__docId__": 115,
    "kind": "member",
    "name": "phyloref",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#phyloref",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 116,
    "kind": "get",
    "name": "label",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#label",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 117,
    "kind": "set",
    "name": "label",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#label",
    "access": "public",
    "description": null,
    "lineNumber": 43,
    "undocument": true
  },
  {
    "__docId__": 118,
    "kind": "get",
    "name": "specifiers",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#specifiers",
    "access": "public",
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 119,
    "kind": "method",
    "name": "getSpecifierType",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#getSpecifierType",
    "access": "public",
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "params": [
      {
        "name": "specifier",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 120,
    "kind": "method",
    "name": "setSpecifierType",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#setSpecifierType",
    "access": "public",
    "description": null,
    "lineNumber": 71,
    "undocument": true,
    "params": [
      {
        "name": "specifier",
        "types": [
          "*"
        ]
      },
      {
        "name": "specifierType",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 121,
    "kind": "method",
    "name": "deleteSpecifier",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#deleteSpecifier",
    "access": "public",
    "description": null,
    "lineNumber": 102,
    "undocument": true,
    "params": [
      {
        "name": "specifier",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 122,
    "kind": "method",
    "name": "getSpecifierLabel",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper.getSpecifierLabel",
    "access": "public",
    "description": null,
    "lineNumber": 114,
    "undocument": true,
    "params": [
      {
        "name": "specifier",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "getExpectedNodeLabels",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#getExpectedNodeLabels",
    "access": "public",
    "description": null,
    "lineNumber": 143,
    "undocument": true,
    "params": [
      {
        "name": "phylogeny",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 124,
    "kind": "method",
    "name": "getStatusCURIEsInEnglish",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper.getStatusCURIEsInEnglish",
    "access": "public",
    "description": null,
    "lineNumber": 180,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "{\"pso:draft\": string, \"pso:final-draft\": string, \"pso:under-review\": string, \"pso:submitted\": string, \"pso:published\": string, \"pso:retracted-from-publication\": string}"
      ]
    }
  },
  {
    "__docId__": 125,
    "kind": "method",
    "name": "getCurrentStatus",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#getCurrentStatus",
    "access": "public",
    "description": null,
    "lineNumber": 192,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "{\"statusCURIE\": string, \"statusInEnglish\": *}"
      ]
    }
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "getStatusChanges",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#getStatusChanges",
    "access": "public",
    "description": null,
    "lineNumber": 235,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 127,
    "kind": "method",
    "name": "setStatus",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#setStatus",
    "access": "public",
    "description": null,
    "lineNumber": 269,
    "undocument": true,
    "params": [
      {
        "name": "status",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 128,
    "kind": "method",
    "name": "asJSONLD",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#asJSONLD",
    "access": "public",
    "description": null,
    "lineNumber": 313,
    "undocument": true,
    "params": [
      {
        "name": "phylorefURI",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 129,
    "kind": "method",
    "name": "getOWLRestrictionForSpecifier",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper.getOWLRestrictionForSpecifier",
    "access": "public",
    "description": null,
    "lineNumber": 455,
    "undocument": true,
    "params": [
      {
        "name": "specifier",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"@type\": string, \"onProperty\": string, \"hasValue\": *}"
      ]
    }
  },
  {
    "__docId__": 130,
    "kind": "method",
    "name": "wrapInternalOWLRestriction",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper.wrapInternalOWLRestriction",
    "access": "public",
    "description": null,
    "lineNumber": 466,
    "undocument": true,
    "params": [
      {
        "name": "restriction",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"@type\": string, \"unionOf\": *}"
      ]
    }
  },
  {
    "__docId__": 131,
    "kind": "method",
    "name": "wrapExternalOWLRestriction",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper.wrapExternalOWLRestriction",
    "access": "public",
    "description": null,
    "lineNumber": 483,
    "undocument": true,
    "params": [
      {
        "name": "restriction",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"@type\": string, \"onProperty\": *, \"someValuesFrom\": *}"
      ]
    }
  },
  {
    "__docId__": 132,
    "kind": "method",
    "name": "getClassExpressionForMRCA",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper.getClassExpressionForMRCA",
    "access": "public",
    "description": null,
    "lineNumber": 497,
    "undocument": true,
    "params": [
      {
        "name": "baseURI",
        "types": [
          "*"
        ]
      },
      {
        "name": "additionalClasses",
        "types": [
          "*"
        ]
      },
      {
        "name": "specifier1",
        "types": [
          "*"
        ]
      },
      {
        "name": "specifier2",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"@id\": *}"
      ]
    }
  },
  {
    "__docId__": 133,
    "kind": "file",
    "name": "src/wrappers/PhyxWrapper.js",
    "content": "/** Used to make deep copies of objects. */\nconst extend = require('extend');\nconst { has } = require('lodash');\n\nconst owlterms = require('../utils/owlterms');\n\nconst { PhylorefWrapper } = require('./PhylorefWrapper');\nconst { PhylogenyWrapper } = require('./PhylogenyWrapper');\nconst { TaxonomicUnitMatcher } = require('../matchers/TaxonomicUnitMatcher');\n\n/* PHYX file wrapper */\n\nclass PhyxWrapper {\n  // Wraps an entire PHYX document.\n\n  constructor(phyx, newickParser) {\n    // Wraps an entire PHYX document.\n    // - phyx: the Phyx structure to wrap.\n    // - newickParser: a method that accepts a Newick string and returns a list of\n    //   nodes. Each node should have a 'children' key with its children and\n    //   optionally a 'name' key with its label. This code previously depended\n    //   on phylotree.js, whose newick_parser() function works exactly like this.\n    //   This option allows you to drop in Phylotree's newick_parser() or --\n    //   if you prefer -- any other option.\n    this.phyx = phyx;\n    this.newickParser = newickParser;\n  }\n\n  static get BASE_URI() {\n    // Returns the default base URI for PHYX documents in JSON-LD.\n    return '';\n  }\n\n  static getBaseURIForPhyloref(phylorefCount) {\n    // Return the base URI for a phyloreference based on its index.\n    return `${PhyxWrapper.BASE_URI}#phyloref${phylorefCount}`;\n  }\n\n  static getBaseURIForPhylogeny(phylogenyCount) {\n    // Return the base URI for phylogenies based on its index.\n    return `${PhyxWrapper.BASE_URI}#phylogeny${phylogenyCount}`;\n  }\n\n  static getBaseURIForTUMatch(countTaxonomicUnitMatches) {\n    // Return the base URI for taxonomic unit matches.\n    return `${PhyxWrapper.BASE_URI}#taxonomic_unit_match${countTaxonomicUnitMatches}`;\n  }\n\n  asJSONLD() {\n    // Export this PHYX document as a JSON-LD document. This replicates what\n    // phyx2owl.py does in the Clade Ontology.\n    //\n    // The document is mostly in JSON-LD already, except for two important\n    // things:\n    //  1. We have to convert all phylogenies into a series of statements\n    //     relating to the nodes inside these phylogenies.\n    //  2. We have to convert phylogenies into OWL restrictions.\n    //  3. Insert all matches between taxonomic units in this file.\n    //\n    const jsonld = extend(true, {}, this.phyx);\n\n    // Add descriptions for individual nodes in each phylogeny.\n    if (has(jsonld, 'phylogenies')) {\n      jsonld.phylogenies = jsonld.phylogenies.map(\n        (phylogeny, countPhylogeny) => new PhylogenyWrapper(phylogeny)\n          .asJSONLD(PhyxWrapper.getBaseURIForPhylogeny(countPhylogeny), this.newickParser)\n      );\n    }\n\n    // Convert phyloreferences into an OWL class restriction\n    if (has(jsonld, 'phylorefs')) {\n      jsonld.phylorefs = jsonld.phylorefs.map(\n        (phyloref, countPhyloref) => new PhylorefWrapper(phyloref)\n          .asJSONLD(PhyxWrapper.getBaseURIForPhyloref(countPhyloref))\n      );\n    }\n\n    // Match all specifiers with nodes.\n    if (has(jsonld, 'phylorefs') && has(jsonld, 'phylogenies')) {\n      jsonld.hasTaxonomicUnitMatches = [];\n\n      // Used to create unique identifiers for each taxonomic unit match.\n      let countTaxonomicUnitMatches = 0;\n\n      jsonld.phylorefs.forEach((phylorefToChange) => {\n        const phyloref = phylorefToChange;\n        let specifiers = [];\n\n        if (has(phyloref, 'internalSpecifiers')) {\n          specifiers = specifiers.concat(phyloref.internalSpecifiers);\n        }\n\n        if (has(phyloref, 'externalSpecifiers')) {\n          specifiers = specifiers.concat(phyloref.externalSpecifiers);\n        }\n\n        specifiers.forEach((specifier) => {\n          if (!has(specifier, 'referencesTaxonomicUnits')) return;\n          const specifierTUs = specifier.referencesTaxonomicUnits;\n          let nodesMatchedCount = 0;\n\n          jsonld.phylogenies.forEach((phylogenyToChange) => {\n            const phylogeny = phylogenyToChange;\n\n            specifierTUs.forEach((specifierTU) => {\n              phylogeny.nodes.forEach((node) => {\n                if (!has(node, 'representsTaxonomicUnits')) return;\n                const nodeTUs = node.representsTaxonomicUnits;\n\n                nodeTUs.forEach((nodeTU) => {\n                  const matcher = new TaxonomicUnitMatcher(specifierTU, nodeTU);\n                  if (matcher.matched) {\n                    const tuMatchAsJSONLD = matcher.asJSONLD(\n                      PhyxWrapper.getBaseURIForTUMatch(countTaxonomicUnitMatches)\n                    );\n                    jsonld.hasTaxonomicUnitMatches.push(tuMatchAsJSONLD);\n                    nodesMatchedCount += 1;\n                    countTaxonomicUnitMatches += 1;\n                  }\n                });\n              });\n            });\n          });\n\n          if (nodesMatchedCount === 0) {\n            // No nodes matched? Record this as an unmatched specifier.\n            if (!has(phyloref, 'hasUnmatchedSpecifiers')) phyloref.hasUnmatchedSpecifiers = [];\n            phyloref.hasUnmatchedSpecifiers.push(specifier);\n          }\n        });\n      });\n    }\n\n    // Finally, add the base URI as an ontology.\n    jsonld['@id'] = PhyxWrapper.BASE_URI;\n    jsonld['@type'] = [owlterms.PHYLOREFERENCE_TEST_CASE, 'owl:Ontology'];\n    jsonld['owl:imports'] = [\n      'http://raw.githubusercontent.com/phyloref/curation-workflow/develop/ontologies/phyloref_testcase.owl',\n      // - Will become 'http://vocab.phyloref.org/phyloref/testcase.owl'\n      'http://ontology.phyloref.org/2018-12-04/phyloref.owl',\n      // - The Phyloreferencing ontology.\n      'http://purl.obolibrary.org/obo/bco.owl',\n      // - Contains OWL definitions for Darwin Core terms\n    ];\n\n    // If the '@context' is missing, add it here.\n    if (!has(jsonld, '@context')) {\n      jsonld['@context'] = 'http://www.phyloref.org/phyx.js/v0.1.0/phyx.json';\n    }\n\n    return jsonld;\n  }\n}\n\nmodule.exports = {\n  PhyxWrapper,\n};\n",
    "static": true,
    "longname": "/home/vaidyagi/code/phyloref/phyx.js/src/wrappers/PhyxWrapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 134,
    "kind": "variable",
    "name": "extend",
    "memberof": "src/wrappers/PhyxWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhyxWrapper.js~extend",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhyxWrapper.js",
    "importStyle": null,
    "description": "Used to make deep copies of objects.",
    "lineNumber": 2,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 135,
    "kind": "variable",
    "name": "has",
    "memberof": "src/wrappers/PhyxWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhyxWrapper.js~has",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhyxWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 136,
    "kind": "variable",
    "name": "owlterms",
    "memberof": "src/wrappers/PhyxWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhyxWrapper.js~owlterms",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhyxWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 137,
    "kind": "variable",
    "name": "PhylorefWrapper",
    "memberof": "src/wrappers/PhyxWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhyxWrapper.js~PhylorefWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhyxWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 138,
    "kind": "variable",
    "name": "PhylogenyWrapper",
    "memberof": "src/wrappers/PhyxWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhyxWrapper.js~PhylogenyWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhyxWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 139,
    "kind": "variable",
    "name": "TaxonomicUnitMatcher",
    "memberof": "src/wrappers/PhyxWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhyxWrapper.js~TaxonomicUnitMatcher",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhyxWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 140,
    "kind": "class",
    "name": "PhyxWrapper",
    "memberof": "src/wrappers/PhyxWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhyxWrapper.js~PhyxWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhyxWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 141,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/wrappers/PhyxWrapper.js~PhyxWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhyxWrapper.js~PhyxWrapper#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true
  },
  {
    "__docId__": 142,
    "kind": "member",
    "name": "phyx",
    "memberof": "src/wrappers/PhyxWrapper.js~PhyxWrapper",
    "static": false,
    "longname": "src/wrappers/PhyxWrapper.js~PhyxWrapper#phyx",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 143,
    "kind": "member",
    "name": "newickParser",
    "memberof": "src/wrappers/PhyxWrapper.js~PhyxWrapper",
    "static": false,
    "longname": "src/wrappers/PhyxWrapper.js~PhyxWrapper#newickParser",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 144,
    "kind": "get",
    "name": "BASE_URI",
    "memberof": "src/wrappers/PhyxWrapper.js~PhyxWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/PhyxWrapper.js~PhyxWrapper.BASE_URI",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 145,
    "kind": "method",
    "name": "getBaseURIForPhyloref",
    "memberof": "src/wrappers/PhyxWrapper.js~PhyxWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/PhyxWrapper.js~PhyxWrapper.getBaseURIForPhyloref",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "params": [
      {
        "name": "phylorefCount",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 146,
    "kind": "method",
    "name": "getBaseURIForPhylogeny",
    "memberof": "src/wrappers/PhyxWrapper.js~PhyxWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/PhyxWrapper.js~PhyxWrapper.getBaseURIForPhylogeny",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "params": [
      {
        "name": "phylogenyCount",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 147,
    "kind": "method",
    "name": "getBaseURIForTUMatch",
    "memberof": "src/wrappers/PhyxWrapper.js~PhyxWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/PhyxWrapper.js~PhyxWrapper.getBaseURIForTUMatch",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "params": [
      {
        "name": "countTaxonomicUnitMatches",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 148,
    "kind": "method",
    "name": "asJSONLD",
    "memberof": "src/wrappers/PhyxWrapper.js~PhyxWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhyxWrapper.js~PhyxWrapper#asJSONLD",
    "access": "public",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 149,
    "kind": "file",
    "name": "src/wrappers/ScientificNameWrapper.js",
    "content": "const { has } = require('lodash');\nconst { PhyxCacheManager } = require('../utils/PhyxCacheManager');\n\n/* Scientific name processing */\n\nclass ScientificNameWrapper {\n  // Wraps a scientific name to provide access to components of\n  // the scientific name. For now, we ignore binomialName, genus and\n  // specificEpithet and rederive them from the scientific name.\n\n  constructor(scname) {\n    // Create a new scientific name wrapper around the JSON representation of\n    // a scientific name.\n    this.scname = scname;\n  }\n\n  static createFromVerbatimName(verbatimName) {\n    // Returns a scientific name object created from a particular verbatim name.\n    // Not that the returned object will NOT be wrapped -- so remember to wrap it\n    // if necessary!\n\n    // Start with the 'scientific name' as the verbatim name.\n    const scname = {\n      scientificName: verbatimName,\n    };\n\n    // Split the verbatim name into a genus and specific epithet, if possible.\n    // Splitting the verbatim name takes some time, so let's memoize this.\n    if (PhyxCacheManager.has('ScientificNameWrapper.scnameCache', verbatimName)) {\n      return PhyxCacheManager.get('ScientificNameWrapper.scnameCache', verbatimName);\n    }\n\n    const comps = verbatimName.split(/\\s+/);\n\n    // Did we find a binomial?\n    if (comps.length >= 2) {\n      [, scname.specificEpithet] = comps;\n    }\n\n    // Did we find a uninomial?\n    if (comps.length >= 1) {\n      [scname.genus] = comps;\n    }\n\n    // Store in the cache.\n    PhyxCacheManager.put('ScientificNameWrapper.scnameCache', verbatimName, scname);\n\n    return scname;\n  }\n\n  get scientificName() {\n    // Get the \"dwc:scientificName\" -- the complete scientific name.\n    return this.scname.scientificName;\n  }\n\n  get binomialName() {\n    // Get the binomial name. Constructed from the genus and specific epithet\n    // if available.\n    if (this.genus === undefined || this.specificEpithet === undefined) return undefined;\n    return `${this.genus} ${this.specificEpithet}`;\n  }\n\n  get genus() {\n    // Try to read the genus if available.\n    if (has(this.scname, 'genus')) return this.scname.genus;\n\n    // If there is no genus but there is a scientificName, try to extract a genus\n    // from it.\n    if (has(this.scname, 'scientificName')) {\n      const scname = ScientificNameWrapper.createFromVerbatimName(this.scname.scientificName);\n      if (has(scname, 'genus')) return scname.genus;\n    }\n    return undefined;\n  }\n\n  get specificEpithet() {\n    // Try to read the specific epithet if available.\n    if (has(this.scname, 'specificEpithet')) return this.scname.specificEpithet;\n\n    // If there is no specific epithet but there is a scientificName, try to\n    // extract a specific epithet from it.\n    if (has(this.scname, 'scientificName')) {\n      const scname = ScientificNameWrapper.createFromVerbatimName(this.scname.scientificName);\n      if (has(scname, 'specificEpithet')) return scname.specificEpithet;\n    }\n    return undefined;\n  }\n\n  get label() {\n    // Return a label corresponding to this scientific name -- we use the complete verbatim name.\n    return this.scientificName;\n  }\n}\n\nmodule.exports = {\n  ScientificNameWrapper,\n};\n",
    "static": true,
    "longname": "/home/vaidyagi/code/phyloref/phyx.js/src/wrappers/ScientificNameWrapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 150,
    "kind": "variable",
    "name": "has",
    "memberof": "src/wrappers/ScientificNameWrapper.js",
    "static": true,
    "longname": "src/wrappers/ScientificNameWrapper.js~has",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/ScientificNameWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 151,
    "kind": "variable",
    "name": "PhyxCacheManager",
    "memberof": "src/wrappers/ScientificNameWrapper.js",
    "static": true,
    "longname": "src/wrappers/ScientificNameWrapper.js~PhyxCacheManager",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/ScientificNameWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 152,
    "kind": "class",
    "name": "ScientificNameWrapper",
    "memberof": "src/wrappers/ScientificNameWrapper.js",
    "static": true,
    "longname": "src/wrappers/ScientificNameWrapper.js~ScientificNameWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/ScientificNameWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 153,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/wrappers/ScientificNameWrapper.js~ScientificNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/ScientificNameWrapper.js~ScientificNameWrapper#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true
  },
  {
    "__docId__": 154,
    "kind": "member",
    "name": "scname",
    "memberof": "src/wrappers/ScientificNameWrapper.js~ScientificNameWrapper",
    "static": false,
    "longname": "src/wrappers/ScientificNameWrapper.js~ScientificNameWrapper#scname",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 155,
    "kind": "method",
    "name": "createFromVerbatimName",
    "memberof": "src/wrappers/ScientificNameWrapper.js~ScientificNameWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/ScientificNameWrapper.js~ScientificNameWrapper.createFromVerbatimName",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "params": [
      {
        "name": "verbatimName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 156,
    "kind": "get",
    "name": "scientificName",
    "memberof": "src/wrappers/ScientificNameWrapper.js~ScientificNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/ScientificNameWrapper.js~ScientificNameWrapper#scientificName",
    "access": "public",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 157,
    "kind": "get",
    "name": "binomialName",
    "memberof": "src/wrappers/ScientificNameWrapper.js~ScientificNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/ScientificNameWrapper.js~ScientificNameWrapper#binomialName",
    "access": "public",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 158,
    "kind": "get",
    "name": "genus",
    "memberof": "src/wrappers/ScientificNameWrapper.js~ScientificNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/ScientificNameWrapper.js~ScientificNameWrapper#genus",
    "access": "public",
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 159,
    "kind": "get",
    "name": "specificEpithet",
    "memberof": "src/wrappers/ScientificNameWrapper.js~ScientificNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/ScientificNameWrapper.js~ScientificNameWrapper#specificEpithet",
    "access": "public",
    "description": null,
    "lineNumber": 76,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 160,
    "kind": "get",
    "name": "label",
    "memberof": "src/wrappers/ScientificNameWrapper.js~ScientificNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/ScientificNameWrapper.js~ScientificNameWrapper#label",
    "access": "public",
    "description": null,
    "lineNumber": 89,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 161,
    "kind": "file",
    "name": "src/wrappers/SpecimenWrapper.js",
    "content": "const { has } = require('lodash');\nconst { PhyxCacheManager } = require('../utils/PhyxCacheManager');\n\n/* Specimen wrapper */\n\nclass SpecimenWrapper {\n  // Wraps a specimen identifier.\n\n  constructor(specimen) {\n    // Constructs a wrapper around a specimen.\n    this.specimen = specimen;\n\n    if (!has(specimen, 'occurrenceID')) {\n      // There might be a catalogNumber, institutionCode or a collectionCode.\n      // In which case, let's construct an occurrenceID!\n      if (has(specimen, 'catalogNumber')) {\n        if (has(specimen, 'institutionCode')) {\n          if (has(specimen, 'collectionCode')) {\n            this.specimen.occurrenceID = `urn:catalog:${specimen.institutionCode}:${specimen.collectionCode}:${specimen.catalogNumber}`;\n          } else {\n            this.specimen.occurrenceID = `urn:catalog:${specimen.institutionCode}::${specimen.catalogNumber}`;\n          }\n        } else {\n          this.specimen.occurrenceID = `urn:catalog:::${specimen.catalogNumber}`;\n        }\n      } else {\n        this.specimen.occurrenceID = 'urn:catalog:::';\n      }\n    }\n  }\n\n  static createFromOccurrenceID(occurrenceID) {\n    // Create a specimen object from the occurrence ID.\n    // The two expected formats are:\n    //  - 'urn:catalog:[institutionCode]:[collectionCode]:[catalogNumber]'\n    //      (in which case, we ignore the first two \"components\" here)\n    //  - '[institutionCode]:[collectionCode]:[catalogNumber]'\n    // Note that the returned object is NOT wrapped -- so please wrap it if needed!\n\n    // Copy the occurrence ID so we can truncate it if necessary.\n    let occurID = occurrenceID;\n    if (occurID.startsWith('urn:catalog:')) occurID = occurID.substr(12);\n\n    // Prepare the specimen.\n    const specimen = {\n      occurrenceID: occurID,\n    };\n\n    // Look for certain prefixes that suggest that we've been passed a URN or\n    // URL instead. If so, don't do any further processing!\n    const URL_URN_PREFIXES = [\n      'http://',\n      'https://',\n      'ftp://',\n      'sftp://',\n      'file://',\n      'urn:',\n    ];\n    if (URL_URN_PREFIXES.filter(prefix => occurID.toLowerCase().startsWith(prefix)).length > 0) {\n      return specimen;\n    }\n\n    // Parsing an occurrence ID takes some time, so we should memoize it.\n    if (PhyxCacheManager.has('SpecimenWrapper.occurrenceIDCache', occurID)) {\n      return PhyxCacheManager.get('SpecimenWrapper.occurrenceIDCache', occurID);\n    }\n\n    // Split the occurrence ID into components, and store them in the appropriate fields.\n    const comps = occurID.split(/:/);\n    if (comps.length === 1) {\n      // specimen.institutionCode = undefined;\n      // specimen.collectionCode = undefined;\n      [specimen.catalogNumber] = comps;\n    } else if (comps.length === 2) {\n      [specimen.institutionCode, specimen.catalogNumber] = comps;\n    } else if (comps.length >= 3) {\n      let catalogNumValues = []; // Store all split catalog number values.\n      [specimen.institutionCode, specimen.collectionCode, ...catalogNumValues] = comps;\n      specimen.catalogNumber = catalogNumValues.join(':');\n    }\n\n    PhyxCacheManager.put('SpecimenWrapper.occurrenceIDCache', occurID, specimen);\n    return specimen;\n  }\n\n  get catalogNumber() {\n    // Get the catalog number from the specimen object if present.\n    if (has(this.specimen, 'catalogNumber')) return this.specimen.catalogNumber;\n\n    // Otherwise, try to parse the occurrenceID and see if we can extract a\n    // catalogNumber from there.\n    if (has(this.specimen, 'occurrenceID')) {\n      const specimen = SpecimenWrapper.createFromOccurrenceID(this.specimen.occurrenceID);\n      if (has(specimen, 'catalogNumber')) return specimen.catalogNumber;\n    }\n    return undefined;\n  }\n\n  get institutionCode() {\n    // Get the institution code from the specimen object if present.\n    if (has(this.specimen, 'institutionCode')) return this.specimen.institutionCode;\n\n    // Otherwise, try to parse the occurrenceID and see if we can extract an\n    // occurrenceID from there.\n    if (has(this.specimen, 'occurrenceID')) {\n      const specimen = SpecimenWrapper.createFromOccurrenceID(this.specimen.occurrenceID);\n      if (has(specimen, 'institutionCode')) return specimen.institutionCode;\n    }\n    return undefined;\n  }\n\n  get collectionCode() {\n    // Get the collection code from the specimen object if present.\n    if (has(this.specimen, 'collectionCode')) return this.specimen.collectionCode;\n\n    // Otherwise, try to parse the occurrenceID and see if we can extract an\n    // occurrenceID from there.\n    if (has(this.specimen, 'occurrenceID')) {\n      const specimen = SpecimenWrapper.createFromOccurrenceID(this.specimen.occurrenceID);\n      if (has(specimen, 'collectionCode')) return specimen.collectionCode;\n    }\n    return undefined;\n  }\n\n  get occurrenceID() {\n    // Does this specimen have an occurrenceID? If so, return it.\n    // If not, we attempt to construct one in the form:\n    //   \"urn:catalog:\" + institutionCode (if present) + ':' +\n    //      collectionCode (if present) + ':' + catalogNumber (if present)\n    // If all else fails, we return undefined.\n    //\n    // If this was a full wrapper, we might create a setter on the occurrenceID;\n    // however, the Vue model modifies the underlying specimen object, not the\n    // wrapper.\n\n    // Return the occurrenceID if it exists.\n    if (has(this.specimen, 'occurrenceID') && this.specimen.occurrenceID.trim() !== '') {\n      return this.specimen.occurrenceID.trim();\n    }\n\n    // Otherwise, we could try to construct the occurrenceID from its components.\n    if (has(this.specimen, 'catalogNumber')) {\n      if (has(this.specimen, 'institutionCode')) {\n        if (has(this.specimen, 'collectionCode')) {\n          return `urn:catalog:${this.specimen.institutionCode.trim()}:${this.specimen.collectionCode.trim()}:${this.specimen.catalogNumber.trim()}`;\n        }\n        return `urn:catalog:${this.specimen.institutionCode.trim()}::${this.specimen.catalogNumber.trim()}`;\n      }\n      if (has(this.specimen, 'collectionCode')) {\n        return `urn:catalog::${this.specimen.collectionCode.trim()}:${this.specimen.catalogNumber.trim()}`;\n      }\n      return `urn:catalog:::${this.specimen.catalogNumber.trim()}`;\n    }\n\n    // None of our specimen identifier schemes worked.\n    return undefined;\n  }\n\n  get label() {\n    // Return a label for this specimen\n    return `Specimen ${this.occurrenceID}`;\n  }\n}\n\nmodule.exports = {\n  SpecimenWrapper,\n};\n",
    "static": true,
    "longname": "/home/vaidyagi/code/phyloref/phyx.js/src/wrappers/SpecimenWrapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 162,
    "kind": "variable",
    "name": "has",
    "memberof": "src/wrappers/SpecimenWrapper.js",
    "static": true,
    "longname": "src/wrappers/SpecimenWrapper.js~has",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/SpecimenWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 163,
    "kind": "variable",
    "name": "PhyxCacheManager",
    "memberof": "src/wrappers/SpecimenWrapper.js",
    "static": true,
    "longname": "src/wrappers/SpecimenWrapper.js~PhyxCacheManager",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/SpecimenWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 164,
    "kind": "class",
    "name": "SpecimenWrapper",
    "memberof": "src/wrappers/SpecimenWrapper.js",
    "static": true,
    "longname": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/SpecimenWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 165,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true
  },
  {
    "__docId__": 166,
    "kind": "member",
    "name": "specimen",
    "memberof": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper",
    "static": false,
    "longname": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper#specimen",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 167,
    "kind": "method",
    "name": "createFromOccurrenceID",
    "memberof": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper.createFromOccurrenceID",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "params": [
      {
        "name": "occurrenceID",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 168,
    "kind": "get",
    "name": "catalogNumber",
    "memberof": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper#catalogNumber",
    "access": "public",
    "description": null,
    "lineNumber": 86,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 169,
    "kind": "get",
    "name": "institutionCode",
    "memberof": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper#institutionCode",
    "access": "public",
    "description": null,
    "lineNumber": 99,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 170,
    "kind": "get",
    "name": "collectionCode",
    "memberof": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper#collectionCode",
    "access": "public",
    "description": null,
    "lineNumber": 112,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 171,
    "kind": "get",
    "name": "occurrenceID",
    "memberof": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper#occurrenceID",
    "access": "public",
    "description": null,
    "lineNumber": 125,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 172,
    "kind": "get",
    "name": "label",
    "memberof": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper#label",
    "access": "public",
    "description": null,
    "lineNumber": 159,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 173,
    "kind": "file",
    "name": "src/wrappers/TaxonomicUnitWrapper.js",
    "content": "const { has } = require('lodash');\n\nconst { PhyxCacheManager } = require('../utils/PhyxCacheManager');\nconst { SpecimenWrapper } = require('./SpecimenWrapper');\nconst { ScientificNameWrapper } = require('./ScientificNameWrapper');\n\n/* Taxonomic unit wrapper */\n\nclass TaxonomicUnitWrapper {\n  // Wraps a taxonomic unit.\n  // Also provides static methods for obtaining lists of wrapped taxonomic units\n  // from node labels.\n\n  constructor(tunit) {\n    // Wrap a taxonomic unit.\n    this.tunit = tunit;\n  }\n\n  get label() {\n    // Try to determine the label of a taxonomic unit. This checks the\n    // 'label' and 'description' properties, and then tries to create a\n    // descriptive label by combining the scientific names, specimens\n    // and external references of the taxonomic unit.\n    const labels = [];\n\n    // A label or description for the TU?\n    if (has(this.tunit, 'label')) return this.tunit.label;\n    if (has(this.tunit, 'description')) return this.tunit.description;\n\n    // Any specimens?\n    if (has(this.tunit, 'includesSpecimens')) {\n      this.tunit.includesSpecimens.forEach((specimen) => {\n        labels.push(new SpecimenWrapper(specimen).label);\n      });\n    }\n\n    // Any external references?\n    if (has(this.tunit, 'externalReferences')) {\n      this.tunit.externalReferences.forEach(externalRef => labels.push(`<${externalRef}>`));\n    }\n\n    // Any scientific names?\n    if (has(this.tunit, 'scientificNames')) {\n      this.tunit.scientificNames.forEach((scname) => {\n        labels.push(new ScientificNameWrapper(scname).label);\n      });\n    }\n\n    // If we don't have any properties of a taxonomic unit, return undefined.\n    if (labels.length === 0) return undefined;\n\n    return labels.join(' or ');\n  }\n\n  // Access variables in the underlying wrapped taxonomic unit.\n  get scientificNames() {\n    return this.tunit.scientificNames;\n  }\n\n  get includeSpecimens() {\n    return this.tunit.includesSpecimens;\n  }\n\n  get externalReferences() {\n    return this.tunit.externalReferences;\n  }\n\n  static getTaxonomicUnitsFromNodeLabel(nodeLabel) {\n    // Given a node label, attempt to parse it as a scientific name.\n    // Returns a list of taxonomic units.\n    if (nodeLabel === undefined || nodeLabel === null) return [];\n\n    // This regular expression times a while to run, so let's memoize this.\n    if (PhyxCacheManager.has('TaxonomicUnitWrapper.taxonomicUnitsFromNodeLabelCache', nodeLabel)) {\n      return PhyxCacheManager.get('TaxonomicUnitWrapper.taxonomicUnitsFromNodeLabelCache', nodeLabel);\n    }\n\n    // Check if the label starts with a binomial name.\n    let tunits = [];\n    const results = /^([A-Z][a-z]+)[ _]([a-z-]+)(?:\\b|_)\\s*(.*)/.exec(nodeLabel);\n    if (results !== null) {\n      tunits = [{\n        scientificNames: [{\n          scientificName: `${results[1]} ${results[2]} ${results[3]}`.trim(),\n          binomialName: `${results[1]} ${results[2]}`,\n          genus: results[1],\n          specificEpithet: results[2],\n        }],\n      }];\n    } else {\n      // It may be a scientific name, but we don't know how to parse it as such.\n      tunits = [];\n    }\n\n    // Record in the cache\n    PhyxCacheManager.put('TaxonomicUnitWrapper.taxonomicUnitsFromNodeLabelCache', nodeLabel, tunits);\n\n    return tunits;\n  }\n}\n\nmodule.exports = {\n  TaxonomicUnitWrapper,\n};\n",
    "static": true,
    "longname": "/home/vaidyagi/code/phyloref/phyx.js/src/wrappers/TaxonomicUnitWrapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 174,
    "kind": "variable",
    "name": "has",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js",
    "static": true,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~has",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/TaxonomicUnitWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 175,
    "kind": "variable",
    "name": "PhyxCacheManager",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js",
    "static": true,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~PhyxCacheManager",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/TaxonomicUnitWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 176,
    "kind": "variable",
    "name": "SpecimenWrapper",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js",
    "static": true,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~SpecimenWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/TaxonomicUnitWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 177,
    "kind": "variable",
    "name": "ScientificNameWrapper",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js",
    "static": true,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~ScientificNameWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/TaxonomicUnitWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 178,
    "kind": "class",
    "name": "TaxonomicUnitWrapper",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js",
    "static": true,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/TaxonomicUnitWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 179,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true
  },
  {
    "__docId__": 180,
    "kind": "member",
    "name": "tunit",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper",
    "static": false,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper#tunit",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 181,
    "kind": "get",
    "name": "label",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper#label",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 182,
    "kind": "get",
    "name": "scientificNames",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper#scientificNames",
    "access": "public",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 183,
    "kind": "get",
    "name": "includeSpecimens",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper#includeSpecimens",
    "access": "public",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 184,
    "kind": "get",
    "name": "externalReferences",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper#externalReferences",
    "access": "public",
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 185,
    "kind": "method",
    "name": "getTaxonomicUnitsFromNodeLabel",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper.getTaxonomicUnitsFromNodeLabel",
    "access": "public",
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "params": [
      {
        "name": "nodeLabel",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "kind": "index",
    "content": "# phyx.js\n\nThe Phyloreference Exchange (PHYX) format is a JSON representation that can be\nused to store and transfer definitions of [phyloreferences]. This library provides\nclasses to help interpret some parts of these files, and for transforming an\nentire Phyx file into a [JSON-LD] representation that can be reasoned over with\nan [OWL 2 DL] reasoner. See the [Phyloreference Curation Tool] or the [Clade Ontology]\nfor examples of its usage.\n\n## Funding\nFunded by the US National Science Foundation through collaborative grants [DBI-1458484]\nand [DBI-1458604]. See [Funding] for details.\n\n  [phyloreferences]: http://phyloref.org\n  [JSON-LD]: https://en.wikipedia.org/wiki/JSON-LD\n  [OWL 2 DL]: https://www.w3.org/TR/owl2-overview/\n  [Phyloreference Curation Tool]: https://github.com/phyloref/curation-tool\n  [Clade Ontology]: https://github.com/phyloref/clade-ontology\n  [DBI-1458484]: http://www.nsf.gov/awardsearch/showAward?AWD_ID=1458484\n  [DBI-1458604]: http://www.nsf.gov/awardsearch/showAward?AWD_ID=1458604\n  [Funding]: http://www.phyloref.org/about/#funding\n",
    "longname": "/home/vaidyagi/code/phyloref/phyx.js/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"@phyloref/phyx\",\n  \"version\": \"0.2.0\",\n  \"description\": \"Phyloreference Exchange (PHYX) library in JavaScript\",\n  \"main\": \"src/index.js\",\n  \"scripts\": {\n    \"lint\": \"eslint src/index.js \\\"test/**\\\" --ext .js\",\n    \"pretest\": \"npm run lint; npm run docs\",\n    \"test\": \"mocha\",\n    \"docs\": \"esdoc\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/phyloref/phyx.js.git\"\n  },\n  \"keywords\": [\n    \"phylogenetics\",\n    \"phylogeny\",\n    \"phylogenetic definitions\",\n    \"clade definitions\"\n  ],\n  \"author\": \"Gaurav Vaidya <gaurav@ggvaidya.com>\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/phyloref/phyx.js/issues\"\n  },\n  \"homepage\": \"https://github.com/phyloref/phyx.js#readme\",\n  \"dependencies\": {\n    \"extend\": \"^3.0.2\",\n    \"lodash\": \"^4.17.11\",\n    \"moment\": \"^2.23.0\",\n    \"newick-js\": \"^1.1.0\"\n  },\n  \"devDependencies\": {\n    \"chai\": \"^4.2.0\",\n    \"esdoc\": \"^1.1.0\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"eslint\": \"^5.12.0\",\n    \"eslint-config-airbnb-base\": \"^13.1.0\",\n    \"eslint-plugin-import\": \"^2.14.0\",\n    \"eslint-plugin-mocha\": \"^5.2.1\",\n    \"mocha\": \"^5.2.0\"\n  },\n  \"esdoc\": {\n    \"source\": \"./src\",\n    \"destination\": \"./docs\",\n    \"plugins\": [\n      {\n        \"name\": \"esdoc-standard-plugin\"\n      }\n    ]\n  }\n}\n",
    "longname": "/home/vaidyagi/code/phyloref/phyx.js/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]