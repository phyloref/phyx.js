[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/index.js",
    "content": "/*\n * PHYX Library\n * Copyright (c) The Phyloreferencing Project, 2018-19\n *\n * PHYloreference eXchange (PHYX) files store phyloreferences along with\n * annotated phylogenies that allow their expected resolution to be curated\n * and tested. This library provides classes and methods that help read and\n * manipulate components of PHYX files.\n *\n * Note that our goal here isn't to provide a library for modeling an entire\n * PHYX file in Javascript. The Curation Tool can mostly access and edit\n * components of the PHYX file as text strings or JSON objects, and the terms\n * used in the PHYX file should be clearly defined on their own. This library\n * contains convenience classes and methods that make accessing those components\n * easier.\n *\n * Most of these classes are wrappers. Because the object they wrap may be\n * unexpectedly modified through the UI, wrapper constructors should be extremely\n * lightweight so that the wrapper can be created quickly. Individual methods\n * can be complex and slow if necessary.\n */\n\n// Used to parse Newick strings.\nconst { parse: parseNewick } = require('newick-js');\n\n// Used to parse timestamps for phyloref statuses.\nconst moment = require('moment');\n\n// Used to make deep copies of objects.\nconst extend = require('extend');\n\n// Some OWL constants to be used.\nconst CDAO_HAS_CHILD = 'obo:CDAO_0000149';\nconst CDAO_HAS_DESCENDANT = 'obo:CDAO_0000174';\nconst PHYLOREF_EXCLUDES_LINEAGE_TO = 'phyloref:excludes_lineage_to';\nconst PHYLOREFERENCE_TEST_CASE = 'testcase:PhyloreferenceTestCase';\nconst PHYLOREFERENCE_PHYLOGENY = 'testcase:PhyloreferenceTestPhylogeny';\nconst TESTCASE_SPECIFIER = 'testcase:Specifier';\n\n// Our global variables\n// eslint-disable-next-line no-var\nvar phyxCacheManager;\n\n/* Helper methods */\n\nfunction hasOwnProperty(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\n/* Cache manager */\n\nclass CacheManager {\n  // The Cache Manager helps manage the various caches we use in this library\n  // Ideally, caches should be created in the global phyxCacheManager object.\n  // A library can then call phyxCacheManager.clear() to empty the entire cache.\n\n  constructor() {\n    // Construct a new cache manager.\n    this.clear();\n  }\n\n  clear() {\n    // Clear all current caches\n    this.caches = {};\n  }\n\n  has(cacheName, cacheKey) {\n    // Return true if we have a value for this particular cache key.\n    return hasOwnProperty(this.caches, cacheName)\n      && hasOwnProperty(this.caches[cacheName], cacheKey);\n  }\n\n  get(cacheName, cacheKey) {\n    // Look up the value of a key in a particular cache key.\n    if (!hasOwnProperty(this.caches, cacheName)) this.caches[cacheName] = {};\n    if (!hasOwnProperty(this.caches[cacheName], cacheKey)) return undefined;\n    return this.caches[cacheName][cacheKey];\n  }\n\n  put(cacheName, cacheKey, value) {\n    // Set the value of a key in a particular cache key.\n    if (!hasOwnProperty(this.caches, cacheName)) this.caches[cacheName] = {};\n    if (!hasOwnProperty(this.caches[cacheName], cacheKey)) this.caches[cacheName][cacheKey] = {};\n    this.caches[cacheName][cacheKey] = value;\n  }\n}\nphyxCacheManager = new CacheManager();\n\n/* Scientific name processing */\n\nclass ScientificNameWrapper {\n  // Wraps a scientific name to provide access to components of\n  // the scientific name. For now, we ignore binomialName, genus and\n  // specificEpithet and rederive them from the scientific name.\n\n  constructor(scname) {\n    // Create a new scientific name wrapper around the JSON representation of\n    // a scientific name.\n    this.scname = scname;\n  }\n\n  static createFromVerbatimName(verbatimName) {\n    // Returns a scientific name object created from a particular verbatim name.\n    // Not that the returned object will NOT be wrapped -- so remember to wrap it\n    // if necessary!\n\n    // Start with the 'scientific name' as the verbatim name.\n    const scname = {\n      scientificName: verbatimName,\n    };\n\n    // Split the verbatim name into a genus and specific epithet, if possible.\n    // Splitting the verbatim name takes some time, so let's memoize this.\n    if (phyxCacheManager.has('ScientificNameWrapper.scnameCache', verbatimName)) {\n      return phyxCacheManager.get('ScientificNameWrapper.scnameCache', verbatimName);\n    }\n\n    const comps = verbatimName.split(/\\s+/);\n\n    // Did we find a binomial?\n    if (comps.length >= 2) {\n      [, scname.specificEpithet] = comps;\n    }\n\n    // Did we find a uninomial?\n    if (comps.length >= 1) {\n      [scname.genus] = comps;\n    }\n\n    // Store in the cache.\n    phyxCacheManager.put('ScientificNameWrapper.scnameCache', verbatimName, scname);\n\n    return scname;\n  }\n\n  get scientificName() {\n    // Get the \"dwc:scientificName\" -- the complete scientific name.\n    return this.scname.scientificName;\n  }\n\n  get binomialName() {\n    // Get the binomial name. Constructed from the genus and specific epithet\n    // if available.\n    if (this.genus === undefined || this.specificEpithet === undefined) return undefined;\n    return `${this.genus} ${this.specificEpithet}`;\n  }\n\n  get genus() {\n    // Try to read the genus if available.\n    if (hasOwnProperty(this.scname, 'genus')) return this.scname.genus;\n\n    // If there is no genus but there is a scientificName, try to extract a genus\n    // from it.\n    if (hasOwnProperty(this.scname, 'scientificName')) {\n      const scname = ScientificNameWrapper.createFromVerbatimName(this.scname.scientificName);\n      if (hasOwnProperty(scname, 'genus')) return scname.genus;\n    }\n    return undefined;\n  }\n\n  get specificEpithet() {\n    // Try to read the specific epithet if available.\n    if (hasOwnProperty(this.scname, 'specificEpithet')) return this.scname.specificEpithet;\n\n    // If there is no specific epithet but there is a scientificName, try to\n    // extract a specific epithet from it.\n    if (hasOwnProperty(this.scname, 'scientificName')) {\n      const scname = ScientificNameWrapper.createFromVerbatimName(this.scname.scientificName);\n      if (hasOwnProperty(scname, 'specificEpithet')) return scname.specificEpithet;\n    }\n    return undefined;\n  }\n\n  get label() {\n    // Return a label corresponding to this scientific name -- we use the complete verbatim name.\n    return this.scientificName;\n  }\n}\n\n/* Specimen wrapper */\n\nclass SpecimenWrapper {\n  // Wraps a specimen identifier.\n\n  constructor(specimen) {\n    // Constructs a wrapper around a specimen.\n    this.specimen = specimen;\n\n    if (!hasOwnProperty(specimen, 'occurrenceID')) {\n      // There might be a catalogNumber, institutionCode or a collectionCode.\n      // In which case, let's construct an occurrenceID!\n      if (hasOwnProperty(specimen, 'catalogNumber')) {\n        if (hasOwnProperty(specimen, 'institutionCode')) {\n          if (hasOwnProperty(specimen, 'collectionCode')) {\n            this.specimen.occurrenceID = `urn:catalog:${specimen.institutionCode}:${specimen.collectionCode}:${specimen.catalogNumber}`;\n          } else {\n            this.specimen.occurrenceID = `urn:catalog:${specimen.institutionCode}::${specimen.catalogNumber}`;\n          }\n        } else {\n          this.specimen.occurrenceID = `urn:catalog:::${specimen.catalogNumber}`;\n        }\n      } else {\n        this.specimen.occurrenceID = 'urn:catalog:::';\n      }\n    }\n  }\n\n  static createFromOccurrenceID(occurrenceID) {\n    // Create a specimen object from the occurrence ID.\n    // The two expected formats are:\n    //  - 'urn:catalog:[institutionCode]:[collectionCode]:[catalogNumber]'\n    //      (in which case, we ignore the first two \"components\" here)\n    //  - '[institutionCode]:[collectionCode]:[catalogNumber]'\n    // Note that the returned object is NOT wrapped -- so please wrap it if needed!\n\n    // Copy the occurrence ID so we can truncate it if necessary.\n    let occurID = occurrenceID;\n    if (occurID.startsWith('urn:catalog:')) occurID = occurID.substr(12);\n\n    // Prepare the specimen.\n    const specimen = {\n      occurrenceID: occurID,\n    };\n\n    // Look for certain prefixes that suggest that we've been passed a URN or\n    // URL instead. If so, don't do any further processing!\n    const URL_URN_PREFIXES = [\n      'http://',\n      'https://',\n      'ftp://',\n      'sftp://',\n      'file://',\n      'urn:',\n    ];\n    if (URL_URN_PREFIXES.filter(prefix => occurID.toLowerCase().startsWith(prefix)).length > 0) {\n      return specimen;\n    }\n\n    // Parsing an occurrence ID takes some time, so we should memoize it.\n    if (phyxCacheManager.has('SpecimenWrapper.occurrenceIDCache', occurID)) {\n      return phyxCacheManager.get('SpecimenWrapper.occurrenceIDCache', occurID);\n    }\n\n    // Split the occurrence ID into components, and store them in the appropriate fields.\n    const comps = occurID.split(/:/);\n    if (comps.length === 1) {\n      // specimen.institutionCode = undefined;\n      // specimen.collectionCode = undefined;\n      [specimen.catalogNumber] = comps;\n    } else if (comps.length === 2) {\n      [specimen.institutionCode, specimen.catalogNumber] = comps;\n    } else if (comps.length >= 3) {\n      let catalogNumValues = []; // Store all split catalog number values.\n      [specimen.institutionCode, specimen.collectionCode, ...catalogNumValues] = comps;\n      specimen.catalogNumber = catalogNumValues.join(':');\n    }\n\n    phyxCacheManager.put('SpecimenWrapper.occurrenceIDCache', occurID, specimen);\n    return specimen;\n  }\n\n  get catalogNumber() {\n    // Get the catalog number from the specimen object if present.\n    if (hasOwnProperty(this.specimen, 'catalogNumber')) return this.specimen.catalogNumber;\n\n    // Otherwise, try to parse the occurrenceID and see if we can extract a\n    // catalogNumber from there.\n    if (hasOwnProperty(this.specimen, 'occurrenceID')) {\n      const specimen = SpecimenWrapper.createFromOccurrenceID(this.specimen.occurrenceID);\n      if (hasOwnProperty(specimen, 'catalogNumber')) return specimen.catalogNumber;\n    }\n    return undefined;\n  }\n\n  get institutionCode() {\n    // Get the institution code from the specimen object if present.\n    if (hasOwnProperty(this.specimen, 'institutionCode')) return this.specimen.institutionCode;\n\n    // Otherwise, try to parse the occurrenceID and see if we can extract an\n    // occurrenceID from there.\n    if (hasOwnProperty(this.specimen, 'occurrenceID')) {\n      const specimen = SpecimenWrapper.createFromOccurrenceID(this.specimen.occurrenceID);\n      if (hasOwnProperty(specimen, 'institutionCode')) return specimen.institutionCode;\n    }\n    return undefined;\n  }\n\n  get collectionCode() {\n    // Get the collection code from the specimen object if present.\n    if (hasOwnProperty(this.specimen, 'collectionCode')) return this.specimen.collectionCode;\n\n    // Otherwise, try to parse the occurrenceID and see if we can extract an\n    // occurrenceID from there.\n    if (hasOwnProperty(this.specimen, 'occurrenceID')) {\n      const specimen = SpecimenWrapper.createFromOccurrenceID(this.specimen.occurrenceID);\n      if (hasOwnProperty(specimen, 'collectionCode')) return specimen.collectionCode;\n    }\n    return undefined;\n  }\n\n  get occurrenceID() {\n    // Does this specimen have an occurrenceID? If so, return it.\n    // If not, we attempt to construct one in the form:\n    //   \"urn:catalog:\" + institutionCode (if present) + ':' +\n    //      collectionCode (if present) + ':' + catalogNumber (if present)\n    // If all else fails, we return undefined.\n    //\n    // If this was a full wrapper, we might create a setter on the occurrenceID;\n    // however, the Vue model modifies the underlying specimen object, not the\n    // wrapper.\n\n    // Return the occurrenceID if it exists.\n    if (hasOwnProperty(this.specimen, 'occurrenceID') && this.specimen.occurrenceID.trim() !== '') {\n      return this.specimen.occurrenceID.trim();\n    }\n\n    // Otherwise, we could try to construct the occurrenceID from its components.\n    if (hasOwnProperty(this.specimen, 'catalogNumber')) {\n      if (hasOwnProperty(this.specimen, 'institutionCode')) {\n        if (hasOwnProperty(this.specimen, 'collectionCode')) {\n          return `urn:catalog:${this.specimen.institutionCode.trim()}:${this.specimen.collectionCode.trim()}:${this.specimen.catalogNumber.trim()}`;\n        }\n        return `urn:catalog:${this.specimen.institutionCode.trim()}::${this.specimen.catalogNumber.trim()}`;\n      }\n      if (hasOwnProperty(this.specimen, 'collectionCode')) {\n        return `urn:catalog::${this.specimen.collectionCode.trim()}:${this.specimen.catalogNumber.trim()}`;\n      }\n      return `urn:catalog:::${this.specimen.catalogNumber.trim()}`;\n    }\n\n    // None of our specimen identifier schemes worked.\n    return undefined;\n  }\n\n  get label() {\n    // Return a label for this specimen\n    return `Specimen ${this.occurrenceID}`;\n  }\n}\n\n/* Taxonomic unit wrapper */\n\nclass TaxonomicUnitWrapper {\n  // Wraps a taxonomic unit.\n  // Also provides static methods for obtaining lists of wrapped taxonomic units\n  // from node labels.\n\n  constructor(tunit) {\n    // Wrap a taxonomic unit.\n    this.tunit = tunit;\n  }\n\n  get label() {\n    // Try to determine the label of a taxonomic unit. This checks the\n    // 'label' and 'description' properties, and then tries to create a\n    // descriptive label by combining the scientific names, specimens\n    // and external references of the taxonomic unit.\n    const labels = [];\n\n    // A label or description for the TU?\n    if (hasOwnProperty(this.tunit, 'label')) return this.tunit.label;\n    if (hasOwnProperty(this.tunit, 'description')) return this.tunit.description;\n\n    // Any specimens?\n    if (hasOwnProperty(this.tunit, 'includesSpecimens')) {\n      this.tunit.includesSpecimens.forEach((specimen) => {\n        labels.push(new SpecimenWrapper(specimen).label);\n      });\n    }\n\n    // Any external references?\n    if (hasOwnProperty(this.tunit, 'externalReferences')) {\n      this.tunit.externalReferences.forEach(externalRef => labels.push(`<${externalRef}>`));\n    }\n\n    // Any scientific names?\n    if (hasOwnProperty(this.tunit, 'scientificNames')) {\n      this.tunit.scientificNames.forEach((scname) => {\n        labels.push(new ScientificNameWrapper(scname).label);\n      });\n    }\n\n    // If we don't have any properties of a taxonomic unit, return undefined.\n    if (labels.length === 0) return undefined;\n\n    return labels.join(' or ');\n  }\n\n  // Access variables in the underlying wrapped taxonomic unit.\n  get scientificNames() {\n    return this.tunit.scientificNames;\n  }\n\n  get includeSpecimens() {\n    return this.tunit.includesSpecimens;\n  }\n\n  get externalReferences() {\n    return this.tunit.externalReferences;\n  }\n\n  static getTaxonomicUnitsFromNodeLabel(nodeLabel) {\n    // Given a node label, attempt to parse it as a scientific name.\n    // Returns a list of taxonomic units.\n    if (nodeLabel === undefined || nodeLabel === null) return [];\n\n    // This regular expression times a while to run, so let's memoize this.\n    if (phyxCacheManager.has('TaxonomicUnitWrapper.taxonomicUnitsFromNodeLabelCache', nodeLabel)) {\n      return phyxCacheManager.get('TaxonomicUnitWrapper.taxonomicUnitsFromNodeLabelCache', nodeLabel);\n    }\n\n    // Check if the label starts with a binomial name.\n    let tunits = [];\n    const results = /^([A-Z][a-z]+)[ _]([a-z-]+)(?:\\b|_)\\s*(.*)/.exec(nodeLabel);\n    if (results !== null) {\n      tunits = [{\n        scientificNames: [{\n          scientificName: `${results[1]} ${results[2]} ${results[3]}`.trim(),\n          binomialName: `${results[1]} ${results[2]}`,\n          genus: results[1],\n          specificEpithet: results[2],\n        }],\n      }];\n    } else {\n      // It may be a scientific name, but we don't know how to parse it as such.\n      tunits = [];\n    }\n\n    // Record in the cache\n    phyxCacheManager.put('TaxonomicUnitWrapper.taxonomicUnitsFromNodeLabelCache', nodeLabel, tunits);\n\n    return tunits;\n  }\n}\n\n/* Taxonomic unit matching */\n\nclass TaxonomicUnitMatcher {\n  // A taxonomic unit matcher tests for taxonomic matches between pairs of\n  // taxonomic units.\n\n  constructor(tunit1, tunit2) {\n    // Construct a Taxonomic Unit Matcher to compare the two provided\n    // taxonomic units.\n    this.tunit1 = tunit1;\n    this.tunit2 = tunit2;\n\n    // Set up places to store the match results.\n    this.matched = undefined; // Boolean variable for storing whether these TUnits matched.\n    this.matchReason = undefined; // The reason provided for this match.\n\n    // Execute the match.\n    this.match();\n  }\n\n  asJSONLD(idURI) {\n    // Return this TUMatch as a JSON object for insertion into the PHYX file.\n    if (!this.matched) return undefined;\n\n    return {\n      '@id': idURI,\n      '@type': 'testcase:TUMatch',\n      reason: this.matchReason,\n      matchesTaxonomicUnits: [\n        { '@id': this.tunit1['@id'] },\n        { '@id': this.tunit2['@id'] },\n      ],\n    };\n  }\n\n  match() {\n    // Try to match the two taxonomic units using a number of matching methods.\n    if (\n      this.matchByBinomialName()\n      || this.matchByExternalReferences()\n      || this.matchBySpecimenIdentifier()\n    ) {\n      this.matched = true;\n    } else {\n      this.matched = false;\n      this.matchReason = undefined;\n    }\n  }\n\n  matchByBinomialName() {\n    // Try to match by binomial name, and return true if it could be matched.\n\n    // Do both TUnits have scientificNames?\n    if (!hasOwnProperty(this.tunit1, 'scientificNames') || !hasOwnProperty(this.tunit2, 'scientificNames')) return false;\n\n    return this.tunit1.scientificNames.some((scname1) => {\n      const scname1wrapped = new ScientificNameWrapper(scname1);\n      return this.tunit2.scientificNames.some((scname2) => {\n        const scname2wrapped = new ScientificNameWrapper(scname2);\n\n        const result = scname1wrapped.binomialName !== undefined\n          && scname2wrapped.binomialName !== undefined\n          && scname1wrapped.binomialName.trim().length > 0\n          && scname1wrapped.binomialName.trim() === scname2wrapped.binomialName.trim();\n\n        if (result) {\n          this.matchReason = `Scientific name '${scname1wrapped.scientificName}' and scientific name '${scname2wrapped.scientificName}' share the same binomial name`;\n        }\n\n        return result;\n      });\n    });\n  }\n\n  matchByExternalReferences() {\n    // Try to match by external references.\n\n    if (hasOwnProperty(this.tunit1, 'externalReferences') && hasOwnProperty(this.tunit2, 'externalReferences')) {\n      // Each external reference is a URL as a string. We will lowercase it,\n      // but do no other transformation.\n      return this.tunit1.externalReferences.some(\n        extref1 => this.tunit2.externalReferences.some((extref2) => {\n          const result = (\n            // Make sure that the external reference isn't blank\n            extref1.trim() !== ''\n\n              // And that it is identical after trimming\n              && extref1.toLowerCase().trim() === extref2.toLowerCase().trim()\n          );\n\n          if (result) {\n            this.matchReason = `External reference '${extref1}' is shared by taxonomic unit ${this.tunit1} and ${this.tunit2}`;\n          }\n\n          return result;\n        })\n      );\n    }\n\n    return false;\n  }\n\n  matchBySpecimenIdentifier() {\n    // Try to match by specimen identifier (i.e. occurrence ID).\n\n    if (hasOwnProperty(this.tunit1, 'includesSpecimens') && hasOwnProperty(this.tunit2, 'includesSpecimens')) {\n      // Convert specimen identifiers (if present) into a standard format and compare those.\n      return this.tunit1.includesSpecimens.some((specimen1) => {\n        const specimenURN1 = new SpecimenWrapper(specimen1).occurrenceID;\n        return this.tunit2.includesSpecimens.some((specimen2) => {\n          const specimenURN2 = new SpecimenWrapper(specimen2).occurrenceID;\n\n          const result = (specimenURN1 === specimenURN2);\n\n          if (result) {\n            this.matchReason = `Specimen identifier '${specimenURN1}' is shared by taxonomic units`;\n          }\n\n          return result;\n        });\n      });\n    }\n\n    return false;\n  }\n}\n\n/* Phylogeny wrapper */\n\nclass PhylogenyWrapper {\n  // Wraps a Phylogeny in a PHYX file and provides access to node, node labels\n  // and other information. Remember that a Phylogeny also has the\n  // additionalNodeProperties object which provides additional properties for\n  // nodes.\n\n  constructor(phylogeny) {\n    // Construct a phylogeny based on a Phylogeny object in a PHYX phylogeny.\n    // Note that this version ONLY uses the `newick` property to determine the\n    // phylogeny: if other representations are included (such as a node-based\n    // format, as used in JSON-LD), they will be ignored and possibly overwritten\n    // during export. So, to update the phylogeny, please only update the newick\n    // string!\n    //\n    // This ensures that we don't need to reconcile between different\n    // possible representations of a phylogeny.\n    this.phylogeny = phylogeny;\n  }\n\n  static getErrorsInNewickString(newick) {\n    // Given a Newick string, return a list of errors found in parsing this\n    // string. The errors are returned as a list of objects, each of which\n    // has two properties:\n    //  - title: A short title of the error, distinct for each type of error.\n    //  - message: A longer description of the error, which might include\n    //    information specific to a particular error.\n    //\n    // We try to order errors from most helpful ('Unbalanced parentheses in\n    // Newick string') to least helpful ('Error parsing phylogeny').\n    const newickTrimmed = newick.trim();\n    const errors = [];\n\n    // Look for an empty Newick string.\n    if (newickTrimmed === '' || newickTrimmed === '()' || newickTrimmed === '();') {\n      // None of the later errors are relevant here, so bail out now.\n      return [{\n        title: 'No phylogeny entered',\n        message: 'Click on \"Edit as Newick\" to enter a phylogeny below.',\n      }];\n    }\n\n    // Look for an unbalanced Newick string.\n    let parenLevels = 0;\n    for (let x = 0; x < newickTrimmed.length; x += 1) {\n      if (newickTrimmed[x] === '(') parenLevels += 1;\n      if (newickTrimmed[x] === ')') parenLevels -= 1;\n    }\n\n    if (parenLevels !== 0) {\n      errors.push({\n        title: 'Unbalanced parentheses in Newick string',\n        message: (parenLevels > 0\n          ? `You have ${parenLevels} too many open parentheses`\n          : `You have ${-parenLevels} too few open parentheses`\n        ),\n      });\n    }\n\n    // Finally, try parsing it with parseNewick and see if we get an error.\n    try {\n      parseNewick(newickTrimmed);\n    } catch (ex) {\n      errors.push({\n        title: 'Error parsing phylogeny',\n        message: `An error occured while parsing this phylogeny: ${ex.message}`,\n      });\n    }\n\n    return errors;\n  }\n\n  static recurseNodes(node, func, nodeCount = 0, parentCount = undefined) {\n    // Recurse through PhyloTree nodes, executing function on each node.\n    //  - node: The node to recurse from. The function will be called on node\n    //          *before* being called on its children.\n    //  - func: The function to call on `node` and all of its children.\n    //  - nodeCount: `node` will be called with this nodeCount. All of its\n    //          children will be called with consecutively increasing nodeCounts.\n    //  - parentCount: The nodeCount associated with the parent of this node\n    //          within this run of recurseNodes. For instance, immediate children\n    //          of `node` will have a parentCount of 0. By default, `node` itself\n    //          will have a parentCount of `undefined`.\n    // When the function `func` is called, it is given three arguments:\n    //  - The current node object (initially: `node`)\n    //  - The count of the current node object (initially: `nodeCount`)\n    //  - The parent count of the current node object (initially: `parentCount`)\n    func(node, nodeCount, parentCount);\n\n    let nextID = nodeCount + 1;\n\n    // Recurse through all children of this node.\n    if (hasOwnProperty(node, 'children')) {\n      node.children.forEach((child) => {\n        nextID = PhylogenyWrapper.recurseNodes(\n          child,\n          func,\n          nextID,\n          nodeCount\n        );\n      });\n    }\n\n    return nextID;\n  }\n\n  getTaxonomicUnits(nodeType = 'both') {\n    // Return a list of all taxonomic units in this phylogeny.\n    // Node labels will be extracted from:\n    //  - internal nodes only (if nodeType == 'internal')\n    //  - terminal nodes only (if nodeType == 'terminal')\n    //  - both internal and terminal nodes (if nodeType == 'both')\n    //\n    // See `getTaxonomicUnitsForNodeLabel` to see how node labels are converted\n    // into node labels, but in brief:\n    //  1. We look for taxonomic units in the additionalNodeProperties.\n    //  2. If none are found, we attempt to parse the node label as a scientific name.\n    //\n    const nodeLabels = this.getNodeLabels(nodeType);\n    const tunits = new Set();\n\n    nodeLabels.forEach(\n      nodeLabel => this.getTaxonomicUnitsForNodeLabel(nodeLabel)\n        .forEach(tunit => tunits.add(tunit))\n    );\n\n    return tunits;\n  }\n\n  getNodeLabels(nodeType = 'both') {\n    // Return a list of all the node labels in this phylogeny.\n    //\n    // nodeType can be one of:\n    // - 'internal': Return node labels on internal nodes.\n    // - 'terminal': Return node labels on terminal nodes.\n    // - 'both': Return node labels on both internal and terminal nodes.\n\n    // Parse the phylogeny (will throw an exception if parsing failed).\n    const { graph } = parseNewick(this.phylogeny.newick || '()');\n    const [vertices, arcs] = graph;\n\n    if (nodeType === 'both') {\n      // Return all node labels.\n      return Array.from(\n        new Set(\n          Array.from(vertices)\n            .map(vertex => vertex.label)\n            .filter(label => label !== undefined)\n        )\n      );\n    }\n\n    if (nodeType === 'internal') {\n      // Return the internal nodes (those with atleast one child).\n      return Array.from(new Set(\n        Array.from(arcs)\n          .map(arc => arc[0].label) // Retrieve the label of the parent vertex in this arc.\n          .filter(label => label !== undefined)\n      ));\n    }\n\n    if (nodeType === 'terminal') {\n      // Return the terminal nodes. This would require calculating the children\n      // of every vertex in the graph and then identifying vertices without any\n      // children.\n      //\n      // A quicker and dirtier way to do this is by removing internal labels\n      // from the list of all node labels. This will report an incorrect result\n      // if an internal node has the same label as a terminal node, but at that\n      // point a lot of other assumptions are going to fail, too, so this is\n      // probably good enough for now.\n      const allLabels = this.getNodeLabels('both');\n      const internalLabels = new Set(this.getNodeLabels('internal'));\n\n      return allLabels.filter(label => !internalLabels.has(label));\n    }\n\n    throw new Error(`Unknown nodeType: '${nodeType}'`);\n  }\n\n  getTaxonomicUnitsForNodeLabel(nodeLabel) {\n    // Return a list of taxonomic units for a node label.\n\n    // Look up additional node properties.\n    let additionalNodeProperties = {};\n    if (\n      hasOwnProperty(this.phylogeny, 'additionalNodeProperties')\n      && hasOwnProperty(this.phylogeny.additionalNodeProperties, nodeLabel)\n    ) {\n      additionalNodeProperties = this.phylogeny.additionalNodeProperties[nodeLabel];\n    }\n\n    // If there are explicit taxonomic units in the\n    // representsTaxonomicUnits property, we need to use those.\n    if (hasOwnProperty(additionalNodeProperties, 'representsTaxonomicUnits')) {\n      return additionalNodeProperties.representsTaxonomicUnits;\n    }\n\n    // If that doesn't work, we can try to extract scientific names from\n    // the node label. Note that taxonomic units will NOT be extracted from\n    // the label if there is a taxonomic unit present!\n    return TaxonomicUnitWrapper.getTaxonomicUnitsFromNodeLabel(nodeLabel.trim());\n  }\n\n  getNodeLabelsMatchedBySpecifier(specifier) {\n    // Return a list of node labels matched by a given specifier on\n    // a given phylogeny.\n\n    // Does the specifier have any taxonomic units? If not, we can't\n    // match anything!\n    if (!hasOwnProperty(specifier, 'referencesTaxonomicUnits')) { return []; }\n    const specifierTUnits = specifier.referencesTaxonomicUnits;\n\n    return this.getNodeLabels().filter((nodeLabel) => {\n      // Find all the taxonomic units associated with the specifier and\n      // with the node.\n      const nodeTUnits = this.getTaxonomicUnitsForNodeLabel(nodeLabel);\n\n      // Attempt pairwise matches between taxonomic units in the specifier\n      // and associated with the node.\n      return specifierTUnits.some(\n        tunit1 => nodeTUnits.some(\n          tunit2 => new TaxonomicUnitMatcher(tunit1, tunit2).matched\n        )\n      );\n    });\n  }\n\n  static getParsedNewick(newick) {\n    // We previously used phylotree.js's Newick parser to parse Newick into a\n    // tree-like structure. However, this is difficult to integrate using NPM.\n    // This method provides a similar facility using the newick-js library.\n    //\n    // Throws an exception if the Newick could not be parsed.\n    const { graph, root, rootWeight } = parseNewick(newick);\n    const [, arcs] = graph;\n\n    // Go through the arcs, assigning 'children' to the appropriate parent node.\n    arcs.forEach((arc) => {\n      const [parent, child, weight] = arc;\n\n      // Add child to parent.children.\n      if (!hasOwnProperty(parent, 'children')) parent.children = [];\n      parent.children.push(child);\n\n      // Phylotree.js uses 'name' instead of 'label'.\n      if (hasOwnProperty(parent, 'label')) { parent.name = parent.label; }\n      if (hasOwnProperty(child, 'label')) { child.name = child.label; }\n\n      // Phylotree.js uses 'attribute' to store weights, so we'll store it there as well.\n      if (!hasOwnProperty(child, 'attribute') && !Number.isNaN(weight)) child.attribute = weight;\n    });\n\n    // Set root 'attribute' to root weight.\n    if (!hasOwnProperty(root, 'attribute') && !Number.isNaN(rootWeight)) root.attribute = rootWeight;\n\n    return { json: root };\n  }\n\n  getParsedNewickWithIRIs(baseURI, newickParser = PhylogenyWrapper.getParsedNewick) {\n    // Return the parsed Newick string, but with EVERY node given an IRI.\n    // parsedNewick: A Newick tree represented as a tree produced by Phylotree.\n    // baseURI: The base URI to use for node elements (e.g. ':phylogeny1').\n\n    const parsed = newickParser(this.phylogeny.newick || '()');\n    if (hasOwnProperty(parsed, 'json')) {\n      PhylogenyWrapper.recurseNodes(parsed.json, (node, nodeCount) => {\n        // Start with the additional node properties.\n        const nodeAsJSONLD = node;\n\n        // Set @id and @type.\n        const nodeURI = `${baseURI}_node${nodeCount}`;\n        nodeAsJSONLD['@id'] = nodeURI;\n      });\n    }\n\n    return parsed;\n  }\n\n  getNodesAsJSONLD(baseURI, newickParser) {\n    // Returns a list of all nodes in this phylogeny as a series of nodes.\n    // - parsedNewick: A Newick tree parsed into a tree structure by Phylotree.\n    // - baseURI: The base URI to use for node elements (e.g. ':phylogeny1').\n\n    // List of nodes we have identified.\n    const nodes = [];\n\n    // We need to track the identifiers we give each node as we go.\n    const nodesById = {};\n    const nodeIdsByParentId = {};\n\n    // Extract the newick string.\n    const { additionalNodeProperties } = this.phylogeny;\n\n    // Parse the Newick string; if parseable, recurse through the nodes,\n    // added them to the list of JSON-LD nodes as we go.\n\n    const parsed = this.getParsedNewickWithIRIs(baseURI, newickParser);\n    if (hasOwnProperty(parsed, 'json')) {\n      PhylogenyWrapper.recurseNodes(parsed.json, (node, nodeCount, parentCount) => {\n        // Start with the additional node properties.\n        const nodeAsJSONLD = {};\n\n        // Set @id and @type. '@id' should already be set by getParsedNewickWithIRIs()!\n        const nodeURI = node['@id'];\n        nodeAsJSONLD['@id'] = nodeURI;\n        nodeAsJSONLD['@type'] = 'http://purl.obolibrary.org/obo/CDAO_0000140';\n\n        // Add labels, additional node properties and taxonomic units.\n        if (hasOwnProperty(node, 'name') && node.name !== '') {\n          // Add node label.\n          nodeAsJSONLD.labels = [node.name];\n\n          // Add additional node properties, if any.\n          if (additionalNodeProperties && hasOwnProperty(additionalNodeProperties, node.name)) {\n            Object.keys(additionalNodeProperties[node.name]).forEach((key) => {\n              nodeAsJSONLD[key] = additionalNodeProperties[node.name][key];\n            });\n          }\n\n          // Add taxonomic units.\n          nodeAsJSONLD.representsTaxonomicUnits = this.getTaxonomicUnitsForNodeLabel(node.name);\n\n          // Apply @id and @type to each taxonomic unit.\n          let countTaxonomicUnits = 0;\n          nodeAsJSONLD.representsTaxonomicUnits.forEach((tunitToChange) => {\n            const tunit = tunitToChange;\n\n            tunit['@id'] = `${nodeURI}_taxonomicunit${countTaxonomicUnits}`;\n            tunit['@type'] = 'http://purl.obolibrary.org/obo/CDAO_0000138';\n            countTaxonomicUnits += 1;\n          });\n        }\n\n        // Add references to parents and siblings.\n        if (parentCount !== undefined) {\n          const parentURI = `${baseURI}_node${parentCount}`;\n          nodeAsJSONLD.parent = parentURI;\n\n          // Update list of nodes by parent IDs.\n          if (!hasOwnProperty(nodeIdsByParentId, parentURI)) {\n            nodeIdsByParentId[parentURI] = new Set();\n          }\n          nodeIdsByParentId[parentURI].add(nodeURI);\n        }\n\n        // Add nodeAsJSONLD to list\n        if (hasOwnProperty(nodesById, nodeURI)) {\n          throw new Error('Error in programming: duplicate node URI generated');\n        }\n        nodesById[nodeURI] = nodeAsJSONLD;\n        nodes.push(nodeAsJSONLD);\n      });\n    }\n\n    // Go through nodes again and set children and sibling relationships.\n    Object.keys(nodeIdsByParentId).forEach((parentId) => {\n      // What are the children of this parentId?\n      const childrenIDs = Array.from(nodeIdsByParentId[parentId]);\n      const children = childrenIDs.map(childId => nodesById[childId]);\n\n      // Is this the root node?\n      if (hasOwnProperty(nodesById, parentId)) {\n        const parent = nodesById[parentId];\n        parent.children = childrenIDs;\n      }\n\n      children.forEach((child) => {\n        const childToModify = child;\n        // Add all other sibling to node.siblings, but don't add this node itself!\n        childToModify.siblings = childrenIDs.filter(childId => childId !== child['@id']);\n      });\n    });\n\n    return nodes;\n  }\n\n  asJSONLD(baseURI, newickParser) {\n    // Export this phylogeny as JSON-LD.\n\n    // Create a copy to export.\n    const phylogenyAsJSONLD = JSON.parse(JSON.stringify(this.phylogeny));\n\n    // Set name and class for phylogeny.\n    phylogenyAsJSONLD['@id'] = baseURI;\n    phylogenyAsJSONLD['@type'] = PHYLOREFERENCE_PHYLOGENY;\n\n    // Translate nodes into JSON-LD objects.\n    phylogenyAsJSONLD.nodes = this.getNodesAsJSONLD(baseURI, newickParser);\n    if (phylogenyAsJSONLD.nodes.length > 0) {\n      // We don't have a better way to identify the root node, so we just\n      // default to the first one.\n      phylogenyAsJSONLD.hasRootNode = {\n        '@id': phylogenyAsJSONLD.nodes[0]['@id'],\n      };\n    }\n\n    return phylogenyAsJSONLD;\n  }\n}\n\n/* Phyloreference wrapper */\n\nclass PhylorefWrapper {\n  // Wraps a phyloreference in a PHYX model.\n\n  constructor(phyloref) {\n    // Wraps the provided phyloreference\n    this.phyloref = phyloref;\n\n    // Reset internal and external specifiers if needed.\n    // if (!hasOwnProperty(this.phyloref, 'internalSpecifiers'))\n    //  Vue.set(this.phyloref, 'internalSpecifiers', []);\n    if (!hasOwnProperty(this.phyloref, 'internalSpecifiers')) {\n      this.phyloref.internalSpecifiers = [];\n    }\n    // if (!hasOwnProperty(this.phyloref, 'externalSpecifiers'))\n    //  Vue.set(this.phyloref, 'externalSpecifiers', []);\n    if (!hasOwnProperty(this.phyloref, 'externalSpecifiers')) {\n      this.phyloref.externalSpecifiers = [];\n    }\n  }\n\n  get label() {\n    // Return a label for this phyloreference.\n    if (hasOwnProperty(this.phyloref, 'label')) return this.phyloref.label;\n    if (hasOwnProperty(this.phyloref, 'labels') && this.phyloref.labels.length > 0) return this.phyloref.labels[0];\n    if (hasOwnProperty(this.phyloref, 'title')) return this.phyloref.title;\n\n    return undefined;\n  }\n\n  set label(newLabel) {\n    // Set a label for this phyloreference.\n    if (hasOwnProperty(this.phyloref, 'label')) {\n      this.phyloref.label = newLabel;\n    } else {\n      // Vue.set(this.phyloref, 'label', newLabel);\n      this.phyloref.label = newLabel;\n    }\n  }\n\n  get specifiers() {\n    // Returns a list of all specifiers by combining the internal and external\n    // specifiers into a single list, with internal specifiers before\n    // external specifiers.\n    let specifiers = this.phyloref.internalSpecifiers;\n    specifiers = specifiers.concat(this.phyloref.externalSpecifiers);\n    return specifiers;\n  }\n\n  getSpecifierType(specifier) {\n    // For a given specifier, return a string indicating whether it is\n    // an 'Internal' or 'External' specifier.\n\n    if (this.phyloref.internalSpecifiers.includes(specifier)) return 'Internal';\n    if (this.phyloref.externalSpecifiers.includes(specifier)) return 'External';\n    return 'Specifier';\n  }\n\n  setSpecifierType(specifier, specifierType) {\n    // Change the type of a given specifier. To do this, we first need\n    // to determine if it was originally an internal or external\n    // specifier, then move it into the other list.\n\n    let index;\n    if (specifierType === 'Internal') {\n      // To set a specifier to 'Internal', we might need to delete it from the\n      // list of external specifiers first.\n      index = this.phyloref.externalSpecifiers.indexOf(specifier);\n      if (index !== -1) this.phyloref.externalSpecifiers.splice(index, 1);\n\n      // Don't add it to the list of internal specifiers if it's already there.\n      if (!this.phyloref.internalSpecifiers.includes(specifier)) {\n        this.phyloref.internalSpecifiers.unshift(specifier);\n      }\n    } else if (specifierType === 'External') {\n      // To set a specifier to 'External', we might need to delete it from the\n      // list of internal specifiers first.\n      index = this.phyloref.internalSpecifiers.indexOf(specifier);\n      if (index !== -1) this.phyloref.internalSpecifiers.splice(index, 1);\n\n      // Don't add it to the list of internal specifiers if it's already there.\n      if (!this.phyloref.externalSpecifiers.includes(specifier)) {\n        this.phyloref.externalSpecifiers.unshift(specifier);\n      }\n    } else {\n      // Neither internal nor external? Ignore.\n    }\n  }\n\n  deleteSpecifier(specifier) {\n    // Since the user interface combines specifiers into a single list,\n    // it doesn't remember if the specifier to be deleted is internal\n    // or external. We delete the intended specifier from both arrays.\n\n    let index = this.phyloref.internalSpecifiers.indexOf(specifier);\n    if (index !== -1) this.phyloref.internalSpecifiers.splice(index, 1);\n\n    index = this.phyloref.externalSpecifiers.indexOf(specifier);\n    if (index !== -1) this.phyloref.externalSpecifiers.splice(index, 1);\n  }\n\n  static getSpecifierLabel(specifier) {\n    // Try to determine the label of a specifier. This checks the\n    // 'label' and 'description' properties, and then tries to create a\n    // descriptive label by using the list of referenced taxonomic units.\n    //\n    // This logically belongs in PhylorefWrapper, but we don't actually need to\n    // know the phyloreference to figure out the specifier label, which is why\n    // this is a static method.\n\n    // Is this specifier even non-null?\n    if (specifier === undefined) return undefined;\n    if (specifier === null) return undefined;\n\n    // Maybe there is a label or description right there?\n    if (hasOwnProperty(specifier, 'label')) return specifier.label;\n    if (hasOwnProperty(specifier, 'description')) return specifier.description;\n\n    // Look at the individual taxonomic units.\n    if (hasOwnProperty(specifier, 'referencesTaxonomicUnits')) {\n      const labels = specifier.referencesTaxonomicUnits\n        .map(tu => new TaxonomicUnitWrapper(tu).label)\n        .filter(label => (label !== undefined));\n      if (labels.length > 0) return labels.join('; ');\n    }\n\n    // No idea!\n    return undefined;\n  }\n\n  getExpectedNodeLabels(phylogeny) {\n    // Given a phylogeny, determine which node labels we expect this phyloref to\n    // resolve to. To do this, we:\n    //  1. Find all node labels that are case-sensitively identical\n    //     to the phyloreference.\n    //  2. Find all node labels that have additionalNodeProperties with\n    //     expectedPhyloreferenceNamed case-sensitively identical to\n    //     the phyloreference.\n    const phylorefLabel = this.label;\n    const nodeLabels = new Set();\n\n    new PhylogenyWrapper(phylogeny).getNodeLabels().forEach((nodeLabel) => {\n      // Is this node label identical to the phyloreference name?\n      if (nodeLabel === phylorefLabel) {\n        nodeLabels.add(nodeLabel);\n      } else if (\n        hasOwnProperty(phylogeny, 'additionalNodeProperties')\n        && hasOwnProperty(phylogeny.additionalNodeProperties, nodeLabel)\n        && hasOwnProperty(phylogeny.additionalNodeProperties[nodeLabel], 'expectedPhyloreferenceNamed')\n      ) {\n        // Does this node label have an expectedPhyloreferenceNamed that\n        // includes this phyloreference name?\n\n        const expectedPhylorefs = phylogeny\n          .additionalNodeProperties[nodeLabel]\n          .expectedPhyloreferenceNamed;\n\n        if (expectedPhylorefs.includes(phylorefLabel)) {\n          nodeLabels.add(nodeLabel);\n        }\n      }\n    });\n\n    // Return node labels sorted alphabetically.\n    return Array.from(nodeLabels).sort();\n  }\n\n  static getStatusCURIEsInEnglish() {\n    // Return dictionary of all phyloref statuses in English\n    return {\n      'pso:draft': 'Draft',\n      'pso:final-draft': 'Final draft',\n      'pso:under-review': 'Under review',\n      'pso:submitted': 'Tested',\n      'pso:published': 'Published',\n      'pso:retracted-from-publication': 'Retracted',\n    };\n  }\n\n  getCurrentStatus() {\n    // Return a result object that contains:\n    //  - status: phyloreference status as a short URI (CURIE)\n    //  - statusInEnglish: an English representation of the phyloref status\n    //  - intervalStart: the start of the interval\n    //  - intervalEnd: the end of the interval\n\n    if (\n      hasOwnProperty(this.phyloref, 'pso:holdsStatusInTime')\n      && Array.isArray(this.phyloref['pso:holdsStatusInTime'])\n      && this.phyloref['pso:holdsStatusInTime'].length > 0\n    ) {\n      // If we have any pso:holdsStatusInTime entries, pick the first one and\n      // extract the CURIE and time interval information from it.\n      const lastStatusInTime = this.phyloref['pso:holdsStatusInTime'][this.phyloref['pso:holdsStatusInTime'].length - 1];\n      const statusCURIE = lastStatusInTime['pso:withStatus']['@id'];\n\n      // Look for time interval information\n      let intervalStart;\n      let intervalEnd;\n\n      if (hasOwnProperty(lastStatusInTime, 'tvc:atTime')) {\n        const atTime = lastStatusInTime['tvc:atTime'];\n        if (hasOwnProperty(atTime, 'timeinterval:hasIntervalStartDate')) intervalStart = atTime['timeinterval:hasIntervalStartDate'];\n        if (hasOwnProperty(atTime, 'timeinterval:hasIntervalEndDate')) intervalEnd = atTime['timeinterval:hasIntervalEndDate'];\n      }\n\n      // Return result object\n      return {\n        statusCURIE,\n        statusInEnglish: PhylorefWrapper.getStatusCURIEsInEnglish()[statusCURIE],\n        intervalStart,\n        intervalEnd,\n      };\n    }\n\n    // If we couldn't figure out a status for this phyloref, assume it's a draft.\n    return {\n      statusCURIE: 'pso:draft',\n      statusInEnglish: PhylorefWrapper.getStatusCURIEsInEnglish()['pso:draft'],\n    };\n  }\n\n  getStatusChanges() {\n    // Return a list of status changes for a particular phyloreference\n    if (hasOwnProperty(this.phyloref, 'pso:holdsStatusInTime')) {\n      return this.phyloref['pso:holdsStatusInTime'].map((entry) => {\n        const result = {};\n\n        // Create a statusCURIE convenience field.\n        if (hasOwnProperty(entry, 'pso:withStatus')) {\n          result.statusCURIE = entry['pso:withStatus']['@id'];\n          result.statusInEnglish = PhylorefWrapper.getStatusCURIEsInEnglish()[result.statusCURIE];\n        }\n\n        // Create intervalStart/intervalEnd convenient fields\n        if (hasOwnProperty(entry, 'tvc:atTime')) {\n          const atTime = entry['tvc:atTime'];\n          if (hasOwnProperty(atTime, 'timeinterval:hasIntervalStartDate')) {\n            result.intervalStart = atTime['timeinterval:hasIntervalStartDate'];\n            result.intervalStartAsCalendar = moment(result.intervalStart).calendar();\n          }\n\n          if (hasOwnProperty(atTime, 'timeinterval:hasIntervalEndDate')) {\n            result.intervalEnd = atTime['timeinterval:hasIntervalEndDate'];\n            result.intervalEndAsCalendar = moment(result.intervalEnd).calendar();\n          }\n        }\n\n        return result;\n      });\n    }\n\n    // No changes? Return an empty list.\n    return [];\n  }\n\n  setStatus(status) {\n    // Set the status of a phyloreference\n    //\n    // Check whether we have a valid status CURIE.\n    if (!hasOwnProperty(PhylorefWrapper.getStatusCURIEsInEnglish(), status)) {\n      throw new TypeError(`setStatus() called with invalid status CURIE '${status}'`);\n    }\n\n    // See if we can end the previous interval.\n    const currentTime = new Date(Date.now()).toISOString();\n\n    if (!hasOwnProperty(this.phyloref, 'pso:holdsStatusInTime')) {\n      // Vue.set(this.phyloref, 'pso:holdsStatusInTime', []);\n      this.phyloref['pso:holdsStatusInTime'] = [];\n    }\n\n    // Check to see if there's a previous time interval we should end.\n    if (\n      Array.isArray(this.phyloref['pso:holdsStatusInTime'])\n      && this.phyloref['pso:holdsStatusInTime'].length > 0\n    ) {\n      const lastStatusInTime = this.phyloref['pso:holdsStatusInTime'][this.phyloref['pso:holdsStatusInTime'].length - 1];\n\n      // if (!hasOwnProperty(lastStatusInTime, 'tvc:atTime'))\n      //  Vue.set(lastStatusInTime, 'tvc:atTime', {});\n      if (!hasOwnProperty(lastStatusInTime, 'tvc:atTime')) {\n        lastStatusInTime['tvc:atTime'] = {};\n      }\n      if (!hasOwnProperty(lastStatusInTime['tvc:atTime'], 'timeinterval:hasIntervalEndDate')) {\n        // If the last time entry doesn't already have an interval end date, set it to now.\n        lastStatusInTime['tvc:atTime']['timeinterval:hasIntervalEndDate'] = currentTime;\n      }\n    }\n\n    // Create new entry.\n    this.phyloref['pso:holdsStatusInTime'].push({\n      '@type': 'http://purl.org/spar/pso/StatusInTime',\n      'pso:withStatus': { '@id': status },\n      'tvc:atTime': {\n        'timeinterval:hasIntervalStartDate': currentTime,\n      },\n    });\n  }\n\n  asJSONLD(phylorefURI) {\n    // Export this phyloreference in JSON-LD.\n\n    // Keep all currently extant data.\n    // - baseURI: the base URI for this phyloreference\n    const phylorefAsJSONLD = JSON.parse(JSON.stringify(this.phyloref));\n\n    // Set the @id and @type.\n    phylorefAsJSONLD['@id'] = phylorefURI;\n\n    phylorefAsJSONLD['@type'] = [\n      // We pun this as an instance that is a Phyloreference.\n      // (We need this to ensure that the object properties that store\n      // information on specifiers will work correctly)\n      'phyloref:Phyloreference',\n      // Since we're writing this in RDF, just adding a '@type' of\n      // phyloref:Phyloreference would imply that phylorefURI is a named\n      // individual of class phyloref:Phyloreference. We need to explicitly\n      // let OWL know that this phylorefURI is an owl:Class.\n      //\n      // (This is implied by some of the properties that we apply to phylorefURI,\n      // such as by the domain of owl:equivalentClass. But it's nice to make that\n      // explicit as well!)\n      'owl:Class',\n    ];\n\n    // Add identifiers for each internal specifier.\n    let internalSpecifierCount = 0;\n    phylorefAsJSONLD.internalSpecifiers.forEach((internalSpecifierToChange) => {\n      internalSpecifierCount += 1;\n\n      const internalSpecifier = internalSpecifierToChange;\n      const specifierId = `${phylorefURI}_specifier_internal${internalSpecifierCount}`;\n\n      internalSpecifier['@id'] = specifierId;\n      internalSpecifier['@type'] = [\n        TESTCASE_SPECIFIER,\n      ];\n\n      // Add identifiers to all taxonomic units.\n      let countTaxonomicUnits = 0;\n      if (hasOwnProperty(internalSpecifier, 'referencesTaxonomicUnits')) {\n        internalSpecifier.referencesTaxonomicUnits.forEach((tunitToChange) => {\n          const tunit = tunitToChange;\n\n          tunit['@id'] = `${specifierId}_tunit${countTaxonomicUnits}`;\n          tunit['@type'] = 'http://purl.obolibrary.org/obo/CDAO_0000138';\n          countTaxonomicUnits += 1;\n        });\n      }\n    });\n\n    // Add identifiers for each external specifier.\n    let externalSpecifierCount = 0;\n    phylorefAsJSONLD.externalSpecifiers.forEach((externalSpecifierToChange) => {\n      externalSpecifierCount += 1;\n\n      const externalSpecifier = externalSpecifierToChange;\n      const specifierId = `${phylorefURI}_specifier_external${externalSpecifierCount}`;\n\n      externalSpecifier['@id'] = specifierId;\n      externalSpecifier['@type'] = [\n        TESTCASE_SPECIFIER,\n      ];\n\n      // Add identifiers to all taxonomic units.\n      let countTaxonomicUnits = 0;\n      if (hasOwnProperty(externalSpecifier, 'referencesTaxonomicUnits')) {\n        externalSpecifier.referencesTaxonomicUnits.forEach((tunitToChange) => {\n          const tunit = tunitToChange;\n\n          tunit['@id'] = `${specifierId}_tunit${countTaxonomicUnits}`;\n          tunit['@type'] = 'http://purl.obolibrary.org/obo/CDAO_0000138';\n          countTaxonomicUnits += 1;\n        });\n      }\n    });\n\n    // For historical reasons, the Clade Ontology uses 'hasInternalSpecifier' to\n    // store the specifiers as OWL classes and 'internalSpecifiers' to store them\n    // as RDF annotations. We simplify that here by duplicating them here, but\n    // this should really be fixed in the Clade Ontology and in phyx.json.\n    phylorefAsJSONLD.hasInternalSpecifier = phylorefAsJSONLD.internalSpecifiers;\n    phylorefAsJSONLD.hasExternalSpecifier = phylorefAsJSONLD.externalSpecifiers;\n\n    if (internalSpecifierCount === 0 && externalSpecifierCount === 0) {\n      phylorefAsJSONLD.malformedPhyloreference = 'No specifiers provided';\n    } else if (externalSpecifierCount > 1) {\n      phylorefAsJSONLD.malformedPhyloreference = 'Multiple external specifiers are not yet supported';\n    } else if (internalSpecifierCount === 1 && externalSpecifierCount === 0) {\n      phylorefAsJSONLD.malformedPhyloreference = 'Only a single internal specifier was provided';\n    } else if (externalSpecifierCount === 0) {\n      // This phyloreference is made up entirely of internal specifiers.\n\n      // We can write this in an accumulative manner by creating class expressions\n      // in the form:\n      //  mrca(mrca(mrca(node1, node2), node3), node4)\n\n      // We could write this as a single giant expression, but this tends to\n      // slow down the reasoner dramatically. So instead, we break it up into a\n      // series of \"additional classes\", each of which represents a part of the\n      // overall expression.\n      phylorefAsJSONLD.hasAdditionalClass = [];\n\n      let equivalentClassAccumulator = PhylorefWrapper.getClassExpressionForMRCA(\n        phylorefURI,\n        phylorefAsJSONLD.hasAdditionalClass,\n        phylorefAsJSONLD.internalSpecifiers[0],\n        phylorefAsJSONLD.internalSpecifiers[1]\n      );\n\n      for (let index = 2; index < internalSpecifierCount; index += 1) {\n        equivalentClassAccumulator = PhylorefWrapper.getClassExpressionForMRCA(\n          phylorefURI,\n          phylorefAsJSONLD.hasAdditionalClass,\n          equivalentClassAccumulator,\n          phylorefAsJSONLD.internalSpecifiers[index]\n        );\n      }\n\n      phylorefAsJSONLD.equivalentClass = equivalentClassAccumulator;\n    } else {\n      // This phyloreference is made up of one external specifier and some number\n      // of internal specifiers.\n\n      const internalSpecifierRestrictions = phylorefAsJSONLD.internalSpecifiers\n        .map(specifier => PhylorefWrapper\n          .wrapInternalOWLRestriction(PhylorefWrapper.getOWLRestrictionForSpecifier(specifier)));\n\n      const externalSpecifierRestrictions = phylorefAsJSONLD.externalSpecifiers\n        .map(specifier => PhylorefWrapper\n          .wrapExternalOWLRestriction(PhylorefWrapper.getOWLRestrictionForSpecifier(specifier)));\n\n      phylorefAsJSONLD.equivalentClass = {\n        '@type': 'owl:Class',\n        intersectionOf: internalSpecifierRestrictions.concat(externalSpecifierRestrictions),\n      };\n    }\n\n    return phylorefAsJSONLD;\n  }\n\n  static getOWLRestrictionForSpecifier(specifier) {\n    // Return an OWL restriction corresponding to a specifier.\n    return {\n      '@type': 'owl:Restriction',\n      onProperty: 'testcase:matches_specifier',\n      hasValue: {\n        '@id': specifier['@id'],\n      },\n    };\n  }\n\n  static wrapInternalOWLRestriction(restriction) {\n    // Wraps a restriction to act as an internal specifier.\n    // Mainly, we just need to extend the restriction to match:\n    //  restriction or cdao:has_Descendant some restriction\n    return {\n      '@type': 'owl:Restriction',\n      unionOf: [\n        restriction,\n        {\n          '@type': 'owl:Restriction',\n          onProperty: CDAO_HAS_DESCENDANT,\n          someValuesFrom: restriction,\n        },\n      ],\n    };\n  }\n\n  static wrapExternalOWLRestriction(restriction) {\n    // Wraps a restriction to act as an external specifier.\n    // This needs to match:\n    //  cdao:has_Sibling some (restriction or cdao:has_Descendant some restriction)\n    // Since that second part is just an internal specifier restriction, we can\n    // incorporate that in here.\n    return {\n      '@type': 'owl:Restriction',\n      // onProperty: PHYLOREF_HAS_SIBLING,\n      onProperty: PHYLOREF_EXCLUDES_LINEAGE_TO,\n      someValuesFrom: restriction,\n    };\n  }\n\n  static getClassExpressionForMRCA(baseURI, additionalClasses, specifier1, specifier2) {\n    // Create an OWL restriction for the most recent common ancestor (MRCA)\n    // of the nodes matched by two specifiers.\n    const additionalClassesIds = new Set(additionalClasses.map(cl => cl['@id']));\n\n    // Specifiers might be either a real specifier or an additional class.\n    // We can check their @ids here and translate specifiers into class expressions.\n    let owlRestriction1;\n    if (additionalClassesIds.has(specifier1['@id'])) {\n      owlRestriction1 = specifier1;\n    } else {\n      owlRestriction1 = PhylorefWrapper.getOWLRestrictionForSpecifier(specifier1);\n    }\n\n    let owlRestriction2;\n    if (additionalClassesIds.has(specifier2['@id'])) {\n      owlRestriction2 = specifier2;\n    } else {\n      owlRestriction2 = PhylorefWrapper.getOWLRestrictionForSpecifier(specifier2);\n    }\n\n    // Construct OWL expression.\n    const mrcaAsOWL = {\n      '@type': 'owl:Class',\n      unionOf: [\n        {\n          // What if specifier2 is a descendant of specifier1? If so, the MRCA\n          // is specifier1!\n          '@type': 'owl:Class',\n          intersectionOf: [\n            owlRestriction1,\n            {\n              '@type': 'owl:Restriction',\n              onProperty: CDAO_HAS_DESCENDANT,\n              someValuesFrom: owlRestriction2,\n            },\n          ],\n        },\n        {\n          // What if specifier1 is a descendant of specifier2? If so, the MRCA\n          // is specifier2!\n          '@type': 'owl:Class',\n          intersectionOf: [\n            owlRestriction2,\n            {\n              '@type': 'owl:Restriction',\n              onProperty: CDAO_HAS_DESCENDANT,\n              someValuesFrom: owlRestriction1,\n            },\n          ],\n        },\n        {\n          // If neither specifier is a descendant of the other, we can use our\n          // standard formula.\n          '@type': 'owl:Class',\n          intersectionOf: [{\n            '@type': 'owl:Restriction',\n            onProperty: CDAO_HAS_CHILD,\n            someValuesFrom: {\n              '@type': 'owl:Class',\n              intersectionOf: [\n                PhylorefWrapper.wrapInternalOWLRestriction(owlRestriction1),\n                PhylorefWrapper.wrapExternalOWLRestriction(owlRestriction2),\n              ],\n            },\n          }, {\n            '@type': 'owl:Restriction',\n            onProperty: CDAO_HAS_CHILD,\n            someValuesFrom: {\n              '@type': 'owl:Class',\n              intersectionOf: [\n                PhylorefWrapper.wrapInternalOWLRestriction(owlRestriction2),\n                PhylorefWrapper.wrapExternalOWLRestriction(owlRestriction1),\n              ],\n            },\n          }],\n        },\n      ],\n    };\n\n    // Instead of building a single, large, complex expression, reasoners appear\n    // to prefer smaller expressions for classes that are assembled together.\n    // To help with that, we'll store the class expression in the additionalClasses\n    // list, and return a reference to this class.\n    const additionalClassId = `${baseURI}_additional${additionalClasses.length}`;\n    additionalClasses.push({\n      '@id': additionalClassId,\n      '@type': 'owl:Class',\n      equivalentClass: mrcaAsOWL,\n    });\n\n    return { '@id': additionalClassId };\n  }\n}\n\n/* PHYX file wrapper */\n\nclass PHYXWrapper {\n  // Wraps an entire PHYX document.\n\n  constructor(phyx, newickParser) {\n    // Wraps an entire PHYX document.\n    // - phyx: the Phyx structure to wrap.\n    // - newickParser: a method that accepts a Newick string and returns a list of\n    //   nodes. Each node should have a 'children' key with its children and\n    //   optionally a 'name' key with its label. This code previously depended\n    //   on phylotree.js, whose newick_parser() function works exactly like this.\n    //   This option allows you to drop in Phylotree's newick_parser() or --\n    //   if you prefer -- any other option.\n    this.phyx = phyx;\n    this.newickParser = newickParser;\n  }\n\n  static get BASE_URI() {\n    // Returns the default base URI for PHYX documents in JSON-LD.\n    return '';\n  }\n\n  static getBaseURIForPhyloref(phylorefCount) {\n    // Return the base URI for a phyloreference based on its index.\n    return `${PHYXWrapper.BASE_URI}#phyloref${phylorefCount}`;\n  }\n\n  static getBaseURIForPhylogeny(phylogenyCount) {\n    // Return the base URI for phylogenies based on its index.\n    return `${PHYXWrapper.BASE_URI}#phylogeny${phylogenyCount}`;\n  }\n\n  static getBaseURIForTUMatch(countTaxonomicUnitMatches) {\n    // Return the base URI for taxonomic unit matches.\n    return `${PHYXWrapper.BASE_URI}#taxonomic_unit_match${countTaxonomicUnitMatches}`;\n  }\n\n  asJSONLD() {\n    // Export this PHYX document as a JSON-LD document. This replicates what\n    // phyx2owl.py does in the Clade Ontology.\n    //\n    // The document is mostly in JSON-LD already, except for two important\n    // things:\n    //  1. We have to convert all phylogenies into a series of statements\n    //     relating to the nodes inside these phylogenies.\n    //  2. We have to convert phylogenies into OWL restrictions.\n    //  3. Insert all matches between taxonomic units in this file.\n    //\n    const jsonld = extend(true, {}, this.phyx);\n\n    // Add descriptions for individual nodes in each phylogeny.\n    if (hasOwnProperty(jsonld, 'phylogenies')) {\n      jsonld.phylogenies = jsonld.phylogenies.map(\n        (phylogeny, countPhylogeny) => new PhylogenyWrapper(phylogeny)\n          .asJSONLD(PHYXWrapper.getBaseURIForPhylogeny(countPhylogeny), this.newickParser)\n      );\n    }\n\n    // Convert phyloreferences into an OWL class restriction\n    if (hasOwnProperty(jsonld, 'phylorefs')) {\n      jsonld.phylorefs = jsonld.phylorefs.map(\n        (phyloref, countPhyloref) => new PhylorefWrapper(phyloref)\n          .asJSONLD(PHYXWrapper.getBaseURIForPhyloref(countPhyloref))\n      );\n    }\n\n    // Match all specifiers with nodes.\n    if (hasOwnProperty(jsonld, 'phylorefs') && hasOwnProperty(jsonld, 'phylogenies')) {\n      jsonld.hasTaxonomicUnitMatches = [];\n\n      // Used to create unique identifiers for each taxonomic unit match.\n      let countTaxonomicUnitMatches = 0;\n\n      jsonld.phylorefs.forEach((phylorefToChange) => {\n        const phyloref = phylorefToChange;\n        let specifiers = [];\n\n        if (hasOwnProperty(phyloref, 'internalSpecifiers')) {\n          specifiers = specifiers.concat(phyloref.internalSpecifiers);\n        }\n\n        if (hasOwnProperty(phyloref, 'externalSpecifiers')) {\n          specifiers = specifiers.concat(phyloref.externalSpecifiers);\n        }\n\n        specifiers.forEach((specifier) => {\n          if (!hasOwnProperty(specifier, 'referencesTaxonomicUnits')) return;\n          const specifierTUs = specifier.referencesTaxonomicUnits;\n          let nodesMatchedCount = 0;\n\n          jsonld.phylogenies.forEach((phylogenyToChange) => {\n            const phylogeny = phylogenyToChange;\n\n            specifierTUs.forEach((specifierTU) => {\n              phylogeny.nodes.forEach((node) => {\n                if (!hasOwnProperty(node, 'representsTaxonomicUnits')) return;\n                const nodeTUs = node.representsTaxonomicUnits;\n\n                nodeTUs.forEach((nodeTU) => {\n                  const matcher = new TaxonomicUnitMatcher(specifierTU, nodeTU);\n                  if (matcher.matched) {\n                    const tuMatchAsJSONLD = matcher.asJSONLD(\n                      PHYXWrapper.getBaseURIForTUMatch(countTaxonomicUnitMatches)\n                    );\n                    jsonld.hasTaxonomicUnitMatches.push(tuMatchAsJSONLD);\n                    nodesMatchedCount += 1;\n                    countTaxonomicUnitMatches += 1;\n                  }\n                });\n              });\n            });\n          });\n\n          if (nodesMatchedCount === 0) {\n            // No nodes matched? Record this as an unmatched specifier.\n            if (!hasOwnProperty(phyloref, 'hasUnmatchedSpecifiers')) phyloref.hasUnmatchedSpecifiers = [];\n            phyloref.hasUnmatchedSpecifiers.push(specifier);\n          }\n        });\n      });\n    }\n\n    // Finally, add the base URI as an ontology.\n    jsonld['@id'] = PHYXWrapper.BASE_URI;\n    jsonld['@type'] = [PHYLOREFERENCE_TEST_CASE, 'owl:Ontology'];\n    jsonld['owl:imports'] = [\n      'http://raw.githubusercontent.com/phyloref/curation-workflow/develop/ontologies/phyloref_testcase.owl',\n      // - Will become 'http://vocab.phyloref.org/phyloref/testcase.owl'\n      'http://ontology.phyloref.org/2018-12-04/phyloref.owl',\n      // - The Phyloreferencing ontology.\n      'http://purl.obolibrary.org/obo/bco.owl',\n      // - Contains OWL definitions for Darwin Core terms\n    ];\n\n    // If the '@context' is missing, add it here.\n    if (!hasOwnProperty(jsonld, '@context')) {\n      jsonld['@context'] = 'http://www.phyloref.org/phyx.js/v0.1.0/phyx.json';\n    }\n\n    return jsonld;\n  }\n}\n\n/* Exports */\nmodule.exports = {\n  ScientificNameWrapper,\n  SpecimenWrapper,\n  TaxonomicUnitWrapper,\n  TaxonomicUnitMatcher,\n  PhylogenyWrapper,\n  PhylorefWrapper,\n  PHYXWrapper,\n  phyxCacheManager,\n};\n",
    "static": true,
    "longname": "/home/vaidyagi/code/phyloref/phyx.js/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "variable",
    "name": "parse",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~parse",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 50,
    "kind": "variable",
    "name": "moment",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~moment",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 51,
    "kind": "variable",
    "name": "extend",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~extend",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 52,
    "kind": "variable",
    "name": "CDAO_HAS_CHILD",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~CDAO_HAS_CHILD",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 53,
    "kind": "variable",
    "name": "CDAO_HAS_DESCENDANT",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~CDAO_HAS_DESCENDANT",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 54,
    "kind": "variable",
    "name": "PHYLOREF_EXCLUDES_LINEAGE_TO",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~PHYLOREF_EXCLUDES_LINEAGE_TO",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 55,
    "kind": "variable",
    "name": "PHYLOREFERENCE_TEST_CASE",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~PHYLOREFERENCE_TEST_CASE",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 56,
    "kind": "variable",
    "name": "PHYLOREFERENCE_PHYLOGENY",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~PHYLOREFERENCE_PHYLOGENY",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 57,
    "kind": "variable",
    "name": "TESTCASE_SPECIFIER",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~TESTCASE_SPECIFIER",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 58,
    "kind": "function",
    "name": "hasOwnProperty",
    "memberof": "src/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~hasOwnProperty",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 59,
    "kind": "class",
    "name": "CacheManager",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~CacheManager",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 60,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/index.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~CacheManager#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "undocument": true
  },
  {
    "__docId__": 61,
    "kind": "method",
    "name": "clear",
    "memberof": "src/index.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~CacheManager#clear",
    "access": "public",
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 62,
    "kind": "member",
    "name": "caches",
    "memberof": "src/index.js~CacheManager",
    "static": false,
    "longname": "src/index.js~CacheManager#caches",
    "access": "public",
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "method",
    "name": "has",
    "memberof": "src/index.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~CacheManager#has",
    "access": "public",
    "description": null,
    "lineNumber": 67,
    "undocument": true,
    "params": [
      {
        "name": "cacheName",
        "types": [
          "*"
        ]
      },
      {
        "name": "cacheKey",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "method",
    "name": "get",
    "memberof": "src/index.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~CacheManager#get",
    "access": "public",
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "params": [
      {
        "name": "cacheName",
        "types": [
          "*"
        ]
      },
      {
        "name": "cacheKey",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 65,
    "kind": "method",
    "name": "put",
    "memberof": "src/index.js~CacheManager",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~CacheManager#put",
    "access": "public",
    "description": null,
    "lineNumber": 80,
    "undocument": true,
    "params": [
      {
        "name": "cacheName",
        "types": [
          "*"
        ]
      },
      {
        "name": "cacheKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 66,
    "kind": "class",
    "name": "ScientificNameWrapper",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~ScientificNameWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": null,
    "lineNumber": 91,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 67,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/index.js~ScientificNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~ScientificNameWrapper#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 96,
    "undocument": true
  },
  {
    "__docId__": 68,
    "kind": "member",
    "name": "scname",
    "memberof": "src/index.js~ScientificNameWrapper",
    "static": false,
    "longname": "src/index.js~ScientificNameWrapper#scname",
    "access": "public",
    "description": null,
    "lineNumber": 99,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 69,
    "kind": "method",
    "name": "createFromVerbatimName",
    "memberof": "src/index.js~ScientificNameWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~ScientificNameWrapper.createFromVerbatimName",
    "access": "public",
    "description": null,
    "lineNumber": 102,
    "undocument": true,
    "params": [
      {
        "name": "verbatimName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 70,
    "kind": "get",
    "name": "scientificName",
    "memberof": "src/index.js~ScientificNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~ScientificNameWrapper#scientificName",
    "access": "public",
    "description": null,
    "lineNumber": 136,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 71,
    "kind": "get",
    "name": "binomialName",
    "memberof": "src/index.js~ScientificNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~ScientificNameWrapper#binomialName",
    "access": "public",
    "description": null,
    "lineNumber": 141,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 72,
    "kind": "get",
    "name": "genus",
    "memberof": "src/index.js~ScientificNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~ScientificNameWrapper#genus",
    "access": "public",
    "description": null,
    "lineNumber": 148,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 73,
    "kind": "get",
    "name": "specificEpithet",
    "memberof": "src/index.js~ScientificNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~ScientificNameWrapper#specificEpithet",
    "access": "public",
    "description": null,
    "lineNumber": 161,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "get",
    "name": "label",
    "memberof": "src/index.js~ScientificNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~ScientificNameWrapper#label",
    "access": "public",
    "description": null,
    "lineNumber": 174,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 75,
    "kind": "class",
    "name": "SpecimenWrapper",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~SpecimenWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": null,
    "lineNumber": 182,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 76,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/index.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~SpecimenWrapper#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 185,
    "undocument": true
  },
  {
    "__docId__": 77,
    "kind": "member",
    "name": "specimen",
    "memberof": "src/index.js~SpecimenWrapper",
    "static": false,
    "longname": "src/index.js~SpecimenWrapper#specimen",
    "access": "public",
    "description": null,
    "lineNumber": 187,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 78,
    "kind": "method",
    "name": "createFromOccurrenceID",
    "memberof": "src/index.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~SpecimenWrapper.createFromOccurrenceID",
    "access": "public",
    "description": null,
    "lineNumber": 208,
    "undocument": true,
    "params": [
      {
        "name": "occurrenceID",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 79,
    "kind": "get",
    "name": "catalogNumber",
    "memberof": "src/index.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~SpecimenWrapper#catalogNumber",
    "access": "public",
    "description": null,
    "lineNumber": 262,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "get",
    "name": "institutionCode",
    "memberof": "src/index.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~SpecimenWrapper#institutionCode",
    "access": "public",
    "description": null,
    "lineNumber": 275,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "get",
    "name": "collectionCode",
    "memberof": "src/index.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~SpecimenWrapper#collectionCode",
    "access": "public",
    "description": null,
    "lineNumber": 288,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 82,
    "kind": "get",
    "name": "occurrenceID",
    "memberof": "src/index.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~SpecimenWrapper#occurrenceID",
    "access": "public",
    "description": null,
    "lineNumber": 301,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 83,
    "kind": "get",
    "name": "label",
    "memberof": "src/index.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~SpecimenWrapper#label",
    "access": "public",
    "description": null,
    "lineNumber": 335,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 84,
    "kind": "class",
    "name": "TaxonomicUnitWrapper",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~TaxonomicUnitWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": null,
    "lineNumber": 343,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 85,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/index.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~TaxonomicUnitWrapper#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 348,
    "undocument": true
  },
  {
    "__docId__": 86,
    "kind": "member",
    "name": "tunit",
    "memberof": "src/index.js~TaxonomicUnitWrapper",
    "static": false,
    "longname": "src/index.js~TaxonomicUnitWrapper#tunit",
    "access": "public",
    "description": null,
    "lineNumber": 350,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 87,
    "kind": "get",
    "name": "label",
    "memberof": "src/index.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~TaxonomicUnitWrapper#label",
    "access": "public",
    "description": null,
    "lineNumber": 353,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "get",
    "name": "scientificNames",
    "memberof": "src/index.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~TaxonomicUnitWrapper#scientificNames",
    "access": "public",
    "description": null,
    "lineNumber": 390,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 89,
    "kind": "get",
    "name": "includeSpecimens",
    "memberof": "src/index.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~TaxonomicUnitWrapper#includeSpecimens",
    "access": "public",
    "description": null,
    "lineNumber": 394,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 90,
    "kind": "get",
    "name": "externalReferences",
    "memberof": "src/index.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~TaxonomicUnitWrapper#externalReferences",
    "access": "public",
    "description": null,
    "lineNumber": 398,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 91,
    "kind": "method",
    "name": "getTaxonomicUnitsFromNodeLabel",
    "memberof": "src/index.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~TaxonomicUnitWrapper.getTaxonomicUnitsFromNodeLabel",
    "access": "public",
    "description": null,
    "lineNumber": 402,
    "undocument": true,
    "params": [
      {
        "name": "nodeLabel",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 92,
    "kind": "class",
    "name": "TaxonomicUnitMatcher",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~TaxonomicUnitMatcher",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": null,
    "lineNumber": 438,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 93,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/index.js~TaxonomicUnitMatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~TaxonomicUnitMatcher#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 442,
    "undocument": true
  },
  {
    "__docId__": 94,
    "kind": "member",
    "name": "tunit1",
    "memberof": "src/index.js~TaxonomicUnitMatcher",
    "static": false,
    "longname": "src/index.js~TaxonomicUnitMatcher#tunit1",
    "access": "public",
    "description": null,
    "lineNumber": 445,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 95,
    "kind": "member",
    "name": "tunit2",
    "memberof": "src/index.js~TaxonomicUnitMatcher",
    "static": false,
    "longname": "src/index.js~TaxonomicUnitMatcher#tunit2",
    "access": "public",
    "description": null,
    "lineNumber": 446,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 96,
    "kind": "member",
    "name": "matched",
    "memberof": "src/index.js~TaxonomicUnitMatcher",
    "static": false,
    "longname": "src/index.js~TaxonomicUnitMatcher#matched",
    "access": "public",
    "description": null,
    "lineNumber": 449,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 97,
    "kind": "member",
    "name": "matchReason",
    "memberof": "src/index.js~TaxonomicUnitMatcher",
    "static": false,
    "longname": "src/index.js~TaxonomicUnitMatcher#matchReason",
    "access": "public",
    "description": null,
    "lineNumber": 450,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 98,
    "kind": "method",
    "name": "asJSONLD",
    "memberof": "src/index.js~TaxonomicUnitMatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~TaxonomicUnitMatcher#asJSONLD",
    "access": "public",
    "description": null,
    "lineNumber": 456,
    "undocument": true,
    "params": [
      {
        "name": "idURI",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"@id\": *, \"@type\": string, \"reason\": *, \"matchesTaxonomicUnits\": *}"
      ]
    }
  },
  {
    "__docId__": 99,
    "kind": "method",
    "name": "match",
    "memberof": "src/index.js~TaxonomicUnitMatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~TaxonomicUnitMatcher#match",
    "access": "public",
    "description": null,
    "lineNumber": 471,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 103,
    "kind": "method",
    "name": "matchByBinomialName",
    "memberof": "src/index.js~TaxonomicUnitMatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~TaxonomicUnitMatcher#matchByBinomialName",
    "access": "public",
    "description": null,
    "lineNumber": 485,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 105,
    "kind": "method",
    "name": "matchByExternalReferences",
    "memberof": "src/index.js~TaxonomicUnitMatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~TaxonomicUnitMatcher#matchByExternalReferences",
    "access": "public",
    "description": null,
    "lineNumber": 510,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 107,
    "kind": "method",
    "name": "matchBySpecimenIdentifier",
    "memberof": "src/index.js~TaxonomicUnitMatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~TaxonomicUnitMatcher#matchBySpecimenIdentifier",
    "access": "public",
    "description": null,
    "lineNumber": 538,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 109,
    "kind": "class",
    "name": "PhylogenyWrapper",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~PhylogenyWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": null,
    "lineNumber": 565,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 110,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/index.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~PhylogenyWrapper#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 571,
    "undocument": true
  },
  {
    "__docId__": 111,
    "kind": "member",
    "name": "phylogeny",
    "memberof": "src/index.js~PhylogenyWrapper",
    "static": false,
    "longname": "src/index.js~PhylogenyWrapper#phylogeny",
    "access": "public",
    "description": null,
    "lineNumber": 581,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 112,
    "kind": "method",
    "name": "getErrorsInNewickString",
    "memberof": "src/index.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~PhylogenyWrapper.getErrorsInNewickString",
    "access": "public",
    "description": null,
    "lineNumber": 584,
    "undocument": true,
    "params": [
      {
        "name": "newick",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 113,
    "kind": "method",
    "name": "recurseNodes",
    "memberof": "src/index.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~PhylogenyWrapper.recurseNodes",
    "access": "public",
    "description": null,
    "lineNumber": 636,
    "undocument": true,
    "params": [
      {
        "name": "node",
        "types": [
          "*"
        ]
      },
      {
        "name": "func",
        "types": [
          "*"
        ]
      },
      {
        "name": "nodeCount",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      },
      {
        "name": "parentCount",
        "optional": true,
        "types": [
          "*"
        ],
        "defaultRaw": "undefined",
        "defaultValue": "undefined"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 114,
    "kind": "method",
    "name": "getTaxonomicUnits",
    "memberof": "src/index.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~PhylogenyWrapper#getTaxonomicUnits",
    "access": "public",
    "description": null,
    "lineNumber": 670,
    "undocument": true,
    "params": [
      {
        "name": "nodeType",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "both",
        "defaultValue": "both"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 115,
    "kind": "method",
    "name": "getNodeLabels",
    "memberof": "src/index.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~PhylogenyWrapper#getNodeLabels",
    "access": "public",
    "description": null,
    "lineNumber": 693,
    "undocument": true,
    "params": [
      {
        "name": "nodeType",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "both",
        "defaultValue": "both"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 116,
    "kind": "method",
    "name": "getTaxonomicUnitsForNodeLabel",
    "memberof": "src/index.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~PhylogenyWrapper#getTaxonomicUnitsForNodeLabel",
    "access": "public",
    "description": null,
    "lineNumber": 744,
    "undocument": true,
    "params": [
      {
        "name": "nodeLabel",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 117,
    "kind": "method",
    "name": "getNodeLabelsMatchedBySpecifier",
    "memberof": "src/index.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~PhylogenyWrapper#getNodeLabelsMatchedBySpecifier",
    "access": "public",
    "description": null,
    "lineNumber": 768,
    "undocument": true,
    "params": [
      {
        "name": "specifier",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 118,
    "kind": "method",
    "name": "getParsedNewick",
    "memberof": "src/index.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~PhylogenyWrapper.getParsedNewick",
    "access": "public",
    "description": null,
    "lineNumber": 792,
    "undocument": true,
    "params": [
      {
        "name": "newick",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"json\": *}"
      ]
    }
  },
  {
    "__docId__": 119,
    "kind": "method",
    "name": "getParsedNewickWithIRIs",
    "memberof": "src/index.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~PhylogenyWrapper#getParsedNewickWithIRIs",
    "access": "public",
    "description": null,
    "lineNumber": 823,
    "undocument": true,
    "params": [
      {
        "name": "baseURI",
        "types": [
          "*"
        ]
      },
      {
        "name": "newickParser",
        "optional": true,
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 120,
    "kind": "method",
    "name": "getNodesAsJSONLD",
    "memberof": "src/index.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~PhylogenyWrapper#getNodesAsJSONLD",
    "access": "public",
    "description": null,
    "lineNumber": 843,
    "undocument": true,
    "params": [
      {
        "name": "baseURI",
        "types": [
          "*"
        ]
      },
      {
        "name": "newickParser",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 121,
    "kind": "method",
    "name": "asJSONLD",
    "memberof": "src/index.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~PhylogenyWrapper#asJSONLD",
    "access": "public",
    "description": null,
    "lineNumber": 941,
    "undocument": true,
    "params": [
      {
        "name": "baseURI",
        "types": [
          "*"
        ]
      },
      {
        "name": "newickParser",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 122,
    "kind": "class",
    "name": "PhylorefWrapper",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~PhylorefWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": null,
    "lineNumber": 967,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 123,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/index.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~PhylorefWrapper#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 970,
    "undocument": true
  },
  {
    "__docId__": 124,
    "kind": "member",
    "name": "phyloref",
    "memberof": "src/index.js~PhylorefWrapper",
    "static": false,
    "longname": "src/index.js~PhylorefWrapper#phyloref",
    "access": "public",
    "description": null,
    "lineNumber": 972,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 125,
    "kind": "get",
    "name": "label",
    "memberof": "src/index.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~PhylorefWrapper#label",
    "access": "public",
    "description": null,
    "lineNumber": 987,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 126,
    "kind": "set",
    "name": "label",
    "memberof": "src/index.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~PhylorefWrapper#label",
    "access": "public",
    "description": null,
    "lineNumber": 996,
    "undocument": true
  },
  {
    "__docId__": 127,
    "kind": "get",
    "name": "specifiers",
    "memberof": "src/index.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~PhylorefWrapper#specifiers",
    "access": "public",
    "description": null,
    "lineNumber": 1006,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 128,
    "kind": "method",
    "name": "getSpecifierType",
    "memberof": "src/index.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~PhylorefWrapper#getSpecifierType",
    "access": "public",
    "description": null,
    "lineNumber": 1015,
    "undocument": true,
    "params": [
      {
        "name": "specifier",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 129,
    "kind": "method",
    "name": "setSpecifierType",
    "memberof": "src/index.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~PhylorefWrapper#setSpecifierType",
    "access": "public",
    "description": null,
    "lineNumber": 1024,
    "undocument": true,
    "params": [
      {
        "name": "specifier",
        "types": [
          "*"
        ]
      },
      {
        "name": "specifierType",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 130,
    "kind": "method",
    "name": "deleteSpecifier",
    "memberof": "src/index.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~PhylorefWrapper#deleteSpecifier",
    "access": "public",
    "description": null,
    "lineNumber": 1055,
    "undocument": true,
    "params": [
      {
        "name": "specifier",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 131,
    "kind": "method",
    "name": "getSpecifierLabel",
    "memberof": "src/index.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~PhylorefWrapper.getSpecifierLabel",
    "access": "public",
    "description": null,
    "lineNumber": 1067,
    "undocument": true,
    "params": [
      {
        "name": "specifier",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 132,
    "kind": "method",
    "name": "getExpectedNodeLabels",
    "memberof": "src/index.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~PhylorefWrapper#getExpectedNodeLabels",
    "access": "public",
    "description": null,
    "lineNumber": 1096,
    "undocument": true,
    "params": [
      {
        "name": "phylogeny",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 133,
    "kind": "method",
    "name": "getStatusCURIEsInEnglish",
    "memberof": "src/index.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~PhylorefWrapper.getStatusCURIEsInEnglish",
    "access": "public",
    "description": null,
    "lineNumber": 1133,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "{\"pso:draft\": string, \"pso:final-draft\": string, \"pso:under-review\": string, \"pso:submitted\": string, \"pso:published\": string, \"pso:retracted-from-publication\": string}"
      ]
    }
  },
  {
    "__docId__": 134,
    "kind": "method",
    "name": "getCurrentStatus",
    "memberof": "src/index.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~PhylorefWrapper#getCurrentStatus",
    "access": "public",
    "description": null,
    "lineNumber": 1145,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "{\"statusCURIE\": string, \"statusInEnglish\": *}"
      ]
    }
  },
  {
    "__docId__": 135,
    "kind": "method",
    "name": "getStatusChanges",
    "memberof": "src/index.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~PhylorefWrapper#getStatusChanges",
    "access": "public",
    "description": null,
    "lineNumber": 1188,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 136,
    "kind": "method",
    "name": "setStatus",
    "memberof": "src/index.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~PhylorefWrapper#setStatus",
    "access": "public",
    "description": null,
    "lineNumber": 1222,
    "undocument": true,
    "params": [
      {
        "name": "status",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 137,
    "kind": "method",
    "name": "asJSONLD",
    "memberof": "src/index.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~PhylorefWrapper#asJSONLD",
    "access": "public",
    "description": null,
    "lineNumber": 1266,
    "undocument": true,
    "params": [
      {
        "name": "phylorefURI",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 138,
    "kind": "method",
    "name": "getOWLRestrictionForSpecifier",
    "memberof": "src/index.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~PhylorefWrapper.getOWLRestrictionForSpecifier",
    "access": "public",
    "description": null,
    "lineNumber": 1408,
    "undocument": true,
    "params": [
      {
        "name": "specifier",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"@type\": string, \"onProperty\": string, \"hasValue\": *}"
      ]
    }
  },
  {
    "__docId__": 139,
    "kind": "method",
    "name": "wrapInternalOWLRestriction",
    "memberof": "src/index.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~PhylorefWrapper.wrapInternalOWLRestriction",
    "access": "public",
    "description": null,
    "lineNumber": 1419,
    "undocument": true,
    "params": [
      {
        "name": "restriction",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"@type\": string, \"unionOf\": *}"
      ]
    }
  },
  {
    "__docId__": 140,
    "kind": "method",
    "name": "wrapExternalOWLRestriction",
    "memberof": "src/index.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~PhylorefWrapper.wrapExternalOWLRestriction",
    "access": "public",
    "description": null,
    "lineNumber": 1436,
    "undocument": true,
    "params": [
      {
        "name": "restriction",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"@type\": string, \"onProperty\": *, \"someValuesFrom\": *}"
      ]
    }
  },
  {
    "__docId__": 141,
    "kind": "method",
    "name": "getClassExpressionForMRCA",
    "memberof": "src/index.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~PhylorefWrapper.getClassExpressionForMRCA",
    "access": "public",
    "description": null,
    "lineNumber": 1450,
    "undocument": true,
    "params": [
      {
        "name": "baseURI",
        "types": [
          "*"
        ]
      },
      {
        "name": "additionalClasses",
        "types": [
          "*"
        ]
      },
      {
        "name": "specifier1",
        "types": [
          "*"
        ]
      },
      {
        "name": "specifier2",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"@id\": *}"
      ]
    }
  },
  {
    "__docId__": 142,
    "kind": "class",
    "name": "PHYXWrapper",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~PHYXWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx",
    "importStyle": null,
    "description": null,
    "lineNumber": 1547,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 143,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/index.js~PHYXWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~PHYXWrapper#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 1550,
    "undocument": true
  },
  {
    "__docId__": 144,
    "kind": "member",
    "name": "phyx",
    "memberof": "src/index.js~PHYXWrapper",
    "static": false,
    "longname": "src/index.js~PHYXWrapper#phyx",
    "access": "public",
    "description": null,
    "lineNumber": 1559,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 145,
    "kind": "member",
    "name": "newickParser",
    "memberof": "src/index.js~PHYXWrapper",
    "static": false,
    "longname": "src/index.js~PHYXWrapper#newickParser",
    "access": "public",
    "description": null,
    "lineNumber": 1560,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 146,
    "kind": "get",
    "name": "BASE_URI",
    "memberof": "src/index.js~PHYXWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~PHYXWrapper.BASE_URI",
    "access": "public",
    "description": null,
    "lineNumber": 1563,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 147,
    "kind": "method",
    "name": "getBaseURIForPhyloref",
    "memberof": "src/index.js~PHYXWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~PHYXWrapper.getBaseURIForPhyloref",
    "access": "public",
    "description": null,
    "lineNumber": 1568,
    "undocument": true,
    "params": [
      {
        "name": "phylorefCount",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 148,
    "kind": "method",
    "name": "getBaseURIForPhylogeny",
    "memberof": "src/index.js~PHYXWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~PHYXWrapper.getBaseURIForPhylogeny",
    "access": "public",
    "description": null,
    "lineNumber": 1573,
    "undocument": true,
    "params": [
      {
        "name": "phylogenyCount",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 149,
    "kind": "method",
    "name": "getBaseURIForTUMatch",
    "memberof": "src/index.js~PHYXWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~PHYXWrapper.getBaseURIForTUMatch",
    "access": "public",
    "description": null,
    "lineNumber": 1578,
    "undocument": true,
    "params": [
      {
        "name": "countTaxonomicUnitMatches",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 150,
    "kind": "method",
    "name": "asJSONLD",
    "memberof": "src/index.js~PHYXWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~PHYXWrapper#asJSONLD",
    "access": "public",
    "description": null,
    "lineNumber": 1583,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "kind": "index",
    "content": "# phyx.js\n\nThe Phyloreference Exchange (PHYX) format is a JSON representation that can be\nused to store and transfer definitions of [phyloreferences]. This library provides\nclasses to help interpret some parts of these files, and for transforming an\nentire Phyx file into a [JSON-LD] representation that can be reasoned over with\nan [OWL 2 DL] reasoner. See the [Phyloreference Curation Tool] or the [Clade Ontology]\nfor examples of its usage.\n\n## Funding\nFunded by the US National Science Foundation through collaborative grants [DBI-1458484]\nand [DBI-1458604]. See [Funding] for details.\n\n  [phyloreferences]: http://phyloref.org\n  [JSON-LD]: https://en.wikipedia.org/wiki/JSON-LD\n  [OWL 2 DL]: https://www.w3.org/TR/owl2-overview/\n  [Phyloreference Curation Tool]: https://github.com/phyloref/curation-tool\n  [Clade Ontology]: https://github.com/phyloref/clade-ontology\n  [DBI-1458484]: http://www.nsf.gov/awardsearch/showAward?AWD_ID=1458484\n  [DBI-1458604]: http://www.nsf.gov/awardsearch/showAward?AWD_ID=1458604\n  [Funding]: http://www.phyloref.org/about/#funding\n",
    "longname": "/home/vaidyagi/code/phyloref/phyx.js/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"@phyloref/phyx\",\n  \"version\": \"0.2.0\",\n  \"description\": \"Phyloreference Exchange (PHYX) library in JavaScript\",\n  \"main\": \"src/index.js\",\n  \"scripts\": {\n    \"lint\": \"eslint src/index.js \\\"test/**\\\" --ext .js\",\n    \"pretest\": \"npm run lint; npm run docs\",\n    \"test\": \"mocha\",\n    \"docs\": \"esdoc\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/phyloref/phyx.js.git\"\n  },\n  \"keywords\": [\n    \"phylogenetics\",\n    \"phylogeny\",\n    \"phylogenetic definitions\",\n    \"clade definitions\"\n  ],\n  \"author\": \"Gaurav Vaidya <gaurav@ggvaidya.com>\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/phyloref/phyx.js/issues\"\n  },\n  \"homepage\": \"https://github.com/phyloref/phyx.js#readme\",\n  \"dependencies\": {\n    \"extend\": \"^3.0.2\",\n    \"moment\": \"^2.23.0\",\n    \"newick-js\": \"^1.1.0\"\n  },\n  \"devDependencies\": {\n    \"chai\": \"^4.2.0\",\n    \"esdoc\": \"^1.1.0\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"eslint\": \"^5.12.0\",\n    \"eslint-config-airbnb-base\": \"^13.1.0\",\n    \"eslint-plugin-import\": \"^2.14.0\",\n    \"eslint-plugin-mocha\": \"^5.2.1\",\n    \"mocha\": \"^5.2.0\"\n  },\n  \"esdoc\": {\n    \"source\": \"./src\",\n    \"destination\": \"./docs\",\n    \"plugins\": [\n      {\n        \"name\": \"esdoc-standard-plugin\"\n      }\n    ]\n  }\n}\n",
    "longname": "/home/vaidyagi/code/phyloref/phyx.js/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]