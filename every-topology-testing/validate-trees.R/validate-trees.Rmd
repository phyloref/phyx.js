---
title: "R Notebook"
output: html_notebook
---

# Validating the generated trees

To ensure that the generated trees are being generated correctly, we run three
levels of verification:

1. We check whether any of the trees generated within a run are duplicates.
2. We generate all the trees using `phytools`, and ensure that the trees we
   generated are identical to those generated by `phytools`.
   
## Setup

To setup, we need to install and load the `phytools` library.

```{r}
# install.packages('phytools');
require('phytools');

# install.packages('purrr')
require('purrr')
```

## Functions

We need a function to identify the differences between two lists of phylogenies.

```{r}
subtractPhylogenies <- function (mp1, mp2) {
  print(paste("mp1 has length", length(mp1)));
  print(paste("mp2 has length", length(mp2)));
  
  # Simplest possible algorithm: remove all sequences from mp1 that are present somewhere in mp2.
  # Would be nice if we had a way of hashing mp2, but I don't know of one right now.
  # return(mp1 %>% discard (function (phylogeny1) {
  results = c()
  for (phylogeny1 in mp1) {
    for (phylogeny2 in mp2) {
      print(paste("Comparing", phylogeny1, "with", phylogeny2));
      if (!all.equal.phylo(phylogeny1, phylogeny2)) {
        print(paste(" - Found discrepency:", phylogeny1, "is not equal to", phylogeny2));
      }
    }
  }
  # }))
}
```

```{r}
checkForDuplicates <- function(filename) {
  multiPhylo <- read.nexus(filename, force.multi = TRUE)
  actualLength <- length(multiPhylo)
  if (actualLength == 0) {
    print(paste(filename, "- No comparison possible: zero phylogenies found."))
  } else {
    uniquePhylos <- unique.multiPhylo(multiPhylo)
    uniqueLengths <- length(uniquePhylos)
    
    if (actualLength == uniqueLengths) {
      print(paste(filename, ': no duplicates found.'))
    } else {
      print(paste(filename, ': found duplicates - file contains', actualLength, 'phylogenies but only', uniqueLengths, 'unique phylogenies'))
    }
  }
}
```

```{r}
compareToExpected <- function(count, filename) {
  # Generate a multiPhylo of all possible trees for n=count
  expectedTrees <- allFurcTrees(tip.label=LETTERS[1:count])
  multiPhylo <- read.nexus(filename, force.multi = TRUE)
  
  print(paste('expectedTrees =', length(expectedTrees)))
  print(paste('multiPhylo =', length(multiPhylo)))

  expectedNotFound <- subtractPhylogenies(expectedTrees, multiPhylo)
  foundNotExpected <- subtractPhylogenies(multiPhylo, expectedTrees)
  
  if (length(expectedNotFound) == 0 && length(foundNotExpected) == 0) {
    print(paste(filename, '- no discrepency between expected and obtained phylogenies.'))
  }
  if (length(expectedNotFound) > 0) {
    print(paste(filename, '- found', length(expectedNotFound), 'phylogenies that were expected but not found:'))
    for(phylo in expectedNotFound) {
      write.tree(phylo)
    }
  }
  if (length(foundNotExpected) > 0) {
    print(paste(filename, '- found', length(foundNotExpected), 'phylogenies that were found but not expected:'))
    for(phylo in foundNotExpected) {
      write.tree(phylo)
    }
  }
}
```

## Testing

We now run our tests over all the NEXUS files in all the phylogenies.

```{r}
for(count in 3:6) {
  nexusFile <- file.path("..", paste("n", count, sep=""), "trees.nex")
  print(nexusFile)
  checkForDuplicates(nexusFile)
  compareToExpected(count, nexusFile)
}
```

Let's try generating multifurcating trees like this:
```{r}
tree <- read.tree(text="(A:1, B:1);")
trees <- c(tree)
for(n in 3:5) {
  trees <- do.call(c, lapply(1:100, function(x) lapply(trees, function(tree) add.random(tree, n=1, tips = LETTERS[n]))))
}
uniqueTrees <- unique.multiPhylo(trees)
print(length(uniqueTrees))
for(phy in uniqueTrees) {
  write.tree(phy)
}
```

