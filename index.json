[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/matchers/TaxonomicUnitMatcher.js",
    "content": "const { TaxonomicUnitWrapper } = require('../wrappers/TaxonomicUnitWrapper');\nconst { TaxonConceptWrapper } = require('../wrappers/TaxonConceptWrapper');\nconst { SpecimenWrapper } = require('../wrappers/SpecimenWrapper');\n\n/**\n * The TaxonomicUnitMatcher matches pairs of taxonomic units and provides\n * a consistent report on:\n *  - Which taxonomic units have matched, and\n *  - Why the match occurred.\n *\n * In Model 2.0, we start by using direct matching in OWL, so this should no longer\n * be needed. However, I'll leave this around to provide matching in the\n * Curation Tool UI and in case it's needed again later.\n */\nclass TaxonomicUnitMatcher {\n  /**\n   * Create a Taxonomic Unit Matcher to match two taxonomic units. Matching\n   * will occur immediately, so when this method returns, you can check\n   * tuMatch.matched and tuMatch.matchReason to determine if the two TUs matched\n   * and why.\n   */\n  constructor(tunit1, tunit2) {\n    this.tunit1 = tunit1;\n    this.tunit2 = tunit2;\n\n    // Set up places to store the match results.\n    this.matched = undefined; // Boolean variable for storing whether these TUnits matched.\n    this.matchReason = undefined; // The reason provided for this match.\n\n    // Execute the match.\n    this.match();\n  }\n\n  /** Return this TUMatch as a JSON object for insertion into the PHYX file. */\n  asJSONLD(idIRI) {\n    if (!this.matched) return undefined;\n\n    return {\n      '@id': idIRI,\n      '@type': 'testcase:TUMatch',\n      reason: this.matchReason,\n      matchesTaxonomicUnits: [\n        { '@id': this.tunit1['@id'] },\n        { '@id': this.tunit2['@id'] },\n      ],\n    };\n  }\n\n  /** Try to match the two taxonomic units using a number of matching methods. */\n  match() {\n    if (\n      this.matchByNameComplete()\n      || this.matchByExternalReferences()\n      || this.matchByOccurrenceID()\n    ) {\n      this.matched = true;\n    } else {\n      this.matched = false;\n      this.matchReason = undefined;\n    }\n  }\n\n  /** Try to match by nameComplete, and return true if it could be matched. */\n  matchByNameComplete() {\n    // Note that this doesn't apply just to taxon concepts -- we try to match\n    // any taxonomic units that have nameComplete, which might be taxon concepts\n    // OR specimens with taxonomic units.\n    const wrappedTName1 = new TaxonConceptWrapper(this.tunit1);\n    const wrappedTName2 = new TaxonConceptWrapper(this.tunit2);\n\n    if (\n      wrappedTName1.nameComplete && wrappedTName2.nameComplete\n      && wrappedTName1.nameComplete === wrappedTName2.nameComplete\n    ) {\n      this.matchReason = `Taxon name '${wrappedTName1.label}' and taxon name '${wrappedTName2.label}' share the same complete name`;\n      return true;\n    }\n\n    return false;\n  }\n\n  /** Match by external references. */\n  matchByExternalReferences() {\n    const wrappedTUnit1 = new TaxonomicUnitWrapper(this.tunit1);\n    const wrappedTUnit2 = new TaxonomicUnitWrapper(this.tunit2);\n\n    const externalRefs1 = wrappedTUnit1.externalReferences;\n    const externalRefs2 = wrappedTUnit2.externalReferences;\n\n    return externalRefs1.some(\n      extref1 => externalRefs2.some(\n        (extref2) => {\n          if (\n            extref1\n            && extref2\n            && (extref1.toLowerCase() === extref2.toLowerCase())\n          ) {\n            this.matchReason = `External reference '${extref1}' is shared by taxonomic unit ${this.tunit1} and ${this.tunit2}`;\n            return true;\n          }\n\n          return false;\n        }\n      )\n    );\n  }\n\n  /** Match by occurrence ID */\n  matchByOccurrenceID() {\n    // Are both TUs specimens?\n    const wrappedTUnit1 = new TaxonomicUnitWrapper(this.tunit1);\n    const wrappedTUnit2 = new TaxonomicUnitWrapper(this.tunit2);\n\n    if (!wrappedTUnit1.types.includes(TaxonomicUnitWrapper.TYPE_SPECIMEN)) return false;\n    if (!wrappedTUnit2.types.includes(TaxonomicUnitWrapper.TYPE_SPECIMEN)) return false;\n\n    // Occurrence IDs from both taxonomic units.\n    const wrappedSpecimen1 = new SpecimenWrapper(this.tunit1);\n    const wrappedSpecimen2 = new SpecimenWrapper(this.tunit2);\n\n    if (\n      wrappedSpecimen1.occurrenceID && wrappedSpecimen2.occurrenceID\n      && wrappedSpecimen1.occurrenceID === wrappedSpecimen2.occurrenceID\n    ) {\n      this.matchReason = `Specimen identifier '${wrappedSpecimen1.occurrenceID}' is shared by taxonomic units`;\n\n      return true;\n    }\n\n    return false;\n  }\n}\n\nmodule.exports = {\n  TaxonomicUnitMatcher,\n};\n",
    "static": true,
    "longname": "/home/runner/work/phyx.js/phyx.js/src/matchers/TaxonomicUnitMatcher.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "variable",
    "name": "TaxonomicUnitWrapper",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js",
    "static": true,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/matchers/TaxonomicUnitMatcher.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 50,
    "kind": "variable",
    "name": "TaxonConceptWrapper",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js",
    "static": true,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonConceptWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/matchers/TaxonomicUnitMatcher.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 51,
    "kind": "variable",
    "name": "SpecimenWrapper",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js",
    "static": true,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~SpecimenWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/matchers/TaxonomicUnitMatcher.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 52,
    "kind": "class",
    "name": "TaxonomicUnitMatcher",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js",
    "static": true,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher",
    "access": "public",
    "export": true,
    "importPath": "@phyloref/phyx/src/matchers/TaxonomicUnitMatcher.js",
    "importStyle": "{TaxonomicUnitMatcher}",
    "description": "The TaxonomicUnitMatcher matches pairs of taxonomic units and provides\na consistent report on:\n - Which taxonomic units have matched, and\n - Why the match occurred.\n\nIn Model 2.0, we start by using direct matching in OWL, so this should no longer\nbe needed. However, I'll leave this around to provide matching in the\nCuration Tool UI and in case it's needed again later.",
    "lineNumber": 18,
    "interface": false
  },
  {
    "__docId__": 53,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher#constructor",
    "access": "public",
    "description": "Create a Taxonomic Unit Matcher to match two taxonomic units. Matching\nwill occur immediately, so when this method returns, you can check\ntuMatch.matched and tuMatch.matchReason to determine if the two TUs matched\nand why.",
    "lineNumber": 25
  },
  {
    "__docId__": 54,
    "kind": "member",
    "name": "tunit1",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher",
    "static": false,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher#tunit1",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "member",
    "name": "tunit2",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher",
    "static": false,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher#tunit2",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 56,
    "kind": "member",
    "name": "matched",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher",
    "static": false,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher#matched",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 57,
    "kind": "member",
    "name": "matchReason",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher",
    "static": false,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher#matchReason",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 58,
    "kind": "method",
    "name": "asJSONLD",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher#asJSONLD",
    "access": "public",
    "description": "Return this TUMatch as a JSON object for insertion into the PHYX file.",
    "lineNumber": 38,
    "params": [
      {
        "name": "idIRI",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"@id\": *, \"@type\": string, \"reason\": *, \"matchesTaxonomicUnits\": *}"
      ]
    }
  },
  {
    "__docId__": 59,
    "kind": "method",
    "name": "match",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher#match",
    "access": "public",
    "description": "Try to match the two taxonomic units using a number of matching methods.",
    "lineNumber": 53,
    "params": [],
    "return": null
  },
  {
    "__docId__": 63,
    "kind": "method",
    "name": "matchByNameComplete",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher#matchByNameComplete",
    "access": "public",
    "description": "Try to match by nameComplete, and return true if it could be matched.",
    "lineNumber": 67,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 65,
    "kind": "method",
    "name": "matchByExternalReferences",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher#matchByExternalReferences",
    "access": "public",
    "description": "Match by external references.",
    "lineNumber": 86,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 67,
    "kind": "method",
    "name": "matchByOccurrenceID",
    "memberof": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/matchers/TaxonomicUnitMatcher.js~TaxonomicUnitMatcher#matchByOccurrenceID",
    "access": "public",
    "description": "Match by occurrence ID",
    "lineNumber": 112,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 69,
    "kind": "file",
    "name": "src/wrappers/CitationWrapper.js",
    "content": "/**\n * The CitationWrapper wraps a single citation in the Phyx document.\n * Based on BibJSON (http://okfnlabs.org/bibjson/).\n */\n\nconst { has, isEmpty } = require('lodash');\n\nclass CitationWrapper {\n  /**\n   * Construct a CitationWrapper.\n   */\n  constructor(citation) {\n    this.citation = citation;\n  }\n\n  /** Returns a single string with the entire bibliographic citation. */\n  toString() {\n    if (!this.citation || isEmpty(this.citation)) return undefined;\n\n    // If we already have a bibliographic citation, we can just return that.\n    if (has(this.citation, 'bibliographicCitation')) return this.citation.bibliographicCitation;\n\n    let authors = (this.citation.authors || []).map(author => author.name);\n    if (authors.length === 0) authors = ['Anonymous'];\n    if (authors.length > 2) authors = [`${authors[0]} et al`];\n    let authorsAndTitle = `${authors.join(' and ')} (${this.citation.year || 'n.d.'}) ${this.citation.title || 'Untitled'}`;\n\n    const editorLists = [];\n    const editors = (this.citation.editors || []).map(editor => editor.name);\n    if (editors.length > 0) editorLists.push(`eds: ${editors.join(' and ')}`);\n\n    const seriesEditors = (this.citation.series_editors || []).map(editor => editor.name);\n    if (seriesEditors.length > 0) editorLists.push(`series eds: ${seriesEditors.join(' and ')}`);\n\n    if (editorLists.length > 0) authorsAndTitle += ` [${editorLists.join(', ')}]`;\n\n    if (has(this.citation, 'section_title')) {\n      authorsAndTitle += ` (section: ${this.citation.section_title})`;\n    }\n\n    // Additional info stores details that should be at the end of the figure number,\n    // DOIs, URLs, ISBNs and so on.\n    let additionalInfo = ' ';\n    if (has(this.citation, 'figure')) additionalInfo += ` fig ${this.citation.figure}`;\n\n    // Add DOIs and URLs.\n    additionalInfo += (this.citation.identifier || [])\n      .filter(id => id.type === 'doi')\n      .map(doi => ` doi: ${doi.id}`)\n      .join('');\n    additionalInfo += (this.citation.link || []).map(link => ` URL: ${link.url}`).join('');\n\n    additionalInfo += (this.citation.identifier || [])\n      .filter(id => id.type === 'isbn')\n      .map(isbn => ` ISBN: ${isbn.id}`)\n      .join('');\n\n    // A citation for a journal article should be different from others.\n    if (has(this.citation, 'journal') && this.citation.type === 'article') {\n      const journal = this.citation.journal;\n      const journalIssue = (has(journal, 'number')) ? `(${journal.number})` : '';\n      const pages = (has(this.citation, 'pages')) ? `:${this.citation.pages}` : '';\n      additionalInfo += (journal.identifier || [])\n        .filter(id => id.type === 'issn')\n        .map(issn => `ISSN: ${issn.id} `)\n        .join('');\n      return `${authorsAndTitle} ${journal.name || 'Unknown journal'} ${journal.volume || 'Unknown volume'}${journalIssue}${pages}${additionalInfo}`;\n    }\n\n    // If we are here, this must be a book or a book_section.\n    if (has(this.citation, 'pages')) additionalInfo += ` pages: ${this.citation.pages}`;\n\n    if (has(this.citation, 'publisher') && has(this.citation, 'city')) {\n      return `${authorsAndTitle} ${this.citation.publisher}, ${this.citation.city}${additionalInfo}`;\n    }\n\n    if (has(this.citation, 'publisher')) {\n      return `${authorsAndTitle} ${this.citation.publisher}${additionalInfo}`;\n    }\n\n    return `${authorsAndTitle}${additionalInfo}`.trim();\n  }\n}\n\nmodule.exports = {\n  CitationWrapper,\n};\n",
    "static": true,
    "longname": "/home/runner/work/phyx.js/phyx.js/src/wrappers/CitationWrapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 70,
    "kind": "variable",
    "name": "has",
    "memberof": "src/wrappers/CitationWrapper.js",
    "static": true,
    "longname": "src/wrappers/CitationWrapper.js~has",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/CitationWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 71,
    "kind": "class",
    "name": "CitationWrapper",
    "memberof": "src/wrappers/CitationWrapper.js",
    "static": true,
    "longname": "src/wrappers/CitationWrapper.js~CitationWrapper",
    "access": "public",
    "export": true,
    "importPath": "@phyloref/phyx/src/wrappers/CitationWrapper.js",
    "importStyle": "{CitationWrapper}",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 72,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/wrappers/CitationWrapper.js~CitationWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/CitationWrapper.js~CitationWrapper#constructor",
    "access": "public",
    "description": "Construct a CitationWrapper.",
    "lineNumber": 13
  },
  {
    "__docId__": 73,
    "kind": "member",
    "name": "citation",
    "memberof": "src/wrappers/CitationWrapper.js~CitationWrapper",
    "static": false,
    "longname": "src/wrappers/CitationWrapper.js~CitationWrapper#citation",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "method",
    "name": "toString",
    "memberof": "src/wrappers/CitationWrapper.js~CitationWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/CitationWrapper.js~CitationWrapper#toString",
    "access": "public",
    "description": "Returns a single string with the entire bibliographic citation.",
    "lineNumber": 18,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 75,
    "kind": "file",
    "name": "src/wrappers/PhylogenyWrapper.js",
    "content": "/**\n * PhylogenyWrapper\n */\n\nconst { has } = require('lodash');\n\n/** Used to parse Newick strings. */\nconst parseNewick = require('newick-js').parse;\n\n/** OWL terms to be used here. */\nconst owlterms = require('../utils/owlterms');\n\nconst { TaxonomicUnitWrapper } = require('./TaxonomicUnitWrapper');\nconst { TaxonomicUnitMatcher } = require('../matchers/TaxonomicUnitMatcher');\nconst { CitationWrapper } = require('./CitationWrapper');\n\nclass PhylogenyWrapper {\n  // Wraps a Phylogeny in a PHYX file and provides access to node, node labels\n  // and other information. Remember that a Phylogeny also has the\n  // additionalNodeProperties object which provides additional properties for\n  // nodes.\n\n  constructor(phylogeny, defaultNomenCode = owlterms.UNKNOWN_CODE) {\n    // Construct a phylogeny based on a Phylogeny object in a PHYX phylogeny.\n    // Note that this version ONLY uses the `newick` property to determine the\n    // phylogeny: if other representations are included (such as a node-based\n    // format, as used in JSON-LD), they will be ignored and possibly overwritten\n    // during export. So, to update the phylogeny, please only update the newick\n    // string!\n    //\n    // This ensures that we don't need to reconcile between different\n    // possible representations of a phylogeny.\n    this.phylogeny = phylogeny;\n    this.defaultNomenCode = defaultNomenCode;\n  }\n\n  static getErrorsInNewickString(newick) {\n    // Given a Newick string, return a list of errors found in parsing this\n    // string. The errors are returned as a list of objects, each of which\n    // has two properties:\n    //  - title: A short title of the error, distinct for each type of error.\n    //  - message: A longer description of the error, which might include\n    //    information specific to a particular error.\n    //\n    // We try to order errors from most helpful ('Unbalanced parentheses in\n    // Newick string') to least helpful ('Error parsing phylogeny').\n    const newickTrimmed = newick.trim();\n    const errors = [];\n\n    // Look for an empty Newick string.\n    if (newickTrimmed === '' || newickTrimmed === '()' || newickTrimmed === '();') {\n      // None of the later errors are relevant here, so bail out now.\n      return [{\n        title: 'No phylogeny entered',\n        message: 'Click on \"Edit as Newick\" to enter a phylogeny below.',\n      }];\n    }\n\n    // Look for an unbalanced Newick string.\n    let parenLevels = 0;\n    for (let x = 0; x < newickTrimmed.length; x += 1) {\n      if (newickTrimmed[x] === '(') parenLevels += 1;\n      if (newickTrimmed[x] === ')') parenLevels -= 1;\n    }\n\n    if (parenLevels !== 0) {\n      errors.push({\n        title: 'Unbalanced parentheses in Newick string',\n        message: (parenLevels > 0\n          ? `You have ${parenLevels} too many open parentheses`\n          : `You have ${-parenLevels} too few open parentheses`\n        ),\n      });\n    }\n\n    // Finally, try parsing it with parseNewick and see if we get an error.\n    try {\n      parseNewick(newickTrimmed);\n    } catch (ex) {\n      errors.push({\n        title: 'Error parsing phylogeny',\n        message: `An error occured while parsing this phylogeny: ${ex.message}`,\n      });\n    }\n\n    return errors;\n  }\n\n  static recurseNodes(node, func, nodeCount = 0, parentCount = undefined) {\n    // Recurse through PhyloTree nodes, executing function on each node.\n    //  - node: The node to recurse from. The function will be called on node\n    //          *before* being called on its children.\n    //  - func: The function to call on `node` and all of its children.\n    //  - nodeCount: `node` will be called with this nodeCount. All of its\n    //          children will be called with consecutively increasing nodeCounts.\n    //  - parentCount: The nodeCount associated with the parent of this node\n    //          within this run of recurseNodes. For instance, immediate children\n    //          of `node` will have a parentCount of 0. By default, `node` itself\n    //          will have a parentCount of `undefined`.\n    // When the function `func` is called, it is given three arguments:\n    //  - The current node object (initially: `node`)\n    //  - The count of the current node object (initially: `nodeCount`)\n    //  - The parent count of the current node object (initially: `parentCount`)\n    func(node, nodeCount, parentCount);\n\n    let nextID = nodeCount + 1;\n\n    // Recurse through all children of this node.\n    if (has(node, 'children')) {\n      node.children.forEach((child) => {\n        nextID = PhylogenyWrapper.recurseNodes(\n          child,\n          func,\n          nextID,\n          nodeCount\n        );\n      });\n    }\n\n    return nextID;\n  }\n\n  getTaxonomicUnits(nodeType = 'both') {\n    // Return a list of all taxonomic units in this phylogeny.\n    // Node labels will be extracted from:\n    //  - internal nodes only (if nodeType == 'internal')\n    //  - terminal nodes only (if nodeType == 'terminal')\n    //  - both internal and terminal nodes (if nodeType == 'both')\n    //\n    // See `getTaxonomicUnitsForNodeLabel` to see how node labels are converted\n    // into node labels, but in brief:\n    //  1. We look for taxonomic units in the additionalNodeProperties.\n    //  2. If none are found, we attempt to parse the node label as a scientific name.\n    //\n    const nodeLabels = this.getNodeLabels(nodeType);\n    const tunits = new Set();\n\n    nodeLabels.forEach(\n      nodeLabel => this.getTaxonomicUnitsForNodeLabel(nodeLabel)\n        .forEach(tunit => tunits.add(tunit))\n    );\n\n    return tunits;\n  }\n\n  getNodeLabels(nodeType = 'both') {\n    // Return a list of all the node labels in this phylogeny.\n    //\n    // nodeType can be one of:\n    // - 'internal': Return node labels on internal nodes.\n    // - 'terminal': Return node labels on terminal nodes.\n    // - 'both': Return node labels on both internal and terminal nodes.\n\n    // Parse the phylogeny (will throw an exception if parsing failed).\n    const { graph } = parseNewick(this.phylogeny.newick || '()');\n    const [vertices, arcs] = graph;\n\n    if (nodeType === 'both') {\n      // Return all node labels.\n      return Array.from(\n        new Set(\n          Array.from(vertices)\n            .map(vertex => vertex.label)\n            .filter(label => label !== undefined)\n        )\n      );\n    }\n\n    if (nodeType === 'internal') {\n      // Return the internal nodes (those with atleast one child).\n      return Array.from(new Set(\n        Array.from(arcs)\n          .map(arc => arc[0].label) // Retrieve the label of the parent vertex in this arc.\n          .filter(label => label !== undefined)\n      ));\n    }\n\n    if (nodeType === 'terminal') {\n      // Return the terminal nodes. This would require calculating the children\n      // of every vertex in the graph and then identifying vertices without any\n      // children.\n      //\n      // A quicker and dirtier way to do this is by removing internal labels\n      // from the list of all node labels. This will report an incorrect result\n      // if an internal node has the same label as a terminal node, but at that\n      // point a lot of other assumptions are going to fail, too, so this is\n      // probably good enough for now.\n      const allLabels = this.getNodeLabels('both');\n      const internalLabels = new Set(this.getNodeLabels('internal'));\n\n      return allLabels.filter(label => !internalLabels.has(label));\n    }\n\n    throw new Error(`Unknown nodeType: '${nodeType}'`);\n  }\n\n  /**\n   * Return a list of taxonomic units for a node label.\n   *\n   * If the additionalNodeProperties for this node label includes taxonomic units\n   * (using `representsTaxonomicUnits` = obo:CDAO_0000187), then those taxonomic\n   * units are used. Otherwise, one will be constructed using the default\n   * nomenclatural code set up when this PhylogenyWrapper was set up.\n   */\n  getTaxonomicUnitsForNodeLabel(nodeLabel) {\n    // Look up additional node properties.\n    let additionalNodeProperties = {};\n    if (\n      has(this.phylogeny, 'additionalNodeProperties')\n      && has(this.phylogeny.additionalNodeProperties, nodeLabel)\n    ) {\n      additionalNodeProperties = this.phylogeny.additionalNodeProperties[nodeLabel];\n    }\n\n    // If there are explicit taxonomic units in the\n    // representsTaxonomicUnits property, we need to use those.\n    if (has(additionalNodeProperties, 'representsTaxonomicUnits')) {\n      return additionalNodeProperties.representsTaxonomicUnits;\n    }\n\n    // If that doesn't work, we can try to extract scientific names from\n    // the node label. Note that taxonomic units will NOT be extracted from\n    // the label if there is a taxonomic unit present!\n    //\n    // Note that old-style taxonomic units were lists while new-style taxonomic\n    // units are single objects. So we turn it into a single entry list here.\n    const tunit = TaxonomicUnitWrapper.fromLabel(nodeLabel.trim(), this.defaultNomenCode);\n    if (tunit) return [tunit];\n    return []; // No TUnit? Return the empty list.\n  }\n\n  getNodeLabelsMatchedBySpecifier(specifier) {\n    // Return a list of node labels matched by a given specifier on\n    // a given phylogeny.\n\n    return this.getNodeLabels().filter((nodeLabel) => {\n      // Find all the taxonomic units associated with the specifier and\n      // with the node.\n      const nodeTUnits = this.getTaxonomicUnitsForNodeLabel(nodeLabel);\n\n      // Attempt pairwise matches between taxonomic units in the specifier\n      // and associated with the node.\n      return nodeTUnits.some(\n        tunit => new TaxonomicUnitMatcher(specifier, tunit).matched\n      );\n    });\n  }\n\n  static getParsedNewick(newick) {\n    // We previously used phylotree.js's Newick parser to parse Newick into a\n    // tree-like structure. However, this is difficult to integrate using NPM.\n    // This method provides a similar facility using the newick-js library.\n    //\n    // Throws an exception if the Newick could not be parsed.\n    const { graph, root, rootWeight } = parseNewick(newick);\n    const [, arcs] = graph;\n\n    // Go through the arcs, assigning 'children' to the appropriate parent node.\n    arcs.forEach((arc) => {\n      const [parent, child, weight] = arc;\n\n      // Add child to parent.children.\n      if (!has(parent, 'children')) parent.children = [];\n      parent.children.push(child);\n\n      // Phylotree.js uses 'name' instead of 'label'.\n      if (has(parent, 'label')) { parent.name = parent.label; }\n      if (has(child, 'label')) { child.name = child.label; }\n\n      // Phylotree.js uses 'attribute' to store weights, so we'll store it there as well.\n      if (!has(child, 'attribute') && !Number.isNaN(weight)) child.attribute = weight;\n    });\n\n    // Set root 'attribute' to root weight.\n    if (!has(root, 'attribute') && !Number.isNaN(rootWeight)) root.attribute = rootWeight;\n\n    return { json: root };\n  }\n\n  getParsedNewickWithIRIs(baseIRI, newickParser = PhylogenyWrapper.getParsedNewick) {\n    // Return the parsed Newick string, but with EVERY node given an IRI.\n    // - baseIRI: The base IRI to use for node elements (e.g. ':phylogeny1').\n    //   Node IDs are generated by concatenating `_node${number}` to the end of\n    //   the baseIRI.\n    // - newickParser: A method for converting a Newick string to a object-based\n    //   representation. The static method PhylogenyWrapper.getParsedNewick() is\n    //   used if none is provided.\n\n    const parsed = newickParser(this.phylogeny.newick || '()');\n    if (has(parsed, 'json')) {\n      PhylogenyWrapper.recurseNodes(parsed.json, (node, nodeCount) => {\n        // Start with the additional node properties.\n        const nodeAsJSONLD = node;\n\n        // Set @id and @type.\n        const nodeIRI = `${baseIRI}_node${nodeCount}`;\n        nodeAsJSONLD['@id'] = nodeIRI;\n      });\n    }\n\n    return parsed;\n  }\n\n  getNodesAsJSONLD(baseIRI, newickParser) {\n    // Returns a list of all nodes in this phylogeny as a series of nodes.\n    // - baseIRI: The base IRI to use for node elements (e.g. ':phylogeny1').\n    //   Node IDs are generated by concatenating `_node${number}` to the end of\n    //   the baseIRI.\n    // - newickParser: A method for converting a Newick string to a object-based\n    //   representation. See PhylogenyWrapper.getParsedNewick() for an example\n    //   implementation.\n\n    // List of nodes we have identified.\n    const nodes = [];\n\n    // We need to track the identifiers we give each node as we go.\n    const nodesById = {};\n    const nodeIdsByParentId = {};\n\n    // Extract the newick string.\n    const { additionalNodeProperties } = this.phylogeny;\n\n    // Parse the Newick string; if parseable, recurse through the nodes,\n    // added them to the list of JSON-LD nodes as we go.\n\n    const parsed = this.getParsedNewickWithIRIs(baseIRI, newickParser);\n    if (has(parsed, 'json')) {\n      PhylogenyWrapper.recurseNodes(parsed.json, (node, nodeCount, parentCount) => {\n        // Start with the additional node properties.\n        const nodeAsJSONLD = {};\n\n        // Set @id and @type. '@id' should already be set by getParsedNewickWithIRIs()!\n        const nodeIRI = node['@id'];\n        nodeAsJSONLD['@id'] = nodeIRI;\n\n        // Since we may need to add multiple classes into the rdf:type, we need\n        // to make @type an array. However, the JSON-LD library we use in JPhyloRef\n        // can't support @type being an array (despite that being in the standard,\n        // see https://w3c.github.io/json-ld-syntax/#example-14-specifying-multiple-types-for-a-node),\n        // so we fall back to using rdf:type instead.\n        nodeAsJSONLD[owlterms.RDF_TYPE] = [{ '@id': owlterms.CDAO_NODE }];\n\n        // Add labels, additional node properties and taxonomic units.\n        if (has(node, 'name') && node.name !== '') {\n          // Add node label.\n          nodeAsJSONLD.labels = [node.name];\n\n          // Add additional node properties, if any.\n          if (additionalNodeProperties && has(additionalNodeProperties, node.name)) {\n            Object.keys(additionalNodeProperties[node.name]).forEach((key) => {\n              nodeAsJSONLD[key] = additionalNodeProperties[node.name][key];\n            });\n          }\n\n          // Add taxonomic units into the metadata.\n          nodeAsJSONLD.representsTaxonomicUnits = this.getTaxonomicUnitsForNodeLabel(node.name);\n\n          // Add it into the @type so we can reason over it.\n          nodeAsJSONLD.representsTaxonomicUnits.forEach((tu) => {\n            const wrappedTUnit = new TaxonomicUnitWrapper(tu);\n\n            if (wrappedTUnit) {\n              const equivClass = wrappedTUnit.asOWLEquivClass;\n              if (equivClass) {\n                nodeAsJSONLD[owlterms.RDF_TYPE].push(\n                  {\n                    '@type': 'owl:Restriction',\n                    onProperty: owlterms.CDAO_REPRESENTS_TU,\n                    someValuesFrom: equivClass,\n                  }\n                );\n              }\n            }\n          });\n        }\n\n        // Add references to parents and siblings.\n        if (parentCount !== undefined) {\n          const parentIRI = `${baseIRI}_node${parentCount}`;\n          nodeAsJSONLD.parent = parentIRI;\n\n          // Update list of nodes by parent IDs.\n          if (!has(nodeIdsByParentId, parentIRI)) {\n            nodeIdsByParentId[parentIRI] = new Set();\n          }\n          nodeIdsByParentId[parentIRI].add(nodeIRI);\n        }\n\n        // Add nodeAsJSONLD to list\n        if (has(nodesById, nodeIRI)) {\n          throw new Error(`Error in programming: duplicate node IRI generated (${nodeIRI})`);\n        }\n        nodesById[nodeIRI] = nodeAsJSONLD;\n        nodes.push(nodeAsJSONLD);\n      });\n    }\n\n    // Go through nodes again and set children and sibling relationships.\n    Object.keys(nodeIdsByParentId).forEach((parentId) => {\n      // What are the children of this parentId?\n      const childrenIDs = Array.from(nodeIdsByParentId[parentId]);\n      const children = childrenIDs.map(childId => nodesById[childId]);\n\n      // Is this the root node?\n      if (has(nodesById, parentId)) {\n        const parent = nodesById[parentId];\n        parent.children = childrenIDs;\n      }\n\n      children.forEach((child) => {\n        const childToModify = child;\n        // Add all other sibling to node.siblings, but don't add this node itself!\n        childToModify.siblings = childrenIDs.filter(childId => childId !== child['@id']);\n      });\n    });\n\n    return nodes;\n  }\n\n  asJSONLD(fallbackIRI, newickParser) {\n    // Export this phylogeny as JSON-LD.\n    // - fallbackIRI: The fallback IRI to use for this phylogeny if it does not\n    //   already have an '@id' set.\n    // - newickParser: A function that parses a Newick string and returns a\n    //   an object based representation of this phylogeny. If not set, the\n    //   static method PhylogenyWrapper.getParsedNewick will be used instead.\n\n    // Create a copy to export.\n    const phylogenyAsJSONLD = JSON.parse(JSON.stringify(this.phylogeny));\n\n    // Set name and class for phylogeny. If no '@id' is set, use the provided\n    // fallbackIRI.\n    if (!has(phylogenyAsJSONLD, '@id')) phylogenyAsJSONLD['@id'] = fallbackIRI;\n    phylogenyAsJSONLD['@type'] = owlterms.PHYLOREFERENCE_PHYLOGENY;\n\n    // Translate nodes into JSON-LD objects.\n    phylogenyAsJSONLD.nodes = this.getNodesAsJSONLD(phylogenyAsJSONLD['@id'], newickParser);\n    if (phylogenyAsJSONLD.nodes.length > 0) {\n      // We don't have a better way to identify the root node, so we just\n      // default to the first one.\n      phylogenyAsJSONLD.hasRootNode = {\n        '@id': phylogenyAsJSONLD.nodes[0]['@id'],\n      };\n    }\n\n    // Add a bibliographicCitation to the source if it is a Citation.\n    if (has(phylogenyAsJSONLD, 'source')) {\n      const source = phylogenyAsJSONLD.source;\n\n      if (!has(source, 'bibliographicCitation')) {\n        source.bibliographicCitation = new CitationWrapper(source).toString();\n      }\n    }\n\n    return phylogenyAsJSONLD;\n  }\n}\n\nmodule.exports = {\n  PhylogenyWrapper,\n};\n",
    "static": true,
    "longname": "/home/runner/work/phyx.js/phyx.js/src/wrappers/PhylogenyWrapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 76,
    "kind": "variable",
    "name": "has",
    "memberof": "src/wrappers/PhylogenyWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhylogenyWrapper.js~has",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhylogenyWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 77,
    "kind": "variable",
    "name": "TaxonomicUnitWrapper",
    "memberof": "src/wrappers/PhylogenyWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhylogenyWrapper.js~TaxonomicUnitWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhylogenyWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 78,
    "kind": "variable",
    "name": "TaxonomicUnitMatcher",
    "memberof": "src/wrappers/PhylogenyWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhylogenyWrapper.js~TaxonomicUnitMatcher",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhylogenyWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 79,
    "kind": "variable",
    "name": "CitationWrapper",
    "memberof": "src/wrappers/PhylogenyWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhylogenyWrapper.js~CitationWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhylogenyWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 80,
    "kind": "class",
    "name": "PhylogenyWrapper",
    "memberof": "src/wrappers/PhylogenyWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "access": "public",
    "export": true,
    "importPath": "@phyloref/phyx/src/wrappers/PhylogenyWrapper.js",
    "importStyle": "{PhylogenyWrapper}",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 81,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true
  },
  {
    "__docId__": 82,
    "kind": "member",
    "name": "phylogeny",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "static": false,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper#phylogeny",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 83,
    "kind": "member",
    "name": "defaultNomenCode",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "static": false,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper#defaultNomenCode",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 84,
    "kind": "method",
    "name": "getErrorsInNewickString",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper.getErrorsInNewickString",
    "access": "public",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "params": [
      {
        "name": "newick",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 85,
    "kind": "method",
    "name": "recurseNodes",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper.recurseNodes",
    "access": "public",
    "description": null,
    "lineNumber": 93,
    "undocument": true,
    "params": [
      {
        "name": "node",
        "types": [
          "*"
        ]
      },
      {
        "name": "func",
        "types": [
          "*"
        ]
      },
      {
        "name": "nodeCount",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      },
      {
        "name": "parentCount",
        "optional": true,
        "types": [
          "*"
        ],
        "defaultRaw": "undefined",
        "defaultValue": "undefined"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "method",
    "name": "getTaxonomicUnits",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper#getTaxonomicUnits",
    "access": "public",
    "description": null,
    "lineNumber": 127,
    "undocument": true,
    "params": [
      {
        "name": "nodeType",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "both",
        "defaultValue": "both"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 87,
    "kind": "method",
    "name": "getNodeLabels",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper#getNodeLabels",
    "access": "public",
    "description": null,
    "lineNumber": 150,
    "undocument": true,
    "params": [
      {
        "name": "nodeType",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "both",
        "defaultValue": "both"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "method",
    "name": "getTaxonomicUnitsForNodeLabel",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper#getTaxonomicUnitsForNodeLabel",
    "access": "public",
    "description": "Return a list of taxonomic units for a node label.\n\nIf the additionalNodeProperties for this node label includes taxonomic units\n(using `representsTaxonomicUnits` = obo:CDAO_0000187), then those taxonomic\nunits are used. Otherwise, one will be constructed using the default\nnomenclatural code set up when this PhylogenyWrapper was set up.",
    "lineNumber": 209,
    "params": [
      {
        "name": "nodeLabel",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 89,
    "kind": "method",
    "name": "getNodeLabelsMatchedBySpecifier",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper#getNodeLabelsMatchedBySpecifier",
    "access": "public",
    "description": null,
    "lineNumber": 236,
    "undocument": true,
    "params": [
      {
        "name": "specifier",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 90,
    "kind": "method",
    "name": "getParsedNewick",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper.getParsedNewick",
    "access": "public",
    "description": null,
    "lineNumber": 253,
    "undocument": true,
    "params": [
      {
        "name": "newick",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"json\": *}"
      ]
    }
  },
  {
    "__docId__": 91,
    "kind": "method",
    "name": "getParsedNewickWithIRIs",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper#getParsedNewickWithIRIs",
    "access": "public",
    "description": null,
    "lineNumber": 284,
    "undocument": true,
    "params": [
      {
        "name": "baseIRI",
        "types": [
          "*"
        ]
      },
      {
        "name": "newickParser",
        "optional": true,
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 92,
    "kind": "method",
    "name": "getNodesAsJSONLD",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper#getNodesAsJSONLD",
    "access": "public",
    "description": null,
    "lineNumber": 308,
    "undocument": true,
    "params": [
      {
        "name": "baseIRI",
        "types": [
          "*"
        ]
      },
      {
        "name": "newickParser",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 93,
    "kind": "method",
    "name": "asJSONLD",
    "memberof": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylogenyWrapper.js~PhylogenyWrapper#asJSONLD",
    "access": "public",
    "description": null,
    "lineNumber": 424,
    "undocument": true,
    "params": [
      {
        "name": "fallbackIRI",
        "types": [
          "*"
        ]
      },
      {
        "name": "newickParser",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 94,
    "kind": "file",
    "name": "src/wrappers/PhylorefWrapper.js",
    "content": "/** Used to parse timestamps for phyloref statuses. */\nconst moment = require('moment');\nconst { has, cloneDeep, uniq } = require('lodash');\n\nconst owlterms = require('../utils/owlterms');\nconst { TaxonomicUnitWrapper } = require('./TaxonomicUnitWrapper');\nconst { TaxonConceptWrapper } = require('./TaxonConceptWrapper');\nconst { PhylogenyWrapper } = require('./PhylogenyWrapper');\nconst { CitationWrapper } = require('./CitationWrapper');\n\n/**\n * PhylorefWrapper\n *\n */\n\nclass PhylorefWrapper {\n  // Wraps a phyloreference in a PHYX model.\n\n  constructor(phyloref, phyxDefaultNomenCode = owlterms.UNKNOWN_CODE) {\n    // Wraps the provided phyloreference\n    this.phyloref = phyloref;\n    this.phyxDefaultNomenCode = phyxDefaultNomenCode;\n  }\n\n  /** Return the internal specifiers of this phyloref (if any). */\n  get internalSpecifiers() {\n    if (!has(this.phyloref, 'internalSpecifiers')) {\n      this.phyloref.internalSpecifiers = [];\n    }\n\n    return this.phyloref.internalSpecifiers;\n  }\n\n  /** Return the external specifiers of this phyloref (if any). */\n  get externalSpecifiers() {\n    if (!has(this.phyloref, 'externalSpecifiers')) {\n      this.phyloref.externalSpecifiers = [];\n    }\n\n    return this.phyloref.externalSpecifiers;\n  }\n\n  get label() {\n    // Return a label for this phyloreference.\n    if (has(this.phyloref, 'label')) return this.phyloref.label;\n    if (has(this.phyloref, 'labels') && this.phyloref.labels.length > 0) return this.phyloref.labels[0];\n    if (has(this.phyloref, 'title')) return this.phyloref.title;\n\n    return undefined;\n  }\n\n  set label(newLabel) {\n    // Set a label for this phyloreference.\n    if (has(this.phyloref, 'label')) {\n      this.phyloref.label = newLabel;\n    } else {\n      // Vue.set(this.phyloref, 'label', newLabel);\n      this.phyloref.label = newLabel;\n    }\n  }\n\n  /** Return all the specifiers of this phyloref (if any). */\n  get specifiers() {\n    // Returns a list of all specifiers by combining the internal and external\n    // specifiers into a single list, with internal specifiers before\n    // external specifiers.\n    let specifiers = this.internalSpecifiers;\n    specifiers = specifiers.concat(this.externalSpecifiers);\n    return specifiers;\n  }\n\n  getSpecifierType(specifier) {\n    // For a given specifier, return a string indicating whether it is\n    // an 'Internal' or 'External' specifier.\n\n    if (this.internalSpecifiers.includes(specifier)) return 'Internal';\n    if (this.externalSpecifiers.includes(specifier)) return 'External';\n    return 'Specifier';\n  }\n\n  setSpecifierType(specifier, specifierType) {\n    // Change the type of a given specifier. To do this, we first need\n    // to determine if it was originally an internal or external\n    // specifier, then move it into the other list.\n\n    let index;\n    if (specifierType === 'Internal') {\n      // To set a specifier to 'Internal', we might need to delete it from the\n      // list of external specifiers first.\n      index = this.externalSpecifiers.indexOf(specifier);\n      if (index !== -1) this.externalSpecifiers.splice(index, 1);\n\n      // Don't add it to the list of internal specifiers if it's already there.\n      if (!this.internalSpecifiers.includes(specifier)) {\n        this.phyloref.internalSpecifiers.unshift(specifier);\n      }\n    } else if (specifierType === 'External') {\n      // To set a specifier to 'External', we might need to delete it from the\n      // list of internal specifiers first.\n      index = this.phyloref.internalSpecifiers.indexOf(specifier);\n      if (index !== -1) this.phyloref.internalSpecifiers.splice(index, 1);\n\n      // Don't add it to the list of internal specifiers if it's already there.\n      if (!this.phyloref.externalSpecifiers.includes(specifier)) {\n        this.phyloref.externalSpecifiers.unshift(specifier);\n      }\n    } else {\n      // Neither internal nor external? Ignore.\n    }\n  }\n\n  deleteSpecifier(specifier) {\n    // Since the user interface combines specifiers into a single list,\n    // it doesn't remember if the specifier to be deleted is internal\n    // or external. We delete the intended specifier from both arrays.\n\n    let index = this.phyloref.internalSpecifiers.indexOf(specifier);\n    if (index !== -1) this.phyloref.internalSpecifiers.splice(index, 1);\n\n    index = this.phyloref.externalSpecifiers.indexOf(specifier);\n    if (index !== -1) this.phyloref.externalSpecifiers.splice(index, 1);\n  }\n\n  getExpectedNodeLabels(phylogeny) {\n    // Given a phylogeny, determine which node labels we expect this phyloref to\n    // resolve to. To do this, we:\n    //  1. Find all node labels that are case-sensitively identical\n    //     to the phyloreference.\n    //  2. Find all node labels that have additionalNodeProperties with\n    //     expectedPhyloreferenceNamed case-sensitively identical to\n    //     the phyloreference.\n    const phylorefLabel = this.label;\n    const nodeLabels = new Set();\n\n    new PhylogenyWrapper(\n      phylogeny,\n      this.defaultNomenCode\n    ).getNodeLabels().forEach((nodeLabel) => {\n      // Is this node label identical to the phyloreference name?\n      if (nodeLabel === phylorefLabel) {\n        nodeLabels.add(nodeLabel);\n      } else if (\n        has(phylogeny, 'additionalNodeProperties')\n        && has(phylogeny.additionalNodeProperties, nodeLabel)\n        && has(phylogeny.additionalNodeProperties[nodeLabel], 'expectedPhyloreferenceNamed')\n      ) {\n        // Does this node label have an expectedPhyloreferenceNamed that\n        // includes this phyloreference name?\n\n        const expectedPhylorefs = phylogeny\n          .additionalNodeProperties[nodeLabel]\n          .expectedPhyloreferenceNamed;\n\n        if (expectedPhylorefs.includes(phylorefLabel)) {\n          nodeLabels.add(nodeLabel);\n        }\n      }\n    });\n\n    // Return node labels sorted alphabetically.\n    return Array.from(nodeLabels).sort();\n  }\n\n  static getStatusCURIEsInEnglish() {\n    // Return dictionary of all phyloref statuses in English\n    return {\n      'pso:draft': 'Draft',\n      'pso:final-draft': 'Final draft',\n      'pso:under-review': 'Under review',\n      'pso:submitted': 'Tested',\n      'pso:published': 'Published',\n      'pso:retracted-from-publication': 'Retracted',\n    };\n  }\n\n  getCurrentStatus() {\n    // Return a result object that contains:\n    //  - status: phyloreference status as a short URI (CURIE)\n    //  - statusInEnglish: an English representation of the phyloref status\n    //  - intervalStart: the start of the interval\n    //  - intervalEnd: the end of the interval\n\n    if (\n      has(this.phyloref, 'pso:holdsStatusInTime')\n      && Array.isArray(this.phyloref['pso:holdsStatusInTime'])\n      && this.phyloref['pso:holdsStatusInTime'].length > 0\n    ) {\n      // If we have any pso:holdsStatusInTime entries, pick the first one and\n      // extract the CURIE and time interval information from it.\n      const lastStatusInTime = this.phyloref['pso:holdsStatusInTime'][this.phyloref['pso:holdsStatusInTime'].length - 1];\n      const statusCURIE = lastStatusInTime['pso:withStatus']['@id'];\n\n      // Look for time interval information\n      let intervalStart;\n      let intervalEnd;\n\n      if (has(lastStatusInTime, 'tvc:atTime')) {\n        const atTime = lastStatusInTime['tvc:atTime'];\n        if (has(atTime, 'timeinterval:hasIntervalStartDate')) intervalStart = atTime['timeinterval:hasIntervalStartDate'];\n        if (has(atTime, 'timeinterval:hasIntervalEndDate')) intervalEnd = atTime['timeinterval:hasIntervalEndDate'];\n      }\n\n      // Return result object\n      return {\n        statusCURIE,\n        statusInEnglish: PhylorefWrapper.getStatusCURIEsInEnglish()[statusCURIE],\n        intervalStart,\n        intervalEnd,\n      };\n    }\n\n    // If we couldn't figure out a status for this phyloref, assume it's a draft.\n    return {\n      statusCURIE: 'pso:draft',\n      statusInEnglish: PhylorefWrapper.getStatusCURIEsInEnglish()['pso:draft'],\n    };\n  }\n\n  getStatusChanges() {\n    // Return a list of status changes for a particular phyloreference\n    if (has(this.phyloref, 'pso:holdsStatusInTime')) {\n      return this.phyloref['pso:holdsStatusInTime'].map((entry) => {\n        const result = {};\n\n        // Create a statusCURIE convenience field.\n        if (has(entry, 'pso:withStatus')) {\n          result.statusCURIE = entry['pso:withStatus']['@id'];\n          result.statusInEnglish = PhylorefWrapper.getStatusCURIEsInEnglish()[result.statusCURIE];\n        }\n\n        // Create intervalStart/intervalEnd convenient fields\n        if (has(entry, 'tvc:atTime')) {\n          const atTime = entry['tvc:atTime'];\n          if (has(atTime, 'timeinterval:hasIntervalStartDate')) {\n            result.intervalStart = atTime['timeinterval:hasIntervalStartDate'];\n            result.intervalStartAsCalendar = moment(result.intervalStart).calendar();\n          }\n\n          if (has(atTime, 'timeinterval:hasIntervalEndDate')) {\n            result.intervalEnd = atTime['timeinterval:hasIntervalEndDate'];\n            result.intervalEndAsCalendar = moment(result.intervalEnd).calendar();\n          }\n        }\n\n        return result;\n      });\n    }\n\n    // No changes? Return an empty list.\n    return [];\n  }\n\n  setStatus(status) {\n    // Set the status of a phyloreference\n    //\n    // Check whether we have a valid status CURIE.\n    if (!has(PhylorefWrapper.getStatusCURIEsInEnglish(), status)) {\n      throw new TypeError(`setStatus() called with invalid status CURIE '${status}'`);\n    }\n\n    // See if we can end the previous interval.\n    const currentTime = new Date(Date.now()).toISOString();\n\n    if (!has(this.phyloref, 'pso:holdsStatusInTime')) {\n      // Vue.set(this.phyloref, 'pso:holdsStatusInTime', []);\n      this.phyloref['pso:holdsStatusInTime'] = [];\n    }\n\n    // Check to see if there's a previous time interval we should end.\n    if (\n      Array.isArray(this.phyloref['pso:holdsStatusInTime'])\n      && this.phyloref['pso:holdsStatusInTime'].length > 0\n    ) {\n      const lastStatusInTime = this.phyloref['pso:holdsStatusInTime'][this.phyloref['pso:holdsStatusInTime'].length - 1];\n\n      // if (!has(lastStatusInTime, 'tvc:atTime'))\n      //  Vue.set(lastStatusInTime, 'tvc:atTime', {});\n      if (!has(lastStatusInTime, 'tvc:atTime')) {\n        lastStatusInTime['tvc:atTime'] = {};\n      }\n      if (!has(lastStatusInTime['tvc:atTime'], 'timeinterval:hasIntervalEndDate')) {\n        // If the last time entry doesn't already have an interval end date, set it to now.\n        lastStatusInTime['tvc:atTime']['timeinterval:hasIntervalEndDate'] = currentTime;\n      }\n    }\n\n    // Create new entry.\n    this.phyloref['pso:holdsStatusInTime'].push({\n      '@type': 'http://purl.org/spar/pso/StatusInTime',\n      'pso:withStatus': { '@id': status },\n      'tvc:atTime': {\n        'timeinterval:hasIntervalStartDate': currentTime,\n      },\n    });\n  }\n\n  /**\n   * Return a list of all the unique nomenclatural codes used by this phyloreference.\n   * The default nomenclatural code used in creating the PhylorefWrapper will be used\n   * for any taxonomic units that don't have any nomenclatural code set. If any\n   * specifiers are not taxon concepts, they will be represented in the returned\n   * list as owlterms.UNKNOWN_CODE.\n   */\n  get uniqNomenCodes() {\n    return uniq(this.specifiers.map((specifier) => {\n      const taxonConcept = new TaxonomicUnitWrapper(\n        specifier,\n        this.phyxDefaultNomenCode\n      ).taxonConcept;\n      if (!taxonConcept) return owlterms.UNKNOWN_CODE;\n\n      const nomenCode = new TaxonConceptWrapper(\n        taxonConcept,\n        this.phyxDefaultNomenCode\n      ).nomenCode;\n      if (!nomenCode) return owlterms.UNKNOWN_CODE;\n\n      return nomenCode;\n    }));\n  }\n\n  /**\n   * Returns a summarized nomenclatural code for this phyloref. If all of the\n   * specifiers have either the same nomenclatural code or `undefined`,\n   * this getter will return that nomenclatural code. Otherwise, this method\n   * will return owlterms.UNKNOWN_CODE.\n   */\n  get defaultNomenCode() {\n    // Check to see if we have a single nomenclatural code to use.\n    if (this.uniqNomenCodes.length === 1) return this.uniqNomenCodes[0];\n\n    // If one or more of our specifiers have no nomenclatural code (e.g. if\n    // they are specimens), they will show up as owlterms.UNKNOWN_CODE.\n    // If we have a single nomenclatural code *apart* from all the\n    // owlterms.UNKNOWN_CODEs, then that is still usable as a default\n    // nomenclatural code for this phyloreference.\n    const uniqNomenCodesNoUnknowns = this.uniqNomenCodes\n      .filter(code => code !== owlterms.UNKNOWN_CODE);\n    if (uniqNomenCodesNoUnknowns.length === 1) return uniqNomenCodesNoUnknowns[0];\n\n    return owlterms.UNKNOWN_CODE;\n  }\n\n  /**\n   * Create a component class for the set of internal and external specifiers provided.\n   * We turn this into a label (in the form `A & B ~ C V D`), which we use to ensure that\n   * we don't create more than one class for a particular set of internal and external\n   * specifiers.\n   * - jsonld: The JSON-LD representation of the Phyloreference this is an component class\n   *   for. We mainly use this to retrieve its '@id'.\n   * - internalSpecifiers: The set of internal specifiers for this component class.\n   * - externalSpecifiers: The set of external specifiers for this component class.\n   * - equivClass: The equivalent class expression for this component class as a function\n   *   that returns the expression as a string.\n   * - reusePrevious (default: true): If true, we reuse previous expressions with the\n   *   same set of included and excluded specifiers. If false, we always generate a new\n   *   component class for this expression.\n   * - parentClass: If not undefined, provides a JSON-LD definition of the class to set as the\n   *   parent class of this component class. We only use the ['@id'].\n   */\n  static createComponentClass(\n    jsonld,\n    internalSpecifiers,\n    externalSpecifiers,\n    equivClass,\n    reusePrevious = true,\n    parentClass = undefined\n  ) {\n    if (internalSpecifiers.length === 0) throw new Error('Cannot create component class without any internal specifiers');\n    if (internalSpecifiers.length === 1 && externalSpecifiers.length === 0) throw new Error('Cannot create component class with a single internal specifiers and no external specifiers');\n\n    /* Generate a label that represents this component class. */\n\n    // Start with the internal specifiers, concatenated with '&'.\n    const internalSpecifierLabel = internalSpecifiers\n      .map(i => new TaxonomicUnitWrapper(i).label || '(error)')\n      .sort()\n      .join(' & ');\n    let componentClassLabel = `(${internalSpecifierLabel}`;\n\n    if (externalSpecifiers.length === 0) {\n      componentClassLabel += ')';\n    } else {\n      // Add the external specifiers, concatenated with 'V'.\n      const externalSpecifierLabel = externalSpecifiers\n        .map(i => new TaxonomicUnitWrapper(i).label || '(error)')\n        .sort()\n        .join(' V ');\n      componentClassLabel += ` ~ ${externalSpecifierLabel})`;\n    }\n\n    // process.stderr.write(`component class label: ${componentClassLabel}\\n`);\n\n    // TODO We need to replace this with an actual object-based comparison,\n    // rather than trusting the labels to tell us everything.\n    if (reusePrevious && has(PhylorefWrapper.componentClassesByLabel, componentClassLabel)) {\n      // If we see the same label again, return the previously defined component class.\n      return { '@id': PhylorefWrapper.componentClassesByLabel[componentClassLabel]['@id'] };\n    }\n\n    // Create a new component class for this set of internal and external specifiers.\n    PhylorefWrapper.componentClassCount += 1;\n    const componentClass = {};\n    componentClass['@id'] = `${jsonld['@id']}_component${PhylorefWrapper.componentClassCount}`;\n    // process.stderr.write(`Creating new componentClass with id: ${componentClass['@id']}`);\n\n    componentClass['@type'] = 'owl:Class';\n    componentClass.label = componentClassLabel;\n    componentClass.equivalentClass = equivClass;\n    if (externalSpecifiers.length > 0) componentClass.subClassOf = ['phyloref:PhyloreferenceUsingMaximumClade'];\n    else componentClass.subClassOf = ['phyloref:PhyloreferenceUsingMinimumClade'];\n\n    if (parentClass) {\n      componentClass.subClassOf.push({\n        '@id': parentClass['@id'],\n      });\n    }\n\n    jsonld.hasComponentClass.push(componentClass);\n    PhylorefWrapper.componentClassesByLabel[componentClassLabel] = componentClass;\n\n    return { '@id': componentClass['@id'] };\n  }\n\n  static getIncludesRestrictionForTU(tu) {\n    return {\n      '@type': 'owl:Restriction',\n      onProperty: 'phyloref:includes_TU',\n      someValuesFrom: new TaxonomicUnitWrapper(tu, this.defaultNomenCode).asOWLEquivClass,\n    };\n  }\n\n  /**\n   * Return an OWL restriction for the most recent common ancestor (MRCA)\n   * of two taxonomic units.\n   */\n  static getMRCARestrictionOfTwoTUs(tu1, tu2) {\n    return {\n      '@type': 'owl:Restriction',\n      onProperty: 'obo:CDAO_0000149', // cdao:has_Child\n      someValuesFrom: {\n        '@type': 'owl:Class',\n        intersectionOf: [\n          {\n            '@type': 'owl:Restriction',\n            onProperty: 'phyloref:excludes_TU',\n            someValuesFrom: new TaxonomicUnitWrapper(tu1, this.defaultNomenCode).asOWLEquivClass,\n          },\n          PhylorefWrapper.getIncludesRestrictionForTU(tu2),\n        ],\n      },\n    };\n  }\n\n  /*\n   * Create an OWL restriction for a phyloreference made up entirely of internal\n   * specifiers.\n   *  - jsonld: the JSON-LD representation of this phyloreference in model 1.0.\n   *    We mainly use this to access the '@id' and internal and external specifiers.\n   *  - remainingInternals: all internal specifiers that have not yet been selected.\n   *  - selected: internal specifiers have been seen selected. This should initially\n   *    be [], and will be filled in when this method calls itself recursively.\n   *\n   * This method works like this:\n   *  1. We have several special cases: we fail if 0 or 1 specifiers are\n   *     provided, and we have a special representation for 2 specifiers.\n   *  2. Create an expression for the currently selected specifiers. This expression\n   *     is in the form:\n   *       has_Child some (\n   *        excludes_lineage_to some [remaining specifiers]\n   *        and [selected specifiers]\n   *       )\n   *     We generate the expressions for remaining specifiers and selected specifiers by calling\n   *     this method recursively.\n   *  3. Finally, we select another internal from the remainingInternals and generate an\n   *     expression for that selection by calling this method recursively. Note that we\n   *     only process cases where there are more remainingInternals than selected\n   *     internals -- when there are fewer, we'll just end up with the inverses of the\n   *     previous comparisons, which we'll already have covered.\n   */\n  static createClassExpressionsForInternals(jsonld, remainingInternals, selected) {\n    // process.stderr.write(`@id [${jsonld['@id']}] Remaining internals:\n    // ${remainingInternals.length}, selected: ${selected.length}\\n`);\n\n    // Quick special case: if we have two 'remainingInternals' and zero selecteds,\n    // we can just return the MRCA for two internal specifiers.\n    if (selected.length === 0) {\n      if (remainingInternals.length === 2) {\n        return [\n          PhylorefWrapper.getMRCARestrictionOfTwoTUs(remainingInternals[0], remainingInternals[1]),\n        ];\n      } if (remainingInternals.length === 1) {\n        throw new Error('Cannot determine class expression for a single specifier');\n      } else if (remainingInternals.length === 0) {\n        throw new Error('Cannot determine class expression for zero specifiers');\n      }\n    }\n\n    // Step 1. If we've already selected something, create an expression for it.\n    const classExprs = [];\n    if (selected.length > 0) {\n      let remainingInternalsExpr = [];\n      if (remainingInternals.length === 1) {\n        remainingInternalsExpr = PhylorefWrapper.getIncludesRestrictionForTU(remainingInternals[0]);\n      } else if (remainingInternals.length === 2) {\n        remainingInternalsExpr = PhylorefWrapper.getMRCARestrictionOfTwoTUs(\n          remainingInternals[0],\n          remainingInternals[1]\n        );\n      } else {\n        remainingInternalsExpr = PhylorefWrapper.createComponentClass(\n          jsonld,\n          remainingInternals,\n          [],\n          PhylorefWrapper.createClassExpressionsForInternals(jsonld, remainingInternals, [])\n        );\n      }\n\n      let selectedExpr = [];\n      if (selected.length === 1) {\n        selectedExpr = PhylorefWrapper.getIncludesRestrictionForTU(selected[0]);\n      } else if (selected.length === 2) {\n        selectedExpr = PhylorefWrapper.getMRCARestrictionOfTwoTUs(selected[0], selected[1]);\n      } else {\n        selectedExpr = PhylorefWrapper.createComponentClass(\n          jsonld,\n          selected,\n          [],\n          PhylorefWrapper.createClassExpressionsForInternals(jsonld, selected, [])\n        );\n      }\n\n      classExprs.push({\n        '@type': 'owl:Restriction',\n        onProperty: 'obo:CDAO_0000149', // cdao:has_Child\n        someValuesFrom: {\n          '@type': 'owl:Class',\n          intersectionOf: [{\n            '@type': 'owl:Restriction',\n            onProperty: 'phyloref:excludes_lineage_to',\n            someValuesFrom: remainingInternalsExpr,\n          }, selectedExpr],\n        },\n      });\n    }\n\n    // Step 2. Now select everything from remaining once, and start recursing through\n    // every possibility.\n    // Note that we only process cases where there are more remainingInternals than\n    // selected internals -- when there are fewer, we'll just end up with the inverses\n    // of the previous comparisons, which we'll already have covered.\n    if (remainingInternals.length > 1 && selected.length <= remainingInternals.length) {\n      remainingInternals.map(newlySelected => PhylorefWrapper.createClassExpressionsForInternals(\n        jsonld,\n        // The new remaining is the old remaining minus the selected TU.\n        remainingInternals.filter(i => i !== newlySelected),\n        // The new selected is the old selected plus the selected TU.\n        selected.concat([newlySelected])\n      ))\n        .reduce((acc, val) => acc.concat(val), [])\n        .forEach(expr => classExprs.push(expr));\n    }\n\n    return classExprs;\n  }\n\n\n  /*\n   * Given an expression that evaluates to an included node and a taxonomic unit,\n   * return an expression for including it and excluding the TU. Note that this\n   * always returns an array.\n   *\n   * When the included expression includes a single taxonomic unit (i.e. is in the\n   * form `includes_TU some [TU]`), then the simple form is adequate. However, when\n   * it's a more complex expression, it's possible that the excluded TU isn't just\n   * sister to this clade but outside of it entirely. In that case, we add another\n   * class expression:\n   *  [includesExpr] and (has_Ancestor some (excludes_TU some [TU]))\n   */\n  static getClassExpressionsForExprAndTU(includedExpr, tu) {\n    if (!includedExpr) throw new Error('Exclusions require an included expression');\n\n    const exprs = [{\n      '@type': 'owl:Class',\n      intersectionOf: [\n        includedExpr,\n        {\n          '@type': 'owl:Restriction',\n          onProperty: 'phyloref:excludes_TU',\n          someValuesFrom: new TaxonomicUnitWrapper(tu, this.defaultNomenCode).asOWLEquivClass,\n        },\n      ],\n    }];\n\n    if (!Array.isArray(includedExpr) && has(includedExpr, 'onProperty') && includedExpr.onProperty === 'phyloref:includes_TU') {\n      // In this specific set of circumstances, we do NOT need to add the has_Ancestor check.\n    } else {\n      // Add the has_Ancestor check!\n      exprs.push({\n        '@type': 'owl:Class',\n        intersectionOf: [\n          includedExpr,\n          {\n            '@type': 'owl:Restriction',\n            onProperty: 'obo:CDAO_0000144', // has_Ancestor\n            someValuesFrom: {\n              '@type': 'owl:Restriction',\n              onProperty: 'phyloref:excludes_TU',\n              someValuesFrom: new TaxonomicUnitWrapper(\n                tu,\n                this.defaultNomenCode\n              ).asOWLEquivClass,\n            },\n          },\n        ],\n      });\n    }\n\n    return exprs;\n  }\n\n\n  /*\n   * Returns a list of class expressions for a phyloreference that has an expression\n   * for the MRCA of its internal specifiers, but also has one or more external specifiers.\n   *  - jsonld: The JSON-LD form of the Phyloreference from Model 1.0. Mainly used\n   *    for retrieving the '@id' and the specifiers.\n   *  - accumulatedExpr: Initially, an expression that evaluates to the MRCA of all\n   *    internal specifiers, calculated using createClassExpressionsForInternals().\n   *    When we call this method recusively, this expression will incorporate\n   *    representations of external references.\n   *  - remainingExternals: External specifiers that are yet to be incorporated into the\n   *    expressions we are building.\n   *  - selected: External specifiers that have already been selected.\n   *\n   * Our overall algorithm here is:\n   *  1. If we need to add a single remaining external to the accumulated expression,\n   *     we can do that by adding an `excludes_TU` to the expression (and possibly a\n   *     `has_Ancestor` check, see getClassExpressionsForExprAndTU()).\n   *  2. If we need to add more than one remaining external, we select each external\n   *     specifier one at a time. We add the selected specifier to the accumulated\n   *     expression using getClassExpressionsForExprAndTU(), and then call ourselves\n   *     recursively to add the remaining specifiers.\n   *\n   * The goal here is to create expressions for every possible sequence of external\n   * specifiers, so we can account for cases where some external specifiers are closer\n   * to the initial internal-specifier-only expression than others.\n   */\n  static createClassExpressionsForExternals(jsonld, accumulatedExpr, remainingExternals, selected) {\n    // process.stderr.write(`@id [${jsonld['@id']}] Remaining externals:\n    // ${remainingExternals.length}, selected: ${selected.length}\\n`);\n\n    // Step 1. If we only have one external remaining, we can provide our two-case example\n    // to detect it.\n    const classExprs = [];\n    if (remainingExternals.length === 0) {\n      throw new Error('Cannot create class expression when no externals remain');\n    } else if (remainingExternals.length === 1) {\n      const remainingExternalsExprs = PhylorefWrapper.getClassExpressionsForExprAndTU(\n        accumulatedExpr,\n        remainingExternals[0],\n        selected.length > 0\n      );\n      remainingExternalsExprs.forEach(expr => classExprs.push(expr));\n    } else { // if(remainingExternals.length > 1)\n      // Recurse into remaining externals. Every time we select a single entry,\n      // we create a class expression for that.\n      remainingExternals.map((newlySelected) => {\n        // process.stderr.write(`Selecting new object, remaining now at:\n        // ${remainingExternals.filter(i => i !== newlySelected).length},\n        // selected: ${selected.concat([newlySelected]).length}\\n`);\n\n        // Create a new component class for the accumulated expression plus the\n        // newly selected external specifier.\n        const newlyAccumulatedExpr = PhylorefWrapper.createComponentClass(\n          jsonld,\n          jsonld.internalSpecifiers,\n          selected.concat([newlySelected]),\n          PhylorefWrapper.getClassExpressionsForExprAndTU(\n            accumulatedExpr, newlySelected, selected.length > 0\n          )\n        );\n\n        // Call ourselves recursively to add the remaining externals.\n        return PhylorefWrapper.createClassExpressionsForExternals(\n          jsonld,\n          newlyAccumulatedExpr,\n          // The new remaining is the old remaining minus the selected TU.\n          remainingExternals.filter(i => i !== newlySelected),\n          // The new selected is the old selected plus the selected TU.\n          selected.concat([newlySelected])\n        );\n      })\n        .reduce((acc, val) => acc.concat(val), [])\n        .forEach(expr => classExprs.push(expr));\n    }\n\n    return classExprs;\n  }\n\n  /*\n   * Phyloref.asJSONLD(fallbackIRI)\n   *\n   * Export this phylogeny as JSON-LD.\n   *\n   * Arguments:\n   *  - fallbackIRI: The base IRI to use for this phyloref if it does not have\n   *    an '@id'.\n   */\n  asJSONLD(fallbackIRI) {\n    // Keep all currently extant data.\n    const phylorefAsJSONLD = cloneDeep(this.phyloref);\n\n    // Set the @id and @type. If we don't already have an '@id', use the\n    // fallbackIRI.\n    if (!has(phylorefAsJSONLD, '@id')) phylorefAsJSONLD['@id'] = fallbackIRI;\n    phylorefAsJSONLD['@type'] = 'owl:Class';\n\n    // If we don't have a bibliographicCitation but we do have a definition source,\n    // then generate a bibliographicCitation for the source.\n    if (has(phylorefAsJSONLD, 'definitionSource')) {\n      const definitionSource = phylorefAsJSONLD.definitionSource;\n      if (!has(definitionSource, 'bibliographicCitation')) {\n        definitionSource.bibliographicCitation = new CitationWrapper(definitionSource).toString();\n      }\n    }\n\n    // Construct a class expression for this phyloreference.\n    const internalSpecifiers = phylorefAsJSONLD.internalSpecifiers || [];\n    const externalSpecifiers = phylorefAsJSONLD.externalSpecifiers || [];\n\n    // We might need to make component classes.\n    // So we reset our component class counts and records.\n    PhylorefWrapper.componentClassCount = 0;\n    PhylorefWrapper.componentClassesByLabel = {};\n    phylorefAsJSONLD.hasComponentClass = [];\n\n    // The type of this phyloreference.\n    let calculatedPhylorefType;\n\n    // The list of logical expressions generated for this phyloref.\n    let logicalExpressions = [];\n\n    if (internalSpecifiers.length === 0) {\n      // We can't handle phyloreferences without at least one internal specifier.\n      phylorefAsJSONLD.malformedPhyloreference = 'No internal specifiers provided';\n    } else if (externalSpecifiers.length > 0) {\n      calculatedPhylorefType = 'phyloref:PhyloreferenceUsingMaximumClade';\n\n      // If the phyloreference has at least one external specifier, we\n      // can provide a simplified expression for the internal specifier,\n      // in the form:\n      //  phyloref:includes_TU some [internal1] and\n      //  phyloref:includes_TU some [internal2] and ...\n      // To which we can then add the external specifiers.\n      if (internalSpecifiers.length === 1) {\n        logicalExpressions = PhylorefWrapper.createClassExpressionsForExternals(\n          phylorefAsJSONLD,\n          PhylorefWrapper.getIncludesRestrictionForTU(internalSpecifiers[0]),\n          externalSpecifiers,\n          []\n        );\n      } else {\n        const expressionForInternals = {\n          '@type': 'owl:Class',\n          intersectionOf: internalSpecifiers.map(PhylorefWrapper.getIncludesRestrictionForTU),\n        };\n\n        logicalExpressions = PhylorefWrapper.createClassExpressionsForExternals(\n          phylorefAsJSONLD, expressionForInternals, externalSpecifiers, []\n        );\n      }\n    } else {\n      calculatedPhylorefType = 'phyloref:PhyloreferenceUsingMinimumClade';\n\n      // We only have internal specifiers. We therefore need to use the algorithm in\n      // PhylorefWrapper.createClassExpressionsForInternals() to create this expression.\n      logicalExpressions = PhylorefWrapper.createClassExpressionsForInternals(\n        phylorefAsJSONLD, internalSpecifiers, []\n      );\n    }\n\n    // If we have a single logical expression, we set that as an equivalentClass\n    // expression. If we have more than one, we produce multiple component classes\n    // to represent it.\n    if (logicalExpressions.length === 0) {\n      // This is fine, as long as there is an explanation in\n      // phyloref.malformedPhyloreference explaining why no logical expressions\n      // could be generated. Otherwise, throw an error.\n      if (!has(phylorefAsJSONLD, 'malformedPhyloreference')) {\n        throw new Error(\n          `Phyloref ${this.label} was generated by Phyx.js with neither logical expressions nor an explanation for the lack of logical expressions. `\n          + 'This indicates an error in the Phyx.js library. Please report this bug at https://github.com/phyloref/phyx.js/issues.'\n        );\n      }\n    } else if (logicalExpressions.length === 1) {\n      // If we have a single logical expression, then that is what this phyloref\n      // is equivalent to.\n      phylorefAsJSONLD.equivalentClass = logicalExpressions[0];\n    } else {\n      // If we have multiple logical expressions, the phyloreference can be\n      // represented by any of them. We model this by creating subclasses of\n      // the phyloreference for each logical expression -- that way, it's clear\n      // that these expressions aren't equivalent to each other (which is what\n      // caused https://github.com/phyloref/phyx.js/issues/57), but nodes\n      // resolved by any of those expressions will also be included in the\n      // phyloreference itself.\n      //\n      // Note that there are two differences from the way in which we usually call\n      // PhylorefWrapper.createComponentClass():\n      //  1. Usually, createComponentClass() reuses logical expressions with the\n      //     same sets of internal and external specifiers. That won't work here,\n      //     since *all* these logical expressions have the same specifiers. So,\n      //     we turn off caching.\n      //  2. We need to set each of these component classes to be a subclass of\n      //     this phyloreference so that it can include instances from each of the\n      //     logical expressions.\n      logicalExpressions.forEach(classExpr => PhylorefWrapper.createComponentClass(\n        phylorefAsJSONLD,\n        internalSpecifiers,\n        externalSpecifiers,\n        classExpr,\n        // False in order to turn off caching by internal and external specifiers.\n        false,\n        // Make the new component class a subclass of this phyloreference.\n        phylorefAsJSONLD\n      ));\n    }\n\n    // Every phyloreference is a subclass of phyloref:Phyloreference.\n    if (!phylorefAsJSONLD.subClassOf) phylorefAsJSONLD.subClassOf = [];\n    if (!Array.isArray(phylorefAsJSONLD.subClassOf)) {\n      phylorefAsJSONLD.subClassOf = [phylorefAsJSONLD.subClassOf];\n    }\n    phylorefAsJSONLD.subClassOf.push('phyloref:Phyloreference');\n\n    // If the this Phyloref has a phylorefType that differs from the calculated\n    // phyloref type, throw an error.\n    if (has(phylorefAsJSONLD, 'phylorefType') && phylorefAsJSONLD.phylorefType !== calculatedPhylorefType) {\n      throw new Error(\n        `Phyloref ${this.label} has phylorefType set to '${phylorefAsJSONLD.phylorefType}', but it appears to be a '${calculatedPhylorefType}'.`\n      );\n    }\n    phylorefAsJSONLD.subClassOf.push(calculatedPhylorefType);\n\n    return phylorefAsJSONLD;\n  }\n}\n\nmodule.exports = {\n  PhylorefWrapper,\n};\n",
    "static": true,
    "longname": "/home/runner/work/phyx.js/phyx.js/src/wrappers/PhylorefWrapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 95,
    "kind": "variable",
    "name": "has",
    "memberof": "src/wrappers/PhylorefWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~has",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhylorefWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 96,
    "kind": "variable",
    "name": "TaxonomicUnitWrapper",
    "memberof": "src/wrappers/PhylorefWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~TaxonomicUnitWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhylorefWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 97,
    "kind": "variable",
    "name": "TaxonConceptWrapper",
    "memberof": "src/wrappers/PhylorefWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~TaxonConceptWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhylorefWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 98,
    "kind": "variable",
    "name": "PhylogenyWrapper",
    "memberof": "src/wrappers/PhylorefWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylogenyWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhylorefWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 99,
    "kind": "variable",
    "name": "CitationWrapper",
    "memberof": "src/wrappers/PhylorefWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~CitationWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhylorefWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 100,
    "kind": "class",
    "name": "PhylorefWrapper",
    "memberof": "src/wrappers/PhylorefWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "access": "public",
    "export": true,
    "importPath": "@phyloref/phyx/src/wrappers/PhylorefWrapper.js",
    "importStyle": "{PhylorefWrapper}",
    "description": "PhylorefWrapper",
    "lineNumber": 21,
    "interface": false
  },
  {
    "__docId__": 101,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true
  },
  {
    "__docId__": 102,
    "kind": "member",
    "name": "phyloref",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#phyloref",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 103,
    "kind": "member",
    "name": "phyxDefaultNomenCode",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#phyxDefaultNomenCode",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 104,
    "kind": "get",
    "name": "internalSpecifiers",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#internalSpecifiers",
    "access": "public",
    "description": "Return the internal specifiers of this phyloref (if any).",
    "lineNumber": 31,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 105,
    "kind": "get",
    "name": "externalSpecifiers",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#externalSpecifiers",
    "access": "public",
    "description": "Return the external specifiers of this phyloref (if any).",
    "lineNumber": 40,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 106,
    "kind": "get",
    "name": "label",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#label",
    "access": "public",
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 107,
    "kind": "set",
    "name": "label",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#label",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "undocument": true
  },
  {
    "__docId__": 108,
    "kind": "get",
    "name": "specifiers",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#specifiers",
    "access": "public",
    "description": "Return all the specifiers of this phyloref (if any).",
    "lineNumber": 68,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 109,
    "kind": "method",
    "name": "getSpecifierType",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#getSpecifierType",
    "access": "public",
    "description": null,
    "lineNumber": 77,
    "undocument": true,
    "params": [
      {
        "name": "specifier",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 110,
    "kind": "method",
    "name": "setSpecifierType",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#setSpecifierType",
    "access": "public",
    "description": null,
    "lineNumber": 86,
    "undocument": true,
    "params": [
      {
        "name": "specifier",
        "types": [
          "*"
        ]
      },
      {
        "name": "specifierType",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 111,
    "kind": "method",
    "name": "deleteSpecifier",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#deleteSpecifier",
    "access": "public",
    "description": null,
    "lineNumber": 117,
    "undocument": true,
    "params": [
      {
        "name": "specifier",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 112,
    "kind": "method",
    "name": "getExpectedNodeLabels",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#getExpectedNodeLabels",
    "access": "public",
    "description": null,
    "lineNumber": 129,
    "undocument": true,
    "params": [
      {
        "name": "phylogeny",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 113,
    "kind": "method",
    "name": "getStatusCURIEsInEnglish",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper.getStatusCURIEsInEnglish",
    "access": "public",
    "description": null,
    "lineNumber": 169,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "{\"pso:draft\": string, \"pso:final-draft\": string, \"pso:under-review\": string, \"pso:submitted\": string, \"pso:published\": string, \"pso:retracted-from-publication\": string}"
      ]
    }
  },
  {
    "__docId__": 114,
    "kind": "method",
    "name": "getCurrentStatus",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#getCurrentStatus",
    "access": "public",
    "description": null,
    "lineNumber": 181,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "{\"statusCURIE\": string, \"statusInEnglish\": *}"
      ]
    }
  },
  {
    "__docId__": 115,
    "kind": "method",
    "name": "getStatusChanges",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#getStatusChanges",
    "access": "public",
    "description": null,
    "lineNumber": 224,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 116,
    "kind": "method",
    "name": "setStatus",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#setStatus",
    "access": "public",
    "description": null,
    "lineNumber": 258,
    "undocument": true,
    "params": [
      {
        "name": "status",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 117,
    "kind": "get",
    "name": "uniqNomenCodes",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#uniqNomenCodes",
    "access": "public",
    "description": "Return a list of all the unique nomenclatural codes used by this phyloreference.\nThe default nomenclatural code used in creating the PhylorefWrapper will be used\nfor any taxonomic units that don't have any nomenclatural code set. If any\nspecifiers are not taxon concepts, they will be represented in the returned\nlist as owlterms.UNKNOWN_CODE.",
    "lineNumber": 309,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 118,
    "kind": "get",
    "name": "defaultNomenCode",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#defaultNomenCode",
    "access": "public",
    "description": "Returns a summarized nomenclatural code for this phyloref. If all of the\nspecifiers have either the same nomenclatural code or `undefined`,\nthis getter will return that nomenclatural code. Otherwise, this method\nwill return owlterms.UNKNOWN_CODE.",
    "lineNumber": 333,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 119,
    "kind": "method",
    "name": "createComponentClass",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper.createComponentClass",
    "access": "public",
    "description": "Create a component class for the set of internal and external specifiers provided.\nWe turn this into a label (in the form `A & B ~ C V D`), which we use to ensure that\nwe don't create more than one class for a particular set of internal and external\nspecifiers.\n- jsonld: The JSON-LD representation of the Phyloreference this is an component class\n  for. We mainly use this to retrieve its '@id'.\n- internalSpecifiers: The set of internal specifiers for this component class.\n- externalSpecifiers: The set of external specifiers for this component class.\n- equivClass: The equivalent class expression for this component class as a function\n  that returns the expression as a string.\n- reusePrevious (default: true): If true, we reuse previous expressions with the\n  same set of included and excluded specifiers. If false, we always generate a new\n  component class for this expression.\n- parentClass: If not undefined, provides a JSON-LD definition of the class to set as the\n  parent class of this component class. We only use the ['@id'].",
    "lineNumber": 366,
    "params": [
      {
        "name": "jsonld",
        "types": [
          "*"
        ]
      },
      {
        "name": "internalSpecifiers",
        "types": [
          "*"
        ]
      },
      {
        "name": "externalSpecifiers",
        "types": [
          "*"
        ]
      },
      {
        "name": "equivClass",
        "types": [
          "*"
        ]
      },
      {
        "name": "reusePrevious",
        "optional": true,
        "types": [
          "boolean"
        ],
        "defaultRaw": true,
        "defaultValue": "true"
      },
      {
        "name": "parentClass",
        "optional": true,
        "types": [
          "*"
        ],
        "defaultRaw": "undefined",
        "defaultValue": "undefined"
      }
    ],
    "return": {
      "types": [
        "{\"@id\": *}"
      ]
    }
  },
  {
    "__docId__": 120,
    "kind": "method",
    "name": "getIncludesRestrictionForTU",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper.getIncludesRestrictionForTU",
    "access": "public",
    "description": null,
    "lineNumber": 430,
    "undocument": true,
    "params": [
      {
        "name": "tu",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"@type\": string, \"onProperty\": string, \"someValuesFrom\": *}"
      ]
    }
  },
  {
    "__docId__": 121,
    "kind": "method",
    "name": "getMRCARestrictionOfTwoTUs",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper.getMRCARestrictionOfTwoTUs",
    "access": "public",
    "description": "Return an OWL restriction for the most recent common ancestor (MRCA)\nof two taxonomic units.",
    "lineNumber": 442,
    "params": [
      {
        "name": "tu1",
        "types": [
          "*"
        ]
      },
      {
        "name": "tu2",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"@type\": string, \"onProperty\": string, \"someValuesFrom\": *}"
      ]
    }
  },
  {
    "__docId__": 122,
    "kind": "method",
    "name": "createClassExpressionsForInternals",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper.createClassExpressionsForInternals",
    "access": "public",
    "description": null,
    "lineNumber": 486,
    "undocument": true,
    "params": [
      {
        "name": "jsonld",
        "types": [
          "*"
        ]
      },
      {
        "name": "remainingInternals",
        "types": [
          "*"
        ]
      },
      {
        "name": "selected",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "getClassExpressionsForExprAndTU",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper.getClassExpressionsForExprAndTU",
    "access": "public",
    "description": null,
    "lineNumber": 585,
    "undocument": true,
    "params": [
      {
        "name": "includedExpr",
        "types": [
          "*"
        ]
      },
      {
        "name": "tu",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 124,
    "kind": "method",
    "name": "createClassExpressionsForExternals",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper.createClassExpressionsForExternals",
    "access": "public",
    "description": null,
    "lineNumber": 654,
    "undocument": true,
    "params": [
      {
        "name": "jsonld",
        "types": [
          "*"
        ]
      },
      {
        "name": "accumulatedExpr",
        "types": [
          "*"
        ]
      },
      {
        "name": "remainingExternals",
        "types": [
          "*"
        ]
      },
      {
        "name": "selected",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 125,
    "kind": "method",
    "name": "asJSONLD",
    "memberof": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhylorefWrapper.js~PhylorefWrapper#asJSONLD",
    "access": "public",
    "description": null,
    "lineNumber": 715,
    "undocument": true,
    "params": [
      {
        "name": "fallbackIRI",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 126,
    "kind": "file",
    "name": "src/wrappers/PhyxWrapper.js",
    "content": "/** Helper methods from lodash. */\nconst { has, cloneDeep, uniq } = require('lodash');\n\nconst owlterms = require('../utils/owlterms');\n\nconst { PhylorefWrapper } = require('./PhylorefWrapper');\nconst { PhylogenyWrapper } = require('./PhylogenyWrapper');\nconst { TaxonomicUnitMatcher } = require('../matchers/TaxonomicUnitMatcher');\n\n/**\n * The PhyxWrapper wraps an entire Phyx document.\n */\n\nclass PhyxWrapper {\n  /**\n   * Wraps an entire PHYX document.\n   * @param {Object} phyx - The Phyx structure to wrap.\n   * @param {function(newick: string): {name: string, children: Object[]}}\n   *    [newickParser=PhylogenyWrapper.getParsedNewick] - A method\n   *    that accepts a Newick string and returns a list of nodes. Each node should have a\n   *    'children' key with its children and optionally a 'name' key with its label. This\n   *    code previously depended on phylotree.js, whose newick_parser() function works exactly\n   *    like this. This option allows you to drop in Phylotree's newick_parser() or -- if you\n   *    prefer -- any other option.\n   */\n  constructor(phyx, newickParser = PhylogenyWrapper.getParsedNewick) {\n    //\n    this.phyx = phyx;\n    this.newickParser = newickParser;\n  }\n\n  /**\n   * Generate an executable ontology from this Phyx document. The document is mostly in JSON-LD\n   * already, except for three important things:\n   *    1. We have to convert all phylogenies into a series of statements relating to the nodes\n   *       inside these phylogenies.\n   *    2. We have to convert phylogenies into OWL restrictions.\n   *    3. Insert all matches between taxonomic units in this file.\n   *\n   * @param {string} [baseIRI=\"\"] - The base IRI to use when generating this Phyx document.\n   *    This should include a trailing '#' or '/'. Use '' to indicate that relative IDs\n   *    should be generated in the produced ontology (e.g. '#phylogeny1'). Note that if a\n   *    baseIRI is provided, then relative IDs already in the Phyx file (identified by an\n   *    initial '#') will be turned into absolute IDs by removing the initial `#` and\n   *    prepending them with the baseIRI.\n   * @return {Object} This Phyx document as an OWL ontology as a JSON-LD object.\n   */\n  asOWLOntology(baseIRI = '') {\n    const jsonld = cloneDeep(this.phyx);\n\n    // Some helper methods for generating base IRIs for phylorefs and phylogenies.\n    function getBaseIRIForPhyloref(index) {\n      if (baseIRI) return `${baseIRI}phyloref${index}`;\n      return `#phyloref${index}`;\n    }\n\n    function getBaseIRIForPhylogeny(index) {\n      if (baseIRI) return `${baseIRI}phylogeny${index}`;\n      return `#phylogeny${index}`;\n    }\n\n    // Given a relative ID (e.g. '#phylo1') make it absolute (`${baseIRI}phylo1`).\n    function makeIDAbsolute(phylogenyId) {\n      if (baseIRI && phylogenyId.startsWith('#')) return `${baseIRI}${phylogenyId.substring(1)}`; // Remove the initial '#'.\n      return phylogenyId;\n    }\n\n    // Given an absolute ID (`${baseIRI}phylo1`) make it relative (e.g. '#phylo1').\n    function makeIDRelative(phylogenyId) {\n      if (phylogenyId.startsWith(baseIRI)) return `#${phylogenyId.substring(baseIRI.length)}`;\n      return phylogenyId;\n    }\n\n    // Determine a 'default nomenclatural code' for this Phyx file. There are\n    // two ways to do this:\n    //  1. If the Phyx file has a 'defaultNomenclaturalCodeIRI' property, we use that.\n    //  2. Otherwise, we check to see if every phyloref in this file has the same\n    //     nomenclatural code. If so, we can use that code. If not, i.e. if any of\n    //     the phylorefs are missing a nomenclatural code or include a specifier,\n    //     we default to owlterms.UNKNOWN_CODE.\n    function determineDefaultNomenCode() {\n      if (has(jsonld, 'defaultNomenclaturalCodeIRI')) return jsonld.defaultNomenclaturalCodeIRI;\n      const nomenCodes = (jsonld.phylorefs || [])\n        .map(phyloref => new PhylorefWrapper(phyloref).defaultNomenCode);\n      const uniqNomenCodes = uniq(nomenCodes);\n      if (uniqNomenCodes.length === 1) return uniqNomenCodes[0];\n      return owlterms.UNKNOWN_CODE;\n    }\n    const defaultNomenCode = determineDefaultNomenCode();\n\n    if (has(jsonld, 'phylorefs')) {\n      // We might have phyloref IDs set to relative IRIs (e.g. \"#phyloref0\").\n      // If the baseIRI is set to '', that's fine. But if not, we'll add it\n      // to the relative IRI to make it absolute. This seems to avoid problems\n      // with some JSON-LD parsers.\n      if (baseIRI) {\n        jsonld.phylorefs = jsonld.phylorefs.map((phyloref) => {\n          if ((phyloref['@id'] || '').startsWith('#')) {\n            const modifiedPhyloref = cloneDeep(phyloref);\n            modifiedPhyloref['@id'] = makeIDAbsolute(phyloref['@id']);\n            return modifiedPhyloref;\n          }\n          return phyloref;\n        });\n      }\n\n      // Convert phyloreferences into an OWL class restriction\n      jsonld.phylorefs = jsonld.phylorefs.map(\n        (phyloref, countPhyloref) => new PhylorefWrapper(phyloref, defaultNomenCode)\n          .asJSONLD(getBaseIRIForPhyloref(countPhyloref))\n      );\n    }\n\n    if (has(jsonld, 'phylogenies')) {\n      // We might have phyloref IDs set to relative IRIs (e.g. \"#phyloref0\").\n      // If the baseIRI is set to '', that's fine. But if not, we'll add it\n      // to the relative IRI to make it absolute. This seems to avoid problems\n      // with some JSON-LD parsers.\n      if (baseIRI) {\n        jsonld.phylogenies = jsonld.phylogenies.map((phylogeny) => {\n          if ((phylogeny['@id'] || '').startsWith('#')) {\n            const modifiedPhylogeny = cloneDeep(phylogeny);\n            modifiedPhylogeny['@id'] = makeIDAbsolute(phylogeny['@id']);\n            return modifiedPhylogeny;\n          }\n          return phylogeny;\n        });\n      }\n\n      // Add descriptions for individual nodes in each phylogeny.\n      jsonld.phylogenies = jsonld.phylogenies.map(\n        (phylogeny, countPhylogeny) => new PhylogenyWrapper(phylogeny, defaultNomenCode)\n          .asJSONLD(getBaseIRIForPhylogeny(countPhylogeny), this.newickParser)\n      );\n\n      // Go through all the nodes and add information on expected resolution.\n      jsonld.phylogenies.forEach((phylogeny) => {\n        const phylogenyId = phylogeny['@id'];\n        (phylogeny.nodes || []).forEach((node) => {\n          // We can't set expected resolution information on unlabeled nodes.\n          if (!node.labels) return;\n\n          jsonld.phylorefs.forEach((phyloref) => {\n            const phylorefId = phyloref['@id'];\n\n            // There are two ways in which we determine that a phyloreference\n            // is expected to resolve to a node:\n            //  (1) If nodeLabel is set, then that must be one of the node's labels.\n            //  (2) If nodeLabel is not set, then one of the node's label should be\n            //      identical to the phyloreference's label.\n            //\n            // We set flagNodeExpectsPhyloref in all cases where we should note\n            // that this node expects to resolve to this phyloreference.\n            let flagNodeExpectsPhyloref = false;\n\n            // console.log(`Testing expected resolution of '${phylorefId}' on `\n            // + `'${phylogenyId}' (${makeIDRelative(phylogenyId)}).`);\n\n            if (\n              has(phyloref, 'expectedResolution')\n              && (\n                // The user might have used the absolute phylogeny ID here.\n                has(phyloref.expectedResolution, phylogenyId)\n\n                // Or they might have used a relative phylogeny ID.\n                || has(phyloref.expectedResolution, makeIDRelative(phylogenyId))\n              )\n            ) {\n              // Expected resolution information set! The node label mentioned in that\n              // information must be identical to one of the labels of this phylogeny node.\n\n              // Figure out which phylogenyId was matched here.\n              const nodeLabel = has(phyloref.expectedResolution, phylogenyId)\n                ? phyloref.expectedResolution[phylogenyId].nodeLabel\n                : phyloref.expectedResolution[makeIDRelative(phylogenyId)].nodeLabel;\n\n              if (nodeLabel && (node.labels || []).includes(nodeLabel)) {\n                flagNodeExpectsPhyloref = true;\n              }\n            } else if ((node.labels || []).includes(phyloref.label)) {\n              // No expected resolution information, so we just check whether\n              // the phyloref label is one of the labels on this phylogeny node.\n              flagNodeExpectsPhyloref = true;\n            }\n\n            if (flagNodeExpectsPhyloref) {\n              // Modify this phylogeny node's type to include that it is a type\n              // of:\n              //  obi:is_specified_output_of some (\n              //    obi:Prediction and obi:has_specified_output some #phyloref_id\n              //  )\n              node[owlterms.RDF_TYPE].push({\n                '@type': owlterms.OWL_RESTRICTION,\n                onProperty: owlterms.OBI_IS_SPECIFIED_OUTPUT_OF,\n                someValuesFrom: {\n                  '@type': owlterms.OWL_CLASS,\n                  intersectionOf: [\n                    { '@id': owlterms.OBI_PREDICTION },\n                    {\n                      '@type': owlterms.OWL_RESTRICTION,\n                      onProperty: owlterms.OBI_HAS_SPECIFIED_INPUT,\n                      someValuesFrom: {\n                        '@id': phylorefId,\n                      },\n                    },\n                  ],\n                },\n              });\n            }\n          });\n        });\n      });\n    }\n\n    // Match all specifiers with nodes.\n    if (has(jsonld, 'phylorefs') && has(jsonld, 'phylogenies')) {\n      jsonld.hasTaxonomicUnitMatches = [];\n\n      // Used to create unique identifiers for each taxonomic unit match.\n      let countTaxonomicUnitMatches = 0;\n\n      jsonld.phylorefs.forEach((phylorefToChange) => {\n        const phyloref = phylorefToChange;\n        let specifiers = [];\n\n        if (has(phyloref, 'internalSpecifiers')) {\n          specifiers = specifiers.concat(phyloref.internalSpecifiers);\n        }\n\n        if (has(phyloref, 'externalSpecifiers')) {\n          specifiers = specifiers.concat(phyloref.externalSpecifiers);\n        }\n\n        specifiers.forEach((specifier) => {\n          if (!has(specifier, 'referencesTaxonomicUnits')) return;\n          const specifierTUs = specifier.referencesTaxonomicUnits;\n          let nodesMatchedCount = 0;\n\n          jsonld.phylogenies.forEach((phylogenyToChange) => {\n            const phylogeny = phylogenyToChange;\n\n            specifierTUs.forEach((specifierTU) => {\n              phylogeny.nodes.forEach((node) => {\n                if (!has(node, 'representsTaxonomicUnits')) return;\n                const nodeTUs = node.representsTaxonomicUnits;\n\n                nodeTUs.forEach((nodeTU) => {\n                  const matcher = new TaxonomicUnitMatcher(specifierTU, nodeTU);\n                  if (matcher.matched) {\n                    const tuMatchAsJSONLD = matcher.asJSONLD(\n                      PhyxWrapper.getBaseIRIForTUMatch(countTaxonomicUnitMatches)\n                    );\n                    jsonld.hasTaxonomicUnitMatches.push(tuMatchAsJSONLD);\n                    nodesMatchedCount += 1;\n                    countTaxonomicUnitMatches += 1;\n                  }\n                });\n              });\n            });\n          });\n\n          if (nodesMatchedCount === 0) {\n            // No nodes matched? Record this as an unmatched specifier.\n            if (!has(phyloref, 'hasUnmatchedSpecifiers')) phyloref.hasUnmatchedSpecifiers = [];\n            phyloref.hasUnmatchedSpecifiers.push(specifier);\n          }\n        });\n      });\n    }\n\n    // Finally, add the base URI as an ontology.\n    if (baseIRI) jsonld['@id'] = baseIRI;\n    jsonld['@type'] = [owlterms.PHYLOREFERENCE_TEST_CASE, 'owl:Ontology'];\n    jsonld['owl:imports'] = [\n      'http://raw.githubusercontent.com/phyloref/curation-workflow/develop/ontologies/phyloref_testcase.owl',\n      'http://ontology.phyloref.org/2018-12-14/phyloref.owl',\n      'http://ontology.phyloref.org/2018-12-14/tcan.owl',\n    ];\n\n    // If the '@context' is missing, add it here.\n    if (!has(jsonld, '@context')) {\n      jsonld['@context'] = owlterms.PHYX_CONTEXT_JSON;\n    }\n\n    return jsonld;\n  }\n}\n\nmodule.exports = {\n  PhyxWrapper,\n};\n",
    "static": true,
    "longname": "/home/runner/work/phyx.js/phyx.js/src/wrappers/PhyxWrapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 127,
    "kind": "variable",
    "name": "has",
    "memberof": "src/wrappers/PhyxWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhyxWrapper.js~has",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhyxWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 128,
    "kind": "variable",
    "name": "PhylorefWrapper",
    "memberof": "src/wrappers/PhyxWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhyxWrapper.js~PhylorefWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhyxWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 129,
    "kind": "variable",
    "name": "PhylogenyWrapper",
    "memberof": "src/wrappers/PhyxWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhyxWrapper.js~PhylogenyWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhyxWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 130,
    "kind": "variable",
    "name": "TaxonomicUnitMatcher",
    "memberof": "src/wrappers/PhyxWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhyxWrapper.js~TaxonomicUnitMatcher",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/PhyxWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 131,
    "kind": "class",
    "name": "PhyxWrapper",
    "memberof": "src/wrappers/PhyxWrapper.js",
    "static": true,
    "longname": "src/wrappers/PhyxWrapper.js~PhyxWrapper",
    "access": "public",
    "export": true,
    "importPath": "@phyloref/phyx/src/wrappers/PhyxWrapper.js",
    "importStyle": "{PhyxWrapper}",
    "description": "The PhyxWrapper wraps an entire Phyx document.",
    "lineNumber": 18,
    "interface": false
  },
  {
    "__docId__": 132,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/wrappers/PhyxWrapper.js~PhyxWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhyxWrapper.js~PhyxWrapper#constructor",
    "access": "public",
    "description": "Wraps an entire PHYX document.",
    "lineNumber": 30,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "phyx",
        "description": "The Phyx structure to wrap."
      },
      {
        "nullable": null,
        "types": [
          "function(newick: string): {name: string, children: Object[]}"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "PhylogenyWrapper.getParsedNewick",
        "defaultRaw": "PhylogenyWrapper.getParsedNewick",
        "name": "newickParser",
        "description": "A method\n   that accepts a Newick string and returns a list of nodes. Each node should have a\n   'children' key with its children and optionally a 'name' key with its label. This\n   code previously depended on phylotree.js, whose newick_parser() function works exactly\n   like this. This option allows you to drop in Phylotree's newick_parser() or -- if you\n   prefer -- any other option."
      }
    ]
  },
  {
    "__docId__": 133,
    "kind": "member",
    "name": "phyx",
    "memberof": "src/wrappers/PhyxWrapper.js~PhyxWrapper",
    "static": false,
    "longname": "src/wrappers/PhyxWrapper.js~PhyxWrapper#phyx",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 134,
    "kind": "member",
    "name": "newickParser",
    "memberof": "src/wrappers/PhyxWrapper.js~PhyxWrapper",
    "static": false,
    "longname": "src/wrappers/PhyxWrapper.js~PhyxWrapper#newickParser",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 135,
    "kind": "method",
    "name": "asOWLOntology",
    "memberof": "src/wrappers/PhyxWrapper.js~PhyxWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/PhyxWrapper.js~PhyxWrapper#asOWLOntology",
    "access": "public",
    "description": "Generate an executable ontology from this Phyx document. The document is mostly in JSON-LD\nalready, except for three important things:\n   1. We have to convert all phylogenies into a series of statements relating to the nodes\n      inside these phylogenies.\n   2. We have to convert phylogenies into OWL restrictions.\n   3. Insert all matches between taxonomic units in this file.",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "\"\"",
        "defaultRaw": "",
        "name": "baseIRI",
        "description": "The base IRI to use when generating this Phyx document.\n   This should include a trailing '#' or '/'. Use '' to indicate that relative IDs\n   should be generated in the produced ontology (e.g. '#phylogeny1'). Note that if a\n   baseIRI is provided, then relative IDs already in the Phyx file (identified by an\n   initial '#') will be turned into absolute IDs by removing the initial `#` and\n   prepending them with the baseIRI."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "This Phyx document as an OWL ontology as a JSON-LD object."
    }
  },
  {
    "__docId__": 136,
    "kind": "file",
    "name": "src/wrappers/SpecimenWrapper.js",
    "content": "const { has } = require('lodash');\nconst { TaxonConceptWrapper } = require('./TaxonConceptWrapper');\nconst owlterms = require('../utils/owlterms');\nconst { PhyxCacheManager } = require('../utils/PhyxCacheManager');\n\n/**\n * The SpecimenWrapper wraps specimen taxonomic units. These can be identified\n * with a '@type' of SpecimenWrapper.TYPE_SPECIMEN (which is currently\n * https://dwc.tdwg.org/terms/#occurrence).\n *\n * - TaxonomicUnitWrapper.TYPE_SPECIMEN: A specimen.\n *    - Based on http://rs.tdwg.org/dwc/terms/Occurrence\n *    - Should have a dwc:occurrenceID with the occurrence identifier.\n *    - Should have a dwc:basisOfRecord to indicate what sort of occurrence this is.\n *\n * Since TaxonNameWrapper follows the TDWG ontology, we'd love to do the same for\n * SpecimenWrapper, but unfortunately the TaxonOccurrence ontology has been deprecated\n * (see https://github.com/tdwg/ontology). Therefore, it instead improvises a\n * representation based on dwc:Occurrence.\n */\nclass SpecimenWrapper {\n  /** The '@type' of specimens in JSON-LD document. */\n  static get TYPE_SPECIMEN() {\n    return owlterms.DWC_OCCURRENCE;\n  }\n\n  /** Construct a wrapper around a specimen. */\n  constructor(specimen) {\n    this.specimen = specimen;\n  }\n\n  /**\n   * Parse the provided occurrence ID. The two expected formats are:\n   *  - 'urn:catalog:[institutionCode]:[collectionCode]:[catalogNumber]'\n   *      (in which case, we ignore the first two \"components\" here)\n   *  - '[institutionCode]:[collectionCode]:[catalogNumber]'\n   */\n  static fromOccurrenceID(occurrenceID, basisOfRecord = 'PreservedSpecimen') {\n    // Copy the occurrence ID so we can truncate it if necessary.\n    let occurID = occurrenceID;\n    if (occurID.startsWith('urn:catalog:')) occurID = occurID.substr(12);\n\n    // Prepare the specimen.\n    const specimen = {\n      '@type': SpecimenWrapper.TYPE_SPECIMEN,\n      'dwc:basisOfRecord': basisOfRecord,\n      occurrenceID: occurID,\n    };\n\n    // Look for certain prefixes that suggest that we've been passed a URN or\n    // URL instead. If so, don't do any further processing!\n    const URL_URN_PREFIXES = [\n      'http://',\n      'https://',\n      'ftp://',\n      'sftp://',\n      'file://',\n      'urn:',\n    ];\n    if (URL_URN_PREFIXES.filter(prefix => occurID.toLowerCase().startsWith(prefix)).length > 0) {\n      return specimen;\n    }\n\n    // Parsing an occurrence ID takes some time, so we should memoize it.\n    if (PhyxCacheManager.has('SpecimenWrapper.occurrenceIDCache', occurID)) {\n      return PhyxCacheManager.get('SpecimenWrapper.occurrenceIDCache', occurID);\n    }\n\n    // Split the occurrence ID into components, and store them in the appropriate fields.\n    const comps = occurID.split(/:/);\n    if (comps.length === 1) {\n      // specimen.institutionCode = undefined;\n      // specimen.collectionCode = undefined;\n      [specimen.catalogNumber] = comps;\n    } else if (comps.length === 2) {\n      [specimen.institutionCode, specimen.catalogNumber] = comps;\n    } else if (comps.length >= 3) {\n      let catalogNumValues = []; // Store all split catalog number values.\n      [specimen.institutionCode, specimen.collectionCode, ...catalogNumValues] = comps;\n      specimen.catalogNumber = catalogNumValues.join(':');\n    }\n\n    PhyxCacheManager.put('SpecimenWrapper.occurrenceIDCache', occurID, specimen);\n    return specimen;\n  }\n\n  /**\n   * Get the catalogNumber if present.\n   */\n  get catalogNumber() {\n    // Get the catalog number from the specimen object if present.\n    if (has(this.specimen, 'catalogNumber')) return this.specimen.catalogNumber;\n\n    // Otherwise, try to parse the occurrenceID and see if we can extract a\n    // catalogNumber from there.\n    if (has(this.specimen, 'occurrenceID')) {\n      const specimen = SpecimenWrapper.fromOccurrenceID(this.specimen.occurrenceID);\n      if (has(specimen, 'catalogNumber')) return specimen.catalogNumber;\n    }\n    return undefined;\n  }\n\n  /**\n   * Get the institutionCode if present.\n   */\n  get institutionCode() {\n    // Get the institution code from the specimen object if present.\n    if (has(this.specimen, 'institutionCode')) return this.specimen.institutionCode;\n\n    // Otherwise, try to parse the occurrenceID and see if we can extract an\n    // occurrenceID from there.\n    if (has(this.specimen, 'occurrenceID')) {\n      const specimen = SpecimenWrapper.fromOccurrenceID(this.specimen.occurrenceID);\n      if (has(specimen, 'institutionCode')) return specimen.institutionCode;\n    }\n    return undefined;\n  }\n\n  /**\n   * Get the collectionCode if present.\n   */\n  get collectionCode() {\n    // Get the collection code from the specimen object if present.\n    if (has(this.specimen, 'collectionCode')) return this.specimen.collectionCode;\n\n    // Otherwise, try to parse the occurrenceID and see if we can extract an\n    // occurrenceID from there.\n    if (has(this.specimen, 'occurrenceID')) {\n      const specimen = SpecimenWrapper.fromOccurrenceID(this.specimen.occurrenceID);\n      if (has(specimen, 'collectionCode')) return specimen.collectionCode;\n    }\n    return undefined;\n  }\n\n  /**\n   * Return the occurrence ID of this specimen, if we have one. Otherwise, we\n   * attempt to construct one in the form:\n   *  \"urn:catalog:\" + institutionCode (if present) + ':' +\n   *  collectionCode (if present) + ':' + catalogNumber (if present)\n   */\n  get occurrenceID() {\n    // Return the occurrenceID if it exists.\n    if (has(this.specimen, 'occurrenceID') && this.specimen.occurrenceID.trim() !== '') {\n      return this.specimen.occurrenceID.trim();\n    }\n\n    // Otherwise, we could try to construct the occurrenceID from its components.\n    if (has(this.specimen, 'catalogNumber')) {\n      if (has(this.specimen, 'institutionCode')) {\n        if (has(this.specimen, 'collectionCode')) {\n          return `urn:catalog:${this.specimen.institutionCode.trim()}:${this.specimen.collectionCode.trim()}:${this.specimen.catalogNumber.trim()}`;\n        }\n        return `urn:catalog:${this.specimen.institutionCode.trim()}::${this.specimen.catalogNumber.trim()}`;\n      }\n      if (has(this.specimen, 'collectionCode')) {\n        return `urn:catalog::${this.specimen.collectionCode.trim()}:${this.specimen.catalogNumber.trim()}`;\n      }\n      return `urn:catalog:::${this.specimen.catalogNumber.trim()}`;\n    }\n\n    // None of our specimen identifier schemes worked.\n    return undefined;\n  }\n\n  /**\n   * Return the basis of record, if one is present.\n   */\n  get basisOfRecord() {\n    if (has(this.specimen, 'dwc:basisOfRecord')) return this.specimen['dwc:basisOfRecord'];\n    return undefined;\n  }\n\n  /**\n   * Set the basis of record. See http://rs.tdwg.org/dwc/terms/basisOfRecord for\n   * recommended values.\n   */\n  set basisOfRecord(bor) {\n    this.specimen['dwc:basisOfRecord'] = bor;\n  }\n\n  /** Return this specimen as a taxon concept if it contains taxon name information. */\n  get taxonConcept() {\n    if (has(this.specimen, 'hasName')) return this.specimen;\n    if (has(this.specimen, 'nameString')) return this.specimen;\n    return undefined;\n  }\n\n  /** Return a label for this specimen. */\n  get label() {\n    // We can't return anything without an occurrenceID.\n    if (!this.occurrenceID) return undefined;\n\n    // Note that specimens may be identified to a taxon concept. If so, we should\n    // include that information in the label.\n    if (this.taxonConcept) {\n      return `Specimen ${this.occurrenceID} identified as ${new TaxonConceptWrapper(this.taxonConcept).label}`;\n    }\n\n    // Return a label for this specimen.\n    return `Specimen ${this.occurrenceID}`;\n  }\n\n  /** Return this specimen as an equivalentClass expression. */\n  get asOWLEquivClass() {\n    // We can't do anything without an occurrence ID!\n    if (!this.occurrenceID) return undefined;\n\n    // TODO: Should we also match by this.taxonConcept is one is available?\n    // Technically no, but it might be useful. Hmm.\n\n    // Return as an OWL restriction.\n    return {\n      '@type': 'owl:Restriction',\n      onProperty: owlterms.DWC_OCCURRENCE_ID,\n      hasValue: this.occurrenceID,\n    };\n  }\n}\n\nmodule.exports = {\n  SpecimenWrapper,\n};\n",
    "static": true,
    "longname": "/home/runner/work/phyx.js/phyx.js/src/wrappers/SpecimenWrapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 137,
    "kind": "variable",
    "name": "has",
    "memberof": "src/wrappers/SpecimenWrapper.js",
    "static": true,
    "longname": "src/wrappers/SpecimenWrapper.js~has",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/SpecimenWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 138,
    "kind": "variable",
    "name": "TaxonConceptWrapper",
    "memberof": "src/wrappers/SpecimenWrapper.js",
    "static": true,
    "longname": "src/wrappers/SpecimenWrapper.js~TaxonConceptWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/SpecimenWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 139,
    "kind": "variable",
    "name": "PhyxCacheManager",
    "memberof": "src/wrappers/SpecimenWrapper.js",
    "static": true,
    "longname": "src/wrappers/SpecimenWrapper.js~PhyxCacheManager",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/SpecimenWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 140,
    "kind": "class",
    "name": "SpecimenWrapper",
    "memberof": "src/wrappers/SpecimenWrapper.js",
    "static": true,
    "longname": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper",
    "access": "public",
    "export": true,
    "importPath": "@phyloref/phyx/src/wrappers/SpecimenWrapper.js",
    "importStyle": "{SpecimenWrapper}",
    "description": "The SpecimenWrapper wraps specimen taxonomic units. These can be identified\nwith a '@type' of SpecimenWrapper.TYPE_SPECIMEN (which is currently\nhttps://dwc.tdwg.org/terms/#occurrence).\n\n- TaxonomicUnitWrapper.TYPE_SPECIMEN: A specimen.\n   - Based on http://rs.tdwg.org/dwc/terms/Occurrence\n   - Should have a dwc:occurrenceID with the occurrence identifier.\n   - Should have a dwc:basisOfRecord to indicate what sort of occurrence this is.\n\nSince TaxonNameWrapper follows the TDWG ontology, we'd love to do the same for\nSpecimenWrapper, but unfortunately the TaxonOccurrence ontology has been deprecated\n(see https://github.com/tdwg/ontology). Therefore, it instead improvises a\nrepresentation based on dwc:Occurrence.",
    "lineNumber": 24,
    "interface": false
  },
  {
    "__docId__": 141,
    "kind": "get",
    "name": "TYPE_SPECIMEN",
    "memberof": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper.TYPE_SPECIMEN",
    "access": "public",
    "description": "The '@type' of specimens in JSON-LD document.",
    "lineNumber": 26,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 142,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper#constructor",
    "access": "public",
    "description": "Construct a wrapper around a specimen.",
    "lineNumber": 31
  },
  {
    "__docId__": 143,
    "kind": "member",
    "name": "specimen",
    "memberof": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper",
    "static": false,
    "longname": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper#specimen",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 144,
    "kind": "method",
    "name": "fromOccurrenceID",
    "memberof": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper.fromOccurrenceID",
    "access": "public",
    "description": "Parse the provided occurrence ID. The two expected formats are:\n - 'urn:catalog:[institutionCode]:[collectionCode]:[catalogNumber]'\n     (in which case, we ignore the first two \"components\" here)\n - '[institutionCode]:[collectionCode]:[catalogNumber]'",
    "lineNumber": 41,
    "params": [
      {
        "name": "occurrenceID",
        "types": [
          "*"
        ]
      },
      {
        "name": "basisOfRecord",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "PreservedSpecimen",
        "defaultValue": "PreservedSpecimen"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 145,
    "kind": "get",
    "name": "catalogNumber",
    "memberof": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper#catalogNumber",
    "access": "public",
    "description": "Get the catalogNumber if present.",
    "lineNumber": 93,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 146,
    "kind": "get",
    "name": "institutionCode",
    "memberof": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper#institutionCode",
    "access": "public",
    "description": "Get the institutionCode if present.",
    "lineNumber": 109,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 147,
    "kind": "get",
    "name": "collectionCode",
    "memberof": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper#collectionCode",
    "access": "public",
    "description": "Get the collectionCode if present.",
    "lineNumber": 125,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 148,
    "kind": "get",
    "name": "occurrenceID",
    "memberof": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper#occurrenceID",
    "access": "public",
    "description": "Return the occurrence ID of this specimen, if we have one. Otherwise, we\nattempt to construct one in the form:\n \"urn:catalog:\" + institutionCode (if present) + ':' +\n collectionCode (if present) + ':' + catalogNumber (if present)",
    "lineNumber": 144,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 149,
    "kind": "get",
    "name": "basisOfRecord",
    "memberof": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper#basisOfRecord",
    "access": "public",
    "description": "Return the basis of record, if one is present.",
    "lineNumber": 171,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 150,
    "kind": "set",
    "name": "basisOfRecord",
    "memberof": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper#basisOfRecord",
    "access": "public",
    "description": "Set the basis of record. See http://rs.tdwg.org/dwc/terms/basisOfRecord for\nrecommended values.",
    "lineNumber": 180
  },
  {
    "__docId__": 151,
    "kind": "get",
    "name": "taxonConcept",
    "memberof": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper#taxonConcept",
    "access": "public",
    "description": "Return this specimen as a taxon concept if it contains taxon name information.",
    "lineNumber": 185,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 152,
    "kind": "get",
    "name": "label",
    "memberof": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper#label",
    "access": "public",
    "description": "Return a label for this specimen.",
    "lineNumber": 192,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 153,
    "kind": "get",
    "name": "asOWLEquivClass",
    "memberof": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/SpecimenWrapper.js~SpecimenWrapper#asOWLEquivClass",
    "access": "public",
    "description": "Return this specimen as an equivalentClass expression.",
    "lineNumber": 207,
    "type": {
      "types": [
        "{\"@type\": string, \"onProperty\": *, \"hasValue\": *}"
      ]
    }
  },
  {
    "__docId__": 154,
    "kind": "file",
    "name": "src/wrappers/TaxonConceptWrapper.js",
    "content": "/** Utility functions. */\nconst { has } = require('lodash');\n\n/** List of OWL/RDF terms we use. */\nconst owlterms = require('../utils/owlterms');\n\n/** For parsing scientific names. */\nconst { TaxonNameWrapper } = require('./TaxonNameWrapper');\n\n/**\n * The TaxonConceptWrapper wraps taxon concepts. These are taxonomic units with\n * a type of TaxonomicUnitWrapper.TYPE_TAXON_CONCEPT. They are based on the\n * Taxon Concept ontology at https://github.com/tdwg/ontology/tree/master/ontology/voc.\n *\n * A taxon concept:\n *    - SHOULD have a hasName property indicating the name this taxon refers to.\n *    - MAY have accordingTo, describedBy or circumscribedBy to indicate how this\n *      taxon concept should be circumscribed. If none of these are present,\n *      this taxonomic unit will be considered a taxon rather than a taxon concept\n *      (i.e. as a nominal taxon concept, as in https://github.com/darwin-sw/dsw/wiki/ClassTaxon).\n *    - MAY have nameString and accordingToString properties. We will fall back\n *      to these properties if hasName or accordingTo are missing.\n */\n\nclass TaxonConceptWrapper {\n  /** The @type of a taxon or taxon concept. */\n  static get TYPE_TAXON_CONCEPT() {\n    return owlterms.TDWG_VOC_TAXON_CONCEPT;\n  }\n\n  /** Create a TaxonConceptWrapper around a taxon concept. */\n  constructor(tunit, defaultNomenCode = owlterms.UNKNOWN_CODE) {\n    this.tunit = tunit;\n    this.defaultNomenCode = defaultNomenCode;\n  }\n\n  /**\n   * Return the taxon name of this taxon concept (if any) as an object.\n   */\n  get taxonName() {\n    // Do we have any names as taxon name objects?\n    if (has(this.tunit, 'hasName')) return this.tunit.hasName;\n\n    // Do we have a nameString with a taxon name as string?\n    if (has(this.tunit, 'nameString')) return TaxonNameWrapper.fromVerbatimName(this.tunit.nameString);\n\n    // If not, we have no name!\n    return undefined;\n  }\n\n  /**\n   * Return the complete taxon name of this taxon concept (if any), which is the\n   * uninomial, binomial or trinomial name.\n   */\n  get nameComplete() {\n    // Do we have any names as taxon name objects?\n    if (has(this.tunit, 'hasName')) return new TaxonNameWrapper(this.tunit.hasName).nameComplete;\n\n    // Do we have a nameString with a taxon name as string?\n    if (has(this.tunit, 'nameString')) return TaxonNameWrapper.fromVerbatimName(this.tunit.nameString).nameComplete;\n\n    // If not, we have no name!\n    return undefined;\n  }\n\n  /**\n   * Return the nomenclatural code of this taxon concept as a string.\n   */\n  get nomenCode() {\n    if (has(this.tunit, 'hasName')) return new TaxonNameWrapper(this.tunit.hasName).nomenclaturalCode;\n\n    return undefined;\n  }\n\n  /**\n   * Return the nomenclatural code of this taxon concept as an object.\n   */\n  get nomenCodeDetails() {\n    if (has(this.tunit, 'hasName')) return new TaxonNameWrapper(this.tunit.hasName).nomenclaturalCodeDetails;\n\n    return undefined;\n  }\n\n  /**\n   * Return the accordingTo information (if any) as an object.\n   *\n   * For now, we return this verbatim. Once we close #15, we should parse raw labels\n   * with a CitationWrapper.\n   */\n  get accordingTo() {\n    // Do we have any accordingTo information?\n    if (has(this.tunit, 'accordingTo')) return this.type.accordingTo;\n\n    // Do we have an accordingToString?\n    if (has(this.tunit, 'accordingToString')) return this.type.accordingToString;\n\n    // If not, we have no accodingTo information!\n    return undefined;\n  }\n\n  /**\n   * Return the accordingTo information (if any) as a string.\n   *\n   * For now, we stringify objects by converting them into JSON strings. Once we\n   * close #15, we will be able to generate a label using CitationWrapper.\n   */\n  get accordingToString() {\n    // Do we have any accordingTo information?\n    if (has(this.tunit, 'accordingTo')) return JSON.stringify(this.type.accordingTo);\n\n    // Do we have an accordingToString?\n    if (has(this.tunit, 'accordingToString')) return this.type.accordingToString;\n\n    // If not, we have no accodingTo information!\n    return undefined;\n  }\n\n  /**\n   * Return the label of this taxon concept.\n   */\n  get label() {\n    // If we're wrapping a taxonName, use its label.\n    if (this.taxonName) {\n      // Do we also have accordingTo information?\n      if (this.accordingToString) {\n        return `${new TaxonNameWrapper(this.taxonName).label} sensu ${this.accordingToString}`;\n      }\n\n      return new TaxonNameWrapper(this.taxonName).label;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Given a node label, attempt to parse it as a scientific name.\n   *\n   * Note that this is NOT memoized -- you should really be using\n   * TaxonomicUnitWrapper.fromLabel() or TaxonNameWrapper.fromVerbatimName() rather\n   * than calling this directly.\n   *\n   * @return A taxonomic unit that corresponds to this taxon concept.\n   */\n  static fromLabel(nodeLabel, nomenCode) {\n    if (nodeLabel === undefined || nodeLabel === null || nodeLabel.trim() === '') return undefined;\n\n    // Check if this label can be divided into a name and a sensu/sec component.\n    const match = /^\\s*(.*)\\s+(?:sec|sensu)\\.?\\s+(.*)\\s*$/.exec(nodeLabel);\n    let accordingTo;\n    if (match) {\n      accordingTo = match[2];\n    }\n\n    // Can we parse it as a taxon name? If not, we will return undefined.\n    const taxonName = TaxonNameWrapper.fromVerbatimName(nodeLabel, nomenCode);\n    if (taxonName) {\n      return TaxonConceptWrapper.wrapTaxonName(taxonName, accordingTo);\n    }\n\n    // Couldn't parse it at all.\n    return undefined;\n  }\n\n  /** Wrap a taxon name with a particular TaxonName object and an accordingTo (string). */\n  static wrapTaxonName(taxonName, accordingTo) {\n    const result = {\n      '@type': TaxonConceptWrapper.TYPE_TAXON_CONCEPT,\n      hasName: taxonName,\n    };\n    if (accordingTo) result.accordingTo = accordingTo;\n    return result;\n  }\n\n  /**\n   * Return how this class should look in an OWL equivalentClass expression.\n   *\n   * Note that we don't include the accordingTo information in this\n   * query, since we don't have a useful way to use that during OWL reasoning.\n   */\n  get asOWLEquivClass() {\n    // Without a taxonomicName, we can't do anything.\n    if (!this.taxonName) return undefined;\n\n    return {\n      '@type': 'owl:Restriction',\n      onProperty: owlterms.TDWG_VOC_HAS_NAME,\n      someValuesFrom: new TaxonNameWrapper(this.taxonName, this.defaultNomenCode).asOWLEquivClass,\n    };\n  }\n}\n\nmodule.exports = {\n  TaxonConceptWrapper,\n};\n",
    "static": true,
    "longname": "/home/runner/work/phyx.js/phyx.js/src/wrappers/TaxonConceptWrapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 155,
    "kind": "variable",
    "name": "has",
    "memberof": "src/wrappers/TaxonConceptWrapper.js",
    "static": true,
    "longname": "src/wrappers/TaxonConceptWrapper.js~has",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/TaxonConceptWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 156,
    "kind": "variable",
    "name": "TaxonNameWrapper",
    "memberof": "src/wrappers/TaxonConceptWrapper.js",
    "static": true,
    "longname": "src/wrappers/TaxonConceptWrapper.js~TaxonNameWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/TaxonConceptWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 157,
    "kind": "class",
    "name": "TaxonConceptWrapper",
    "memberof": "src/wrappers/TaxonConceptWrapper.js",
    "static": true,
    "longname": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper",
    "access": "public",
    "export": true,
    "importPath": "@phyloref/phyx/src/wrappers/TaxonConceptWrapper.js",
    "importStyle": "{TaxonConceptWrapper}",
    "description": "The TaxonConceptWrapper wraps taxon concepts. These are taxonomic units with\na type of TaxonomicUnitWrapper.TYPE_TAXON_CONCEPT. They are based on the\nTaxon Concept ontology at https://github.com/tdwg/ontology/tree/master/ontology/voc.\n\nA taxon concept:\n   - SHOULD have a hasName property indicating the name this taxon refers to.\n   - MAY have accordingTo, describedBy or circumscribedBy to indicate how this\n     taxon concept should be circumscribed. If none of these are present,\n     this taxonomic unit will be considered a taxon rather than a taxon concept\n     (i.e. as a nominal taxon concept, as in https://github.com/darwin-sw/dsw/wiki/ClassTaxon).\n   - MAY have nameString and accordingToString properties. We will fall back\n     to these properties if hasName or accordingTo are missing.",
    "lineNumber": 27,
    "interface": false
  },
  {
    "__docId__": 158,
    "kind": "get",
    "name": "TYPE_TAXON_CONCEPT",
    "memberof": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper.TYPE_TAXON_CONCEPT",
    "access": "public",
    "description": "The @type of a taxon or taxon concept.",
    "lineNumber": 29,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 159,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper#constructor",
    "access": "public",
    "description": "Create a TaxonConceptWrapper around a taxon concept.",
    "lineNumber": 34
  },
  {
    "__docId__": 160,
    "kind": "member",
    "name": "tunit",
    "memberof": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper",
    "static": false,
    "longname": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper#tunit",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 161,
    "kind": "member",
    "name": "defaultNomenCode",
    "memberof": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper",
    "static": false,
    "longname": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper#defaultNomenCode",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 162,
    "kind": "get",
    "name": "taxonName",
    "memberof": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper#taxonName",
    "access": "public",
    "description": "Return the taxon name of this taxon concept (if any) as an object.",
    "lineNumber": 42,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 163,
    "kind": "get",
    "name": "nameComplete",
    "memberof": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper#nameComplete",
    "access": "public",
    "description": "Return the complete taxon name of this taxon concept (if any), which is the\nuninomial, binomial or trinomial name.",
    "lineNumber": 57,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 164,
    "kind": "get",
    "name": "nomenCode",
    "memberof": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper#nomenCode",
    "access": "public",
    "description": "Return the nomenclatural code of this taxon concept as a string.",
    "lineNumber": 71,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 165,
    "kind": "get",
    "name": "nomenCodeDetails",
    "memberof": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper#nomenCodeDetails",
    "access": "public",
    "description": "Return the nomenclatural code of this taxon concept as an object.",
    "lineNumber": 80,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 166,
    "kind": "get",
    "name": "accordingTo",
    "memberof": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper#accordingTo",
    "access": "public",
    "description": "Return the accordingTo information (if any) as an object.\n\nFor now, we return this verbatim. Once we close #15, we should parse raw labels\nwith a CitationWrapper.",
    "lineNumber": 92,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 167,
    "kind": "get",
    "name": "accordingToString",
    "memberof": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper#accordingToString",
    "access": "public",
    "description": "Return the accordingTo information (if any) as a string.\n\nFor now, we stringify objects by converting them into JSON strings. Once we\nclose #15, we will be able to generate a label using CitationWrapper.",
    "lineNumber": 109,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 168,
    "kind": "get",
    "name": "label",
    "memberof": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper#label",
    "access": "public",
    "description": "Return the label of this taxon concept.",
    "lineNumber": 123,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 169,
    "kind": "method",
    "name": "fromLabel",
    "memberof": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper.fromLabel",
    "access": "public",
    "description": "Given a node label, attempt to parse it as a scientific name.\n\nNote that this is NOT memoized -- you should really be using\nTaxonomicUnitWrapper.fromLabel() or TaxonNameWrapper.fromVerbatimName() rather\nthan calling this directly.",
    "lineNumber": 146,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "A taxonomic unit that corresponds to this taxon concept."
    },
    "params": [
      {
        "name": "nodeLabel",
        "types": [
          "*"
        ]
      },
      {
        "name": "nomenCode",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 170,
    "kind": "method",
    "name": "wrapTaxonName",
    "memberof": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper.wrapTaxonName",
    "access": "public",
    "description": "Wrap a taxon name with a particular TaxonName object and an accordingTo (string).",
    "lineNumber": 167,
    "params": [
      {
        "name": "taxonName",
        "types": [
          "*"
        ]
      },
      {
        "name": "accordingTo",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 171,
    "kind": "get",
    "name": "asOWLEquivClass",
    "memberof": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonConceptWrapper.js~TaxonConceptWrapper#asOWLEquivClass",
    "access": "public",
    "description": "Return how this class should look in an OWL equivalentClass expression.\n\nNote that we don't include the accordingTo information in this\nquery, since we don't have a useful way to use that during OWL reasoning.",
    "lineNumber": 182,
    "type": {
      "types": [
        "{\"@type\": string, \"onProperty\": *, \"someValuesFrom\": *}"
      ]
    }
  },
  {
    "__docId__": 172,
    "kind": "file",
    "name": "src/wrappers/TaxonNameWrapper.js",
    "content": "/** Utility functions. */\nconst { has, cloneDeep, isArray } = require('lodash');\n\n/** OWL/RDF terms. */\nconst owlterms = require('../utils/owlterms');\n\n/** We need the cache manager to memoize parsing scientific names. */\nconst { PhyxCacheManager } = require('../utils/PhyxCacheManager');\n\n/**\n * Wraps a taxon name to provide access to components of\n * the taxon name. This is based on the TDWG TaxonName standard, as at\n * https://github.com/tdwg/ontology/blob/master/ontology/voc/TaxonName.rdf.\n *\n * Every instance of this class is expected to have some combination of the\n * following fields:\n *  - rdfs:label -- the verbatim taxon name\n *  - nameComplete -- the complete uninomial, binomial or trinomial name.\n *  - nomenclaturalCode -- the nomenclatural code under which the complete name\n *    should be interpreted.\n *\n * We will also read the following fields if they are present:\n *  - uninomial: The uninomial name of this taxon, if one is present.\n *  - genusPart: The genus name.\n *  - specificEpithet: The specific epithet.\n *  - infraspecificEpithet: The infraspecific epithet.\n *\n * We wrap whatever we're given, so we won't assume that these fields are actually\n * consistent with each other. However, when one of these fields are set, we\n * overwrite the nameComplete to ensure that they are consistent. Similarly,\n * changing the nameComplete will overwrite the genusPart, specificEpithet and\n * infraspecificEpithet.\n *\n * Note that the TaxonName ontology recommends dc:title instead of rdfs:label;\n * however, I like the idea of using dc:title for documents and rdfs:label for\n * vocabulary terms, so I'm okay with using rdfs:label for the verbatim name.\n */\nclass TaxonNameWrapper {\n  /**\n   * Create a new taxon name wrapper around the JSON representation of\n   * a taxon name.\n   */\n  constructor(txname, defaultNomenCode = owlterms.UNKNOWN_CODE) {\n    if (txname === undefined) throw new Error('TaxonNameWrapper tried to wrap undefined');\n    this.txname = txname;\n    this.defaultNomenCode = defaultNomenCode;\n  }\n\n  /**\n   * The type associated with these taxonName objects.\n   */\n  static get TYPE_TAXON_NAME() {\n    return owlterms.TDWG_VOC_TAXON_NAME;\n  }\n\n  /**\n   * The IRI for an unknown nomenclatural code (i.e. all we know is that it's a scientific name).\n   */\n  static get UNKNOWN_CODE() {\n    return owlterms.UNKNOWN_CODE;\n  }\n\n  /* Directly access IRIs for nomenclatural codes. */\n  static get ICZN_CODE() { return owlterms.ICZN_CODE; }\n\n  static get ICN_CODE() { return owlterms.ICN_CODE; }\n\n  static get ICNP_CODE() { return owlterms.ICNP_CODE; }\n\n  static get ICTV_CODE() { return owlterms.ICTV_CODE; }\n\n  static get ICNCP_CODE() { return owlterms.ICNCP_CODE; }\n\n  /**\n   * Return a list of all supported nomenclatural code. Each entry will have\n   * the following keys:\n   *  - code: A list of short names that can be used to represent this nomenclatural code.\n   *  - label: An informal name of this nomenclatural code in English.\n   *  - title: The formal name of this nomenclatural code in English.\n   *  - iri: The IRI of this nomenclatural code.\n   *\n   * This will be used in drawing user interfaces, so this should be in order\n   * of likelihood of use.\n   */\n  static getNomenclaturalCodes() {\n    return [\n      {\n        iri: owlterms.ICZN_CODE,\n        shortName: 'ICZN',\n        label: 'Animals (ICZN)',\n        title: 'International Code of Zoological Nomenclature',\n      },\n      {\n        iri: owlterms.ICN_CODE,\n        shortName: 'ICN',\n        label: 'Algae, fungi and plants (ICN, previously ICBN)',\n        title: 'International Code of Nomenclature for algae, fungi, and plants',\n      },\n      {\n        iri: owlterms.ICNP_CODE,\n        shortName: 'ICNP',\n        label: 'Prokaryotes (ICNP)',\n        title: 'International Code of Nomenclature of Prokaryotes',\n      },\n      {\n        iri: owlterms.ICTV_CODE,\n        shortName: 'ICTV',\n        label: 'Viruses (ICTV)',\n        title: 'International Committee on Taxonomy of Viruses',\n      },\n      {\n        iri: owlterms.ICNCP_CODE,\n        shortName: 'ICNCP',\n        label: 'Cultivated plants (ICNCP)',\n        title: 'International Code of Cultivated Plants',\n      },\n      {\n        iri: owlterms.UNKNOWN_CODE,\n        shortName: 'Code not known',\n        label: 'Nomenclatural code not known',\n        title: 'Nomenclatural code not known',\n      },\n    ];\n  }\n\n  /**\n   * Returns the nomenclatural code entry for a code.\n   */\n  static getNomenCodeDetails(nomenCode) {\n    const codes = TaxonNameWrapper.getNomenclaturalCodes();\n\n    // Look for the entry with the same IRI as the provided IRI.\n    const matchingCode = codes\n      .find(code => code.iri.toLowerCase() === nomenCode.toLowerCase());\n    if (matchingCode) return matchingCode;\n    return undefined;\n  }\n\n  /**\n   * Returns the nomenclatural code of this taxon name.\n   */\n  get nomenclaturalCode() {\n    return this.txname.nomenclaturalCode || this.defaultNomenCode;\n  }\n\n  /**\n   * Returns the nomenclatural code of this taxon name as a IRI.\n   */\n  get nomenclaturalCodeDetails() {\n    const nomenCode = this.nomenclaturalCode;\n    if (!nomenCode) return undefined;\n\n    const nomenObj = TaxonNameWrapper.getNomenCodeDetails(nomenCode);\n    if (!nomenObj) return undefined;\n\n    return nomenObj;\n  }\n\n  /**\n   * Set the nomenclatural code of this taxon name.\n   */\n  set nomenclaturalCode(nomenCode) {\n    this.txname.nomenclaturalCode = nomenCode;\n  }\n\n  /**\n   * Parses a verbatim taxon name into an (unwrapped) TaxonName.\n   */\n  static fromVerbatimName(verbatimName, nomenCode = owlterms.UNKNOWN_CODE) {\n    // Have we already parsed this verbatim name?\n    if (PhyxCacheManager.has(`TaxonNameWrapper.taxonNameCache.${nomenCode}`, verbatimName)) {\n      return PhyxCacheManager.get(`TaxonNameWrapper.taxonNameCache.${nomenCode}`, verbatimName);\n    }\n\n    // Use a regular expression to parse the verbatimName.\n\n    // Attempt 1. Look for a trinomial name.\n    let txname;\n    let results = /^([A-Z][a-z]+)[ _]([a-z-]+\\.?)(?:\\b|_)\\s*([a-z-]+)\\b/.exec(verbatimName);\n\n    if (results) {\n      txname = {\n        '@type': TaxonNameWrapper.TYPE_TAXON_NAME,\n        label: verbatimName,\n        nameComplete: `${results[1]} ${results[2]} ${results[3]}`.trim(),\n        genusPart: results[1],\n        specificEpithet: results[2],\n        infraspecificEpithet: results[3],\n      };\n    }\n\n    // Attempt 2. Look for a binomial name.\n    if (!txname) {\n      results = /^([A-Z][a-z]+)[ _]([a-z-]+\\.?)(?:\\b|_)/.exec(verbatimName);\n\n      if (results) {\n        txname = {\n          '@type': TaxonNameWrapper.TYPE_TAXON_NAME,\n          label: verbatimName,\n          nameComplete: `${results[1]} ${results[2]}`.trim(),\n          genusPart: results[1],\n          specificEpithet: results[2],\n        };\n      }\n    }\n\n    // Attempt 3. Look for a uninomial name.\n    if (!txname) {\n      // Is it a uninomial name?\n      results = /^([A-Z][a-z]+)(?:[_\\s]|\\b)/.exec(verbatimName);\n      if (results) {\n        txname = {\n          '@type': TaxonNameWrapper.TYPE_TAXON_NAME,\n          label: verbatimName,\n          nameComplete: results[1],\n          uninomial: results[1],\n        };\n      }\n    }\n\n    // Add a nomenclatural code if possible.\n    if (txname && nomenCode) {\n      txname.nomenclaturalCode = nomenCode;\n    }\n\n    // Store in the cache.\n    if (txname !== undefined) {\n      PhyxCacheManager.put(`TaxonNameWrapper.taxonNameCache.${nomenCode}`, verbatimName, txname);\n    }\n\n    return txname;\n  }\n\n  /**\n   * Return the label of this scientific name.\n   */\n  get label() {\n    return this.txname.label || this.nameComplete;\n  }\n\n  /**\n   * Set the label of this scientific name.\n   */\n  set label(lab) {\n    this.txname.label = lab;\n    if (!this.nameComplete) {\n      // If we don't have a nameComplete, treat this as the name complete.\n      this.nameComplete = lab;\n    }\n  }\n\n  /**\n   * Return the verbatim name of this taxon name.\n   */\n  get verbatimName() {\n    return this.txname.label;\n  }\n\n  /*\n   * Return the complete name (i.e. the uninomial, binomial or trinomial name\n   * without authority information).\n   */\n  get nameComplete() {\n    return this.txname.nameComplete\n      || this.trinomialName\n      || this.binomialName\n      || this.uninomialName;\n  }\n\n  /**\n   * Set the complete name. To do this, we re-parse the provided name.\n   */\n  set nameComplete(name) {\n    this.txname = TaxonNameWrapper.fromVerbatimName(name, this.nomenclaturalCode);\n  }\n\n  /** Return the uninomial name if there is one. */\n  get uninomial() {\n    if (this.txname.uninomial) return this.txname.uninomial;\n\n    // If there is no genus but there is a scientificName, try to extract a genus\n    // from it.\n    if (this.txname.nameComplete) {\n      const txname = TaxonNameWrapper.fromVerbatimName(\n        this.txname.nameComplete,\n        this.nomenclaturalCode\n      );\n      if (has(txname, 'uninomial')) return txname.uninomial;\n    }\n\n    return undefined;\n  }\n\n  /** Set the uninomial name. */\n  set uninomial(uninom) {\n    this.txname.uninomial = uninom;\n    this.txname.nameComplete = uninom;\n  }\n\n  /** Return the binomial name if available. */\n  get binomialName() {\n    // Get the binomial name. Constructed from the genus and specific epithet\n    // if available.\n    if (this.genusPart === undefined || this.specificEpithet === undefined) return undefined;\n    return `${this.genusPart} ${this.specificEpithet}`;\n  }\n\n  /** Set the binomial name. */\n  set binomialName(binom) {\n    this.txname.uninomial = undefined;\n    this.txname.nameComplete = binom;\n  }\n\n  /** Return the trinomial name if available. */\n  get trinomialName() {\n    if (\n      this.infraspecificEpithet === undefined\n      || this.specificEpithet === undefined\n      || this.genusPart === undefined\n    ) return undefined;\n    return `${this.genusPart} ${this.specificEpithet} ${this.infraspecificEpithet}`;\n  }\n\n  /** Set the trinomial name. */\n  set trinomialName(trinom) {\n    this.txname.uninomial = undefined;\n    this.txname.nameComplete = trinom;\n  }\n\n  /** Return the genus part of this scientific name if available. */\n  get genusPart() {\n    // Try to read the genus if available.\n    if (has(this.txname, 'genusPart')) return this.txname.genusPart;\n\n    // If there is no genus but there is a scientificName, try to extract a genus\n    // from it.\n    if (this.txname.nameComplete) {\n      const txname = TaxonNameWrapper.fromVerbatimName(\n        this.txname.nameComplete,\n        this.nomenclaturalCode\n      );\n      if (has(txname, 'genusPart')) return txname.genusPart;\n    }\n\n    return undefined;\n  }\n\n  /** Set the genus part of this name. */\n  set genusPart(genus) {\n    this.txname.genusPart = genus;\n    if (this.specificEpithet) {\n      if (this.infraspecificEpithet) {\n        this.txname.nameComplete = `${genus} ${this.specificEpithet} ${this.infraspecificEpithet}`;\n      } else {\n        this.txname.nameComplete = `${genus} ${this.specificEpithet}`;\n      }\n    }\n  }\n\n  /** Return the specific epithet of this scientific name if available. */\n  get specificEpithet() {\n    // Try to read the specific epithet if available.\n    if (has(this.txname, 'specificEpithet')) return this.txname.specificEpithet;\n\n    // If there is no specific epithet but there is a scientificName, try to\n    // extract a specific epithet from it.\n    if (this.nameComplete) {\n      const txname = TaxonNameWrapper.fromVerbatimName(\n        this.nameComplete,\n        this.nomenclaturalCode\n      );\n      if (has(txname, 'specificEpithet')) return txname.specificEpithet;\n    }\n\n    return undefined;\n  }\n\n  /** Set the specificEpithet part of this name. */\n  set specificEpithet(epithet) {\n    this.txname.specificEpithet = epithet;\n    if (this.genusPart) {\n      if (this.infraspecificEpithet) {\n        this.txname.nameComplete = `${this.genusPart} ${epithet} ${this.infraspecificEpithet}`;\n      } else {\n        this.txname.nameComplete = `${this.genusPart} ${epithet}`;\n      }\n    }\n  }\n\n  /** Return the infraspecific epithet of this scientific name if available. */\n  get infraspecificEpithet() {\n    // Try to read the specific epithet if available.\n    if (has(this.txname, 'infraspecificEpithet')) return this.txname.infraspecificEpithet;\n\n    // If there is no specific epithet but there is a scientificName, try to\n    // extract a specific epithet from it.\n    if (this.txname.nameComplete) {\n      const txname = TaxonNameWrapper.fromVerbatimName(\n        this.nameComplete,\n        this.nomenclaturalCode\n      );\n      if (has(txname, 'infraspecificEpithet')) return txname.infraspecificEpithet;\n    }\n\n    return undefined;\n  }\n\n  /** Set the infraspecificEpithet part of this name. */\n  set infraspecificEpithet(epithet) {\n    this.txname.infraspecificEpithet = epithet;\n    if (this.genusPart) {\n      if (this.specificEpithet) {\n        this.txname.nameComplete = `${this.genusPart} ${this.specificEpithet} ${epithet}`;\n      } else {\n        this.txname.nameComplete = `${this.genusPart} sp. ${epithet}`;\n      }\n    }\n  }\n\n  /**\n   * Return this taxon name in an JSON-LD representation.\n   */\n  get asJSONLD() {\n    const jsonld = cloneDeep(this.txname);\n\n    // Make sure '@type' is an array.\n    if (!has(jsonld, '@type')) jsonld['@type'] = [];\n    if (!isArray(jsonld['@type'])) jsonld['@type'] = [jsonld['@type']];\n\n    // Make it explicit that the type includes the nomenclaturalCode.\n    const nomenCode = this.nomenclaturalCode;\n    if (!jsonld['@type'].includes(nomenCode)) jsonld['@type'].push(nomenCode);\n\n    return jsonld;\n  }\n\n  /**\n   * Return this taxon name as an OWL equivalentClass expression.\n   */\n  get asOWLEquivClass() {\n    // No complete name, can't return anything.\n    if (!this.nameComplete) return undefined;\n\n    // Do we have a nomenclaturalCode?\n    if (!this.nomenclaturalCode) {\n      return {\n        '@type': 'owl:Restriction',\n        onProperty: owlterms.TDWG_VOC_NAME_COMPLETE,\n        hasValue: this.nameComplete,\n      };\n    }\n\n    // If we do have a nomenclatural code, incorporate that into the logical\n    // expression as well.\n    return {\n      '@type': 'owl:Class',\n      intersectionOf: [{\n        '@type': 'owl:Restriction',\n        onProperty: owlterms.TDWG_VOC_NAME_COMPLETE,\n        hasValue: this.nameComplete,\n      }, {\n        '@type': 'owl:Restriction',\n        onProperty: owlterms.NOMENCLATURAL_CODE,\n        hasValue: {\n          '@id': this.nomenclaturalCode,\n        },\n      }],\n    };\n  }\n}\n\nmodule.exports = {\n  TaxonNameWrapper,\n};\n",
    "static": true,
    "longname": "/home/runner/work/phyx.js/phyx.js/src/wrappers/TaxonNameWrapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 173,
    "kind": "variable",
    "name": "has",
    "memberof": "src/wrappers/TaxonNameWrapper.js",
    "static": true,
    "longname": "src/wrappers/TaxonNameWrapper.js~has",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/TaxonNameWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 174,
    "kind": "variable",
    "name": "PhyxCacheManager",
    "memberof": "src/wrappers/TaxonNameWrapper.js",
    "static": true,
    "longname": "src/wrappers/TaxonNameWrapper.js~PhyxCacheManager",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/TaxonNameWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 175,
    "kind": "class",
    "name": "TaxonNameWrapper",
    "memberof": "src/wrappers/TaxonNameWrapper.js",
    "static": true,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "access": "public",
    "export": true,
    "importPath": "@phyloref/phyx/src/wrappers/TaxonNameWrapper.js",
    "importStyle": "{TaxonNameWrapper}",
    "description": "Wraps a taxon name to provide access to components of\nthe taxon name. This is based on the TDWG TaxonName standard, as at\nhttps://github.com/tdwg/ontology/blob/master/ontology/voc/TaxonName.rdf.\n\nEvery instance of this class is expected to have some combination of the\nfollowing fields:\n - rdfs:label -- the verbatim taxon name\n - nameComplete -- the complete uninomial, binomial or trinomial name.\n - nomenclaturalCode -- the nomenclatural code under which the complete name\n   should be interpreted.\n\nWe will also read the following fields if they are present:\n - uninomial: The uninomial name of this taxon, if one is present.\n - genusPart: The genus name.\n - specificEpithet: The specific epithet.\n - infraspecificEpithet: The infraspecific epithet.\n\nWe wrap whatever we're given, so we won't assume that these fields are actually\nconsistent with each other. However, when one of these fields are set, we\noverwrite the nameComplete to ensure that they are consistent. Similarly,\nchanging the nameComplete will overwrite the genusPart, specificEpithet and\ninfraspecificEpithet.\n\nNote that the TaxonName ontology recommends dc:title instead of rdfs:label;\nhowever, I like the idea of using dc:title for documents and rdfs:label for\nvocabulary terms, so I'm okay with using rdfs:label for the verbatim name.",
    "lineNumber": 40,
    "interface": false
  },
  {
    "__docId__": 176,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#constructor",
    "access": "public",
    "description": "Create a new taxon name wrapper around the JSON representation of\na taxon name.",
    "lineNumber": 45
  },
  {
    "__docId__": 177,
    "kind": "member",
    "name": "txname",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#txname",
    "access": "public",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 178,
    "kind": "member",
    "name": "defaultNomenCode",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#defaultNomenCode",
    "access": "public",
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 179,
    "kind": "get",
    "name": "TYPE_TAXON_NAME",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper.TYPE_TAXON_NAME",
    "access": "public",
    "description": "The type associated with these taxonName objects.",
    "lineNumber": 54,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 180,
    "kind": "get",
    "name": "UNKNOWN_CODE",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper.UNKNOWN_CODE",
    "access": "public",
    "description": "The IRI for an unknown nomenclatural code (i.e. all we know is that it's a scientific name).",
    "lineNumber": 61,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 181,
    "kind": "get",
    "name": "ICZN_CODE",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper.ICZN_CODE",
    "access": "public",
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 182,
    "kind": "get",
    "name": "ICN_CODE",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper.ICN_CODE",
    "access": "public",
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 183,
    "kind": "get",
    "name": "ICNP_CODE",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper.ICNP_CODE",
    "access": "public",
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 184,
    "kind": "get",
    "name": "ICTV_CODE",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper.ICTV_CODE",
    "access": "public",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 185,
    "kind": "get",
    "name": "ICNCP_CODE",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper.ICNCP_CODE",
    "access": "public",
    "description": null,
    "lineNumber": 74,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 186,
    "kind": "method",
    "name": "getNomenclaturalCodes",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper.getNomenclaturalCodes",
    "access": "public",
    "description": "Return a list of all supported nomenclatural code. Each entry will have\nthe following keys:\n - code: A list of short names that can be used to represent this nomenclatural code.\n - label: An informal name of this nomenclatural code in English.\n - title: The formal name of this nomenclatural code in English.\n - iri: The IRI of this nomenclatural code.\n\nThis will be used in drawing user interfaces, so this should be in order\nof likelihood of use.",
    "lineNumber": 87,
    "params": [],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 187,
    "kind": "method",
    "name": "getNomenCodeDetails",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper.getNomenCodeDetails",
    "access": "public",
    "description": "Returns the nomenclatural code entry for a code.",
    "lineNumber": 131,
    "params": [
      {
        "name": "nomenCode",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 188,
    "kind": "get",
    "name": "nomenclaturalCode",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#nomenclaturalCode",
    "access": "public",
    "description": "Returns the nomenclatural code of this taxon name.",
    "lineNumber": 144,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 189,
    "kind": "get",
    "name": "nomenclaturalCodeDetails",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#nomenclaturalCodeDetails",
    "access": "public",
    "description": "Returns the nomenclatural code of this taxon name as a IRI.",
    "lineNumber": 151,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 190,
    "kind": "set",
    "name": "nomenclaturalCode",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#nomenclaturalCode",
    "access": "public",
    "description": "Set the nomenclatural code of this taxon name.",
    "lineNumber": 164
  },
  {
    "__docId__": 191,
    "kind": "method",
    "name": "fromVerbatimName",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper.fromVerbatimName",
    "access": "public",
    "description": "Parses a verbatim taxon name into an (unwrapped) TaxonName.",
    "lineNumber": 171,
    "params": [
      {
        "name": "verbatimName",
        "types": [
          "*"
        ]
      },
      {
        "name": "nomenCode",
        "optional": true,
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 192,
    "kind": "get",
    "name": "label",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#label",
    "access": "public",
    "description": "Return the label of this scientific name.",
    "lineNumber": 239,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 193,
    "kind": "set",
    "name": "label",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#label",
    "access": "public",
    "description": "Set the label of this scientific name.",
    "lineNumber": 246
  },
  {
    "__docId__": 195,
    "kind": "get",
    "name": "verbatimName",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#verbatimName",
    "access": "public",
    "description": "Return the verbatim name of this taxon name.",
    "lineNumber": 257,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 196,
    "kind": "get",
    "name": "nameComplete",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#nameComplete",
    "access": "public",
    "description": null,
    "lineNumber": 265,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 197,
    "kind": "set",
    "name": "nameComplete",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#nameComplete",
    "access": "public",
    "description": "Set the complete name. To do this, we re-parse the provided name.",
    "lineNumber": 275
  },
  {
    "__docId__": 199,
    "kind": "get",
    "name": "uninomial",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#uninomial",
    "access": "public",
    "description": "Return the uninomial name if there is one.",
    "lineNumber": 280,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 200,
    "kind": "set",
    "name": "uninomial",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#uninomial",
    "access": "public",
    "description": "Set the uninomial name.",
    "lineNumber": 297
  },
  {
    "__docId__": 201,
    "kind": "get",
    "name": "binomialName",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#binomialName",
    "access": "public",
    "description": "Return the binomial name if available.",
    "lineNumber": 303,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 202,
    "kind": "set",
    "name": "binomialName",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#binomialName",
    "access": "public",
    "description": "Set the binomial name.",
    "lineNumber": 311
  },
  {
    "__docId__": 203,
    "kind": "get",
    "name": "trinomialName",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#trinomialName",
    "access": "public",
    "description": "Return the trinomial name if available.",
    "lineNumber": 317,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 204,
    "kind": "set",
    "name": "trinomialName",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#trinomialName",
    "access": "public",
    "description": "Set the trinomial name.",
    "lineNumber": 327
  },
  {
    "__docId__": 205,
    "kind": "get",
    "name": "genusPart",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#genusPart",
    "access": "public",
    "description": "Return the genus part of this scientific name if available.",
    "lineNumber": 333,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 206,
    "kind": "set",
    "name": "genusPart",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#genusPart",
    "access": "public",
    "description": "Set the genus part of this name.",
    "lineNumber": 351
  },
  {
    "__docId__": 207,
    "kind": "get",
    "name": "specificEpithet",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#specificEpithet",
    "access": "public",
    "description": "Return the specific epithet of this scientific name if available.",
    "lineNumber": 363,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 208,
    "kind": "set",
    "name": "specificEpithet",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#specificEpithet",
    "access": "public",
    "description": "Set the specificEpithet part of this name.",
    "lineNumber": 381
  },
  {
    "__docId__": 209,
    "kind": "get",
    "name": "infraspecificEpithet",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#infraspecificEpithet",
    "access": "public",
    "description": "Return the infraspecific epithet of this scientific name if available.",
    "lineNumber": 393,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 210,
    "kind": "set",
    "name": "infraspecificEpithet",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#infraspecificEpithet",
    "access": "public",
    "description": "Set the infraspecificEpithet part of this name.",
    "lineNumber": 411
  },
  {
    "__docId__": 211,
    "kind": "get",
    "name": "asJSONLD",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#asJSONLD",
    "access": "public",
    "description": "Return this taxon name in an JSON-LD representation.",
    "lineNumber": 425,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 212,
    "kind": "get",
    "name": "asOWLEquivClass",
    "memberof": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonNameWrapper.js~TaxonNameWrapper#asOWLEquivClass",
    "access": "public",
    "description": "Return this taxon name as an OWL equivalentClass expression.",
    "lineNumber": 442,
    "type": {
      "types": [
        "{\"@type\": string, \"intersectionOf\": *}"
      ]
    }
  },
  {
    "__docId__": 213,
    "kind": "file",
    "name": "src/wrappers/TaxonomicUnitWrapper.js",
    "content": "/** Utility functions. */\nconst {\n  has,\n  isArray,\n  cloneDeep,\n  assign,\n} = require('lodash');\n\n/** List of OWL/RDF terms we use. */\nconst owlterms = require('../utils/owlterms');\n\n/** We store the taxonomic units we extract from phylogeny labels in the Phyx Cache Manager. */\nconst { PhyxCacheManager } = require('../utils/PhyxCacheManager');\n\n/** For parsing specimen identifiers. */\nconst { SpecimenWrapper } = require('./SpecimenWrapper');\n\n/** For parsing scientific names. */\nconst { TaxonConceptWrapper } = require('./TaxonConceptWrapper');\n\n/**\n * The TaxonomicUnitWrapper wraps taxonomic units, whether on a node or being used\n * as a specifier on a phyloreference. Every taxonomic unit can additionally be\n * wrapped by more specific classes, such as {@link TaxonConceptWrapper} or\n * {@link SpecimenWrapper}. We can determine which type it is based on its\n * '@type' and whether it includes:\n *  - TaxonomicUnitWrapper.TYPE_TAXON_CONCEPT => {@link TaxonConceptWrapper}\n *  - TaxonomicUnitWrapper.TYPE_SPECIMEN => {@link SpecimenWrapper}\n *  - TaxonomicUnitWrapper.TYPE_APOMORPHY => reserved for future use\n *  - TaxonomicUnitWrapper.TYPE_PHYLOREF => reserved for future use\n *\n * It also contains static methods for extracting\n * taxonomic units from arbitrary strings, such as phylogeny labels.\n *\n * Every taxonomic unit SHOULD have an rdfs:label and MAY include a dcterm:description\n * to describe it in human-readable terms. It MUST include a '@type' that specifies\n * what type of taxonomic unit it is.\n *\n * Taxonomic units may be specified with only an '@id' or a set of '@id's, which\n * indicate external references.\n */\n\nclass TaxonomicUnitWrapper {\n  /* Types of taxonomic units we support (see documentation above). */\n\n  /** A taxon or taxon concept. */\n  static get TYPE_TAXON_CONCEPT() {\n    return TaxonConceptWrapper.TYPE_TAXON_CONCEPT;\n  }\n\n  /** A specimen. */\n  static get TYPE_SPECIMEN() {\n    return SpecimenWrapper.TYPE_SPECIMEN;\n  }\n\n  /** Wrap a taxonomic unit. */\n  constructor(tunit, defaultNomenCode = owlterms.NAME_IN_UNKNOWN_CODE) {\n    this.tunit = tunit;\n    this.defaultNomenCode = defaultNomenCode;\n  }\n\n  /**\n   * What type of specifier is this? This is an array that could contain multiple\n   * classes, but should contain one of:\n   *  - {@link TYPE_TAXON_CONCEPT}\n   *  - {@link TYPE_SPECIMEN}\n   */\n  get types() {\n    if (!has(this.tunit, '@type')) return [];\n    if (isArray(this.tunit['@type'])) return this.tunit['@type'];\n    return [this.tunit['@type']];\n  }\n\n  /**\n   * Return this taxonomic unit if it is a taxon concept.\n   */\n  get taxonConcept() {\n    if (this.types.includes(TaxonomicUnitWrapper.TYPE_TAXON_CONCEPT)) return this.tunit;\n    return undefined;\n  }\n\n  /**\n   * Return this taxonomic unit if it is a specimen.\n   */\n  get specimen() {\n    // Only specimens have scientific names.\n    if (this.types.includes(TaxonomicUnitWrapper.TYPE_SPECIMEN)) return this.tunit;\n\n    return undefined;\n  }\n\n  /**\n   * Return the list of external references for this taxonomic unit.\n   * This is just all the '@ids' of this object.\n   */\n  get externalReferences() {\n    if (!has(this.tunit, '@id')) return [];\n    if (isArray(this.tunit['@id'])) return this.tunit['@id'];\n    return [this.tunit['@id']];\n  }\n\n  /**\n   * Return the label of this taxonomic unit.\n   */\n  get label() {\n    // A label or description for this TU?\n    if (has(this.tunit, 'label')) return this.tunit.label;\n    if (has(this.tunit, 'description')) return this.tunit.description;\n\n    // Is this a specimen?\n    if (this.specimen) {\n      return new SpecimenWrapper(this.specimen).label;\n    }\n\n    // Is this a taxon concept?\n    if (this.taxonConcept) {\n      return new TaxonConceptWrapper(this.taxonConcept).label;\n    }\n\n    // If its neither a specimen nor a taxon concept, just list the\n    // external references.\n    const externalReferences = this.externalReferences;\n    if (externalReferences.length > 0) {\n      return externalReferences\n        .map(externalRef => `<${externalRef}>`)\n        .join(' and ');\n    }\n\n    // If we don't have any properties of a taxonomic unit, return undefined.\n    return undefined;\n  }\n\n  /**\n   * Given a label, attempt to parse it into a taxonomic unit, whether a scientific\n   * name or a specimen identifier. The provided nomenclatural code is used.\n   *\n   * @return A taxonomic unit that this label could be parsed as.\n   */\n  static fromLabel(nodeLabel, nomenCode = owlterms.NAME_IN_UNKNOWN_CODE) {\n    if (nodeLabel === undefined || nodeLabel === null || nodeLabel.trim() === '') return undefined;\n\n    // Rather than figuring out with this label, check to see if we've parsed\n    // this before.\n    if (PhyxCacheManager.has(`TaxonomicUnitWrapper.taxonomicUnitsFromNodeLabelCache.${nomenCode}`, nodeLabel)) {\n      return PhyxCacheManager.get(`TaxonomicUnitWrapper.taxonomicUnitsFromNodeLabelCache.${nomenCode}`, nodeLabel);\n    }\n\n    // Look for taxon concept.\n    const taxonConcept = TaxonConceptWrapper.fromLabel(nodeLabel, nomenCode);\n\n    // Look for specimen information.\n    let specimen;\n    if (nodeLabel.toLowerCase().startsWith('specimen ')) {\n      // Eliminate a 'Specimen ' prefix if it exists.\n      specimen = SpecimenWrapper.fromOccurrenceID(nodeLabel.substr(9));\n    }\n\n    let tunit;\n    if (taxonConcept && specimen) {\n      // If we have both, then treat it as a specimen that has been identified\n      // to a particular taxonomic name.\n      tunit = assign({}, taxonConcept, specimen);\n\n      tunit['@type'] = TaxonomicUnitWrapper.TYPE_SPECIMEN;\n    } else if (taxonConcept) {\n      tunit = taxonConcept;\n    } else if (specimen) {\n      tunit = specimen;\n    }\n\n    // Look for external references. For now, we only check to see if the entire\n    // nodeLabel starts with URL/URNs, but we should eventually just look for\n    // them inside the label.\n    const URL_URN_PREFIXES = [\n      'http://',\n      'https://',\n      'ftp://',\n      'sftp://',\n      'file://',\n      'urn:',\n    ];\n\n    if (URL_URN_PREFIXES.filter(prefix => nodeLabel.startsWith(prefix)).length > 0) {\n      // The node label starts with something that looks like a URL!\n      // Treat it as an external reference.\n      if (tunit === undefined) tunit = {};\n      tunit['@id'] = nodeLabel;\n    }\n\n    // Finally, let's record the label we parsed to get to this tunit!\n    if (tunit) {\n      tunit.label = nodeLabel;\n    }\n\n    // Record in the cache\n    PhyxCacheManager.put(`TaxonomicUnitWrapper.taxonomicUnitsFromNodeLabelCache.${nomenCode}`, nodeLabel, tunit);\n\n    return tunit;\n  }\n\n  /**\n   * Return the JSON representation of this taxonomic unit, i.e. the object we're wrapping.\n   */\n  get asJSON() {\n    return this.tunit;\n  }\n\n  /**\n   * Return this taxonomic unit as an OWL/JSON-LD object.\n   */\n  get asJSONLD() {\n    const jsonld = cloneDeep(this.tunit);\n\n    // Add CDAO_TU as a type to the existing types.\n    if (has(this.tunit, '@type')) {\n      if (isArray(this.tunit['@type'])) this.tunit['@type'].push(owlterms.CDAO_TU);\n    }\n\n    const equivClass = this.asOWLEquivClass;\n    if (equivClass) {\n      jsonld.equivalentClass = equivClass;\n    }\n\n    return jsonld;\n  }\n\n  /**\n   * Return the equivalent class expression for this taxonomic unit.\n   */\n  get asOWLEquivClass() {\n    if (this.types.includes(TaxonomicUnitWrapper.TYPE_TAXON_CONCEPT)) {\n      return new TaxonConceptWrapper(this.tunit, this.defaultNomenCode).asOWLEquivClass;\n    }\n\n    if (this.types.includes(TaxonomicUnitWrapper.TYPE_SPECIMEN)) {\n      return new SpecimenWrapper(this.specimen).asOWLEquivClass;\n    }\n\n    // Nothing we can do, so just ignore it.\n    return undefined;\n  }\n}\n\nmodule.exports = {\n  TaxonomicUnitWrapper,\n};\n",
    "static": true,
    "longname": "/home/runner/work/phyx.js/phyx.js/src/wrappers/TaxonomicUnitWrapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 214,
    "kind": "variable",
    "name": "has",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js",
    "static": true,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~has",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/TaxonomicUnitWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 215,
    "kind": "variable",
    "name": "PhyxCacheManager",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js",
    "static": true,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~PhyxCacheManager",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/TaxonomicUnitWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 216,
    "kind": "variable",
    "name": "SpecimenWrapper",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js",
    "static": true,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~SpecimenWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/TaxonomicUnitWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 217,
    "kind": "variable",
    "name": "TaxonConceptWrapper",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js",
    "static": true,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonConceptWrapper",
    "access": "public",
    "export": false,
    "importPath": "@phyloref/phyx/src/wrappers/TaxonomicUnitWrapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 218,
    "kind": "class",
    "name": "TaxonomicUnitWrapper",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js",
    "static": true,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper",
    "access": "public",
    "export": true,
    "importPath": "@phyloref/phyx/src/wrappers/TaxonomicUnitWrapper.js",
    "importStyle": "{TaxonomicUnitWrapper}",
    "description": "The TaxonomicUnitWrapper wraps taxonomic units, whether on a node or being used\nas a specifier on a phyloreference. Every taxonomic unit can additionally be\nwrapped by more specific classes, such as {@link TaxonConceptWrapper} or\n{@link SpecimenWrapper}. We can determine which type it is based on its\n'@type' and whether it includes:\n - TaxonomicUnitWrapper.TYPE_TAXON_CONCEPT => {@link TaxonConceptWrapper}\n - TaxonomicUnitWrapper.TYPE_SPECIMEN => {@link SpecimenWrapper}\n - TaxonomicUnitWrapper.TYPE_APOMORPHY => reserved for future use\n - TaxonomicUnitWrapper.TYPE_PHYLOREF => reserved for future use\n\nIt also contains static methods for extracting\ntaxonomic units from arbitrary strings, such as phylogeny labels.\n\nEvery taxonomic unit SHOULD have an rdfs:label and MAY include a dcterm:description\nto describe it in human-readable terms. It MUST include a '@type' that specifies\nwhat type of taxonomic unit it is.\n\nTaxonomic units may be specified with only an '@id' or a set of '@id's, which\nindicate external references.",
    "lineNumber": 47,
    "interface": false
  },
  {
    "__docId__": 219,
    "kind": "get",
    "name": "TYPE_TAXON_CONCEPT",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper.TYPE_TAXON_CONCEPT",
    "access": "public",
    "description": "A taxon or taxon concept.",
    "lineNumber": 51,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 220,
    "kind": "get",
    "name": "TYPE_SPECIMEN",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper.TYPE_SPECIMEN",
    "access": "public",
    "description": "A specimen.",
    "lineNumber": 56,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 221,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper#constructor",
    "access": "public",
    "description": "Wrap a taxonomic unit.",
    "lineNumber": 61
  },
  {
    "__docId__": 222,
    "kind": "member",
    "name": "tunit",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper",
    "static": false,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper#tunit",
    "access": "public",
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 223,
    "kind": "member",
    "name": "defaultNomenCode",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper",
    "static": false,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper#defaultNomenCode",
    "access": "public",
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 224,
    "kind": "get",
    "name": "types",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper#types",
    "access": "public",
    "description": "What type of specifier is this? This is an array that could contain multiple\nclasses, but should contain one of:\n - {@link TYPE_TAXON_CONCEPT}\n - {@link TYPE_SPECIMEN}",
    "lineNumber": 72,
    "type": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 225,
    "kind": "get",
    "name": "taxonConcept",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper#taxonConcept",
    "access": "public",
    "description": "Return this taxonomic unit if it is a taxon concept.",
    "lineNumber": 81,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 226,
    "kind": "get",
    "name": "specimen",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper#specimen",
    "access": "public",
    "description": "Return this taxonomic unit if it is a specimen.",
    "lineNumber": 89,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 227,
    "kind": "get",
    "name": "externalReferences",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper#externalReferences",
    "access": "public",
    "description": "Return the list of external references for this taxonomic unit.\nThis is just all the '@ids' of this object.",
    "lineNumber": 100,
    "type": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 228,
    "kind": "get",
    "name": "label",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper#label",
    "access": "public",
    "description": "Return the label of this taxonomic unit.",
    "lineNumber": 109,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 229,
    "kind": "method",
    "name": "fromLabel",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper.fromLabel",
    "access": "public",
    "description": "Given a label, attempt to parse it into a taxonomic unit, whether a scientific\nname or a specimen identifier. The provided nomenclatural code is used.",
    "lineNumber": 143,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "A taxonomic unit that this label could be parsed as."
    },
    "params": [
      {
        "name": "nodeLabel",
        "types": [
          "*"
        ]
      },
      {
        "name": "nomenCode",
        "optional": true,
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 230,
    "kind": "get",
    "name": "asJSON",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper#asJSON",
    "access": "public",
    "description": "Return the JSON representation of this taxonomic unit, i.e. the object we're wrapping.",
    "lineNumber": 208,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 231,
    "kind": "get",
    "name": "asJSONLD",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper#asJSONLD",
    "access": "public",
    "description": "Return this taxonomic unit as an OWL/JSON-LD object.",
    "lineNumber": 215,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 232,
    "kind": "get",
    "name": "asOWLEquivClass",
    "memberof": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/wrappers/TaxonomicUnitWrapper.js~TaxonomicUnitWrapper#asOWLEquivClass",
    "access": "public",
    "description": "Return the equivalent class expression for this taxonomic unit.",
    "lineNumber": 234,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "kind": "index",
    "content": "# phyx.js\n\n[![Build Status](https://github.com/phyloref/phyx.js/workflows/Build%20and%20Test/badge.svg)](https://github.com/phyloref/phyx.js/actions?query=workflow%3A%22Build+and+Test%22)\n\nThe Phyloreference Exchange (PHYX) format is a JSON representation that can be\nused to store and transfer definitions of [phyloreferences]. This library provides\nclasses to help interpret some parts of these files, and for transforming an\nentire Phyx file into a [JSON-LD] representation that can be reasoned over with\nan [OWL 2 DL] reasoner. See the [Phyloreference Curation Tool] or the [Clade Ontology]\nfor examples of its usage.\n\n## Funding\nFunded by the US National Science Foundation through collaborative grants [DBI-1458484]\nand [DBI-1458604]. See [Funding] for details.\n\n  [phyloreferences]: http://phyloref.org\n  [JSON-LD]: https://en.wikipedia.org/wiki/JSON-LD\n  [OWL 2 DL]: https://www.w3.org/TR/owl2-overview/\n  [Phyloreference Curation Tool]: https://github.com/phyloref/curation-tool\n  [Clade Ontology]: https://github.com/phyloref/clade-ontology\n  [DBI-1458484]: http://www.nsf.gov/awardsearch/showAward?AWD_ID=1458484\n  [DBI-1458604]: http://www.nsf.gov/awardsearch/showAward?AWD_ID=1458604\n  [Funding]: http://www.phyloref.org/about/#funding\n",
    "longname": "/home/runner/work/phyx.js/phyx.js/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"@phyloref/phyx\",\n  \"version\": \"0.2.1\",\n  \"description\": \"Classes and methods that help read and manipulate components of Phyloreference Exchange (PHYX) format files\",\n  \"main\": \"src/index.js\",\n  \"bin\": {\n    \"resolve\": \"bin/resolve.js\",\n    \"phyx2owl\": \"bin/phyx2owl.js\"\n  },\n  \"scripts\": {\n    \"lint\": \"eslint \\\"src/**/*.js\\\" \\\"test/**/*.js\\\"\",\n    \"pretest\": \"npm run lint\",\n    \"test\": \"mocha --recursive\",\n    \"docs\": \"esdoc\",\n    \"resolve\": \"node bin/resolve.js\",\n    \"generate-every-topology\": \"every-topology-testing/generate-topologies.js\",\n    \"phyx2owl\": \"node bin/phyx2owl.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/phyloref/phyx.js.git\"\n  },\n  \"keywords\": [\n    \"phylogenetics\",\n    \"phylogeny\",\n    \"phylogenetic definitions\",\n    \"clade definitions\"\n  ],\n  \"author\": \"Gaurav Vaidya <gaurav@ggvaidya.com>\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/phyloref/phyx.js/issues\"\n  },\n  \"homepage\": \"https://github.com/phyloref/phyx.js#readme\",\n  \"dependencies\": {\n    \"lodash\": \"^4.17.20\",\n    \"moment\": \"^2.27.0\",\n    \"newick-js\": \"^1.1.1\",\n    \"retus\": \"^1.1.1\",\n    \"yargs\": \"^15.4.1\"\n  },\n  \"devDependencies\": {\n    \"ajv\": \"^6.12.2\",\n    \"chai\": \"^4.2.0\",\n    \"esdoc\": \"^1.1.0\",\n    \"esdoc-node\": \"^1.0.5\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"eslint\": \"^5.16.0\",\n    \"eslint-config-airbnb-base\": \"^13.2.0\",\n    \"eslint-plugin-import\": \"^2.22.1\",\n    \"eslint-plugin-mocha\": \"^5.3.0\",\n    \"jsonld\": \"^3.1.0\",\n    \"mocha\": \"^5.2.0\",\n    \"nodejs-file-downloader\": \"^4.1.1\",\n    \"yargs\": \"^15.3.1\"\n  },\n  \"esdoc\": {\n    \"source\": \"./src\",\n    \"destination\": \"./docs\",\n    \"plugins\": [\n      {\n        \"name\": \"esdoc-standard-plugin\",\n        \"option\": {\n          \"manual\": {\n            \"files\": [\n              \"./CHANGELOG.md\"\n            ]\n          },\n          \"test\": {\n            \"source\": \"./test/\",\n            \"includes\": [\n              \"\\\\.js$\"\n            ]\n          }\n        }\n      },\n      {\n        \"name\": \"esdoc-node\"\n      }\n    ]\n  }\n}\n",
    "longname": "/home/runner/work/phyx.js/phyx.js/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualIndex",
    "globalIndex": false,
    "content": null,
    "longname": "",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/runner/work/phyx.js/phyx.js/CHANGELOG.md",
    "name": "./CHANGELOG.md",
    "content": "# Changelog\nAll notable changes to this library will be documented in this file.\n\nThe format is based on [Keep a Changelog] and this project adheres to [Semantic Versioning].\n\n## [Unreleased]\n- Fixed a bug in which phyloref and phylogeny `@id` values were being overwritten when generating JSON-LD.\n- Added scripts to generate every possible topology from n=2 to n=6 with expected resolution and to test them with JPhyloRef.\n\n## [0.2.1] - 2019-08-15\n- Updated all NPM packages to their latest version.\n- Fixed a bug in which node's types were not being correctly set to obo:CDAO\\_0000140.\n\n## [0.2.0] - 2019-07-18\n### Changed\n- The single index.js has been split into multiple files, one per class, with documentation using ESdocs (#21).\n- Added support for generating \"model 2.0\" ontologies, which can be reasoned over in an OWL 2 EL reasoner such as Elk (#4). As part of this change, specifiers have been changed so that they are taxonomic units, rather than containing taxonomic units and a new Phyx context file has been created (#19).\n- Taxonomic units have been cleaned up, are clearly typed, and taxonomic names now include nomenclatural codes (#18) and support trinomial names (#22).\n\n## [0.1.2] - 2019-02-08\n### Added\n- Moved Phyx context file for JSON-LD into this repository from the Curation Tool and changed URI to point to it.\n\n## [0.1.1] - 2019-02-06\n### Added\n- A replacement for the Phylotree.js Newick parser.\n\n## [0.1.0] - 2019-01-27\n### Added\n- Transfered initial code from the [Phyloreference Curation Tool]. The initial\nrelease of this package was based on [commit 14d2c3d5d1] in that repository.\n\n### Changed\n- Replaced references to the [phylotree] library with the [newick-js] library.\n- Made other changes to the initial code as needed to work as an independent NPM package.\n\n  [Unreleased]: https://github.com/phyloref/phyx.js/compare/v0.2.0...master\n  [0.2.1]: https://github.com/phyloref/phyx.js/compare/v0.2.0...v0.2.1\n  [0.2.0]: https://github.com/phyloref/phyx.js/compare/v0.1.2...v0.2.0\n  [0.1.2]: https://github.com/phyloref/phyx.js/compare/v0.1.1...v0.1.2\n  [0.1.1]: https://github.com/phyloref/phyx.js/compare/v0.1.0...v0.1.1\n  [0.1.0]: https://github.com/phyloref/phyx.js/releases/tag/v0.1.0\n  [Keep a Changelog]: https://keepachangelog.com/en/1.0.0/\n  [Semantic Versioning]: https://semver.org/spec/v2.0.0.html\n  [Phyloreference Curation Tool]: http://github.com/phyloref/curation-tool\n  [commit 14d2c3d5d1]: https://github.com/phyloref/curation-tool/commit/14d2c3d5d12ee4e925e29961bd46587aabfb8cd4\n  [phylotree]: https://www.npmjs.com/package/phylotree\n  [newick-js]: https://www.npmjs.com/package/newick-js\n",
    "static": true,
    "access": "public"
  },
  {
    "__docId__": 233,
    "kind": "testFile",
    "name": "test/citations.js",
    "content": "/*\n * Test citations.\n */\n\n// Require phyx.js, our PHYX library, and Chai for testing.\nconst chai = require('chai');\nconst phyx = require('../src');\n\n// We use Chai's Expect API.\nconst expect = chai.expect;\n\n/*\n * Citation tests check to see if the CitationWrapper works correctly.\n */\n\ndescribe('CitationWrapper', function () {\n  // Some citations to use in testing.\n  const citations = [{\n    bibliographicCitation: 'Christopher A. Brochu (2003) Phylogenetic approaches toward crocodylian history Annual Review of Earth and Planetary Sciences 31  fig 1 doi: 10.1146/annurev.earth.31.100901.141308 URL: https://www.annualreviews.org/doi/10.1146/annurev.earth.31.100901.141308',\n    citation: {\n      type: 'article',\n      title: 'Phylogenetic approaches toward crocodylian history',\n      authors: [\n        {\n          name: 'Christopher A. Brochu',\n          alternate: ['Brochu, Christopher A.'],\n          firstname: 'Christopher',\n          middlename: 'A.',\n          lastname: 'Brochu',\n        },\n      ],\n      year: 2003,\n      figure: 1,\n      identifier: [\n        {\n          type: 'doi',\n          id: '10.1146/annurev.earth.31.100901.141308',\n        },\n      ],\n      link: [\n        {\n          url: 'https://www.annualreviews.org/doi/10.1146/annurev.earth.31.100901.141308',\n        },\n      ],\n      journal: {\n        name: 'Annual Review of Earth and Planetary Sciences',\n        volume: '31',\n        pages: '357--397',\n        identifier: [{\n          type: 'eISSN',\n          id: '1545-4495',\n        }],\n      },\n    },\n  }];\n\n  describe('given an empty citation', function () {\n    const wrapper = new phyx.CitationWrapper({});\n\n    describe('#constructor', function () {\n      it('should return a CitationWrapper', function () {\n        expect(wrapper).to.be.an.instanceOf(phyx.CitationWrapper);\n      });\n    });\n\n    describe('#toString', function () {\n      it('should return undefined', function () {\n        expect(wrapper.toString()).to.be.undefined;\n      });\n\n      it('should be settable by changing the title', function () {\n        wrapper.citation.title = 'Title';\n        expect(wrapper.toString()).equals('Anonymous (n.d.) Title');\n      });\n    });\n  });\n\n  citations.forEach((test, index) => {\n    describe(`for test citation #${index + 1}`, function () {\n      const wrapper = new phyx.CitationWrapper(test.citation);\n\n      describe('#constructor', function () {\n        it('should return a CitationWrapper', function () {\n          expect(wrapper).to.be.an.instanceOf(phyx.CitationWrapper);\n        });\n      });\n\n      describe('#toString', function () {\n        it('should return the expected string', function () {\n          expect(wrapper.toString()).to.equal(test.bibliographicCitation);\n        });\n      });\n    });\n  });\n});\n",
    "static": true,
    "longname": "/home/runner/work/phyx.js/phyx.js/test/citations.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 234,
    "kind": "test",
    "name": "describe0",
    "testId": 0,
    "memberof": "test/citations.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/citations.js~describe0",
    "access": null,
    "description": "CitationWrapper",
    "lineNumber": 16
  },
  {
    "__docId__": 235,
    "kind": "test",
    "name": "describe1",
    "testId": 1,
    "memberof": "test/citations.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/citations.js~describe0.describe1",
    "access": null,
    "description": "given an empty citation",
    "lineNumber": 57
  },
  {
    "__docId__": 236,
    "kind": "test",
    "name": "describe2",
    "testId": 2,
    "memberof": "test/citations.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "test/citations.js~describe0.describe1.describe2",
    "access": null,
    "description": "#constructor",
    "lineNumber": 60
  },
  {
    "__docId__": 237,
    "kind": "test",
    "name": "it3",
    "testId": 3,
    "memberof": "test/citations.js~describe0.describe1.describe2",
    "testDepth": 3,
    "static": true,
    "longname": "test/citations.js~describe0.describe1.describe2.it3",
    "access": null,
    "description": "should return a CitationWrapper",
    "lineNumber": 61
  },
  {
    "__docId__": 238,
    "kind": "test",
    "name": "describe4",
    "testId": 4,
    "memberof": "test/citations.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "test/citations.js~describe0.describe1.describe4",
    "access": null,
    "description": "#toString",
    "lineNumber": 66
  },
  {
    "__docId__": 239,
    "kind": "test",
    "name": "it5",
    "testId": 5,
    "memberof": "test/citations.js~describe0.describe1.describe4",
    "testDepth": 3,
    "static": true,
    "longname": "test/citations.js~describe0.describe1.describe4.it5",
    "access": null,
    "description": "should return undefined",
    "lineNumber": 67
  },
  {
    "__docId__": 240,
    "kind": "test",
    "name": "it6",
    "testId": 6,
    "memberof": "test/citations.js~describe0.describe1.describe4",
    "testDepth": 3,
    "static": true,
    "longname": "test/citations.js~describe0.describe1.describe4.it6",
    "access": null,
    "description": "should be settable by changing the title",
    "lineNumber": 71
  },
  {
    "__docId__": 241,
    "kind": "test",
    "name": "describe7",
    "testId": 7,
    "memberof": "test/citations.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/citations.js~describe0.describe7",
    "access": null,
    "lineNumber": 79
  },
  {
    "__docId__": 242,
    "kind": "test",
    "name": "describe8",
    "testId": 8,
    "memberof": "test/citations.js~describe0.describe7",
    "testDepth": 2,
    "static": true,
    "longname": "test/citations.js~describe0.describe7.describe8",
    "access": null,
    "description": "#constructor",
    "lineNumber": 82
  },
  {
    "__docId__": 243,
    "kind": "test",
    "name": "it9",
    "testId": 9,
    "memberof": "test/citations.js~describe0.describe7.describe8",
    "testDepth": 3,
    "static": true,
    "longname": "test/citations.js~describe0.describe7.describe8.it9",
    "access": null,
    "description": "should return a CitationWrapper",
    "lineNumber": 83
  },
  {
    "__docId__": 244,
    "kind": "test",
    "name": "describe10",
    "testId": 10,
    "memberof": "test/citations.js~describe0.describe7",
    "testDepth": 2,
    "static": true,
    "longname": "test/citations.js~describe0.describe7.describe10",
    "access": null,
    "description": "#toString",
    "lineNumber": 88
  },
  {
    "__docId__": 245,
    "kind": "test",
    "name": "it11",
    "testId": 11,
    "memberof": "test/citations.js~describe0.describe7.describe10",
    "testDepth": 3,
    "static": true,
    "longname": "test/citations.js~describe0.describe7.describe10.it11",
    "access": null,
    "description": "should return the expected string",
    "lineNumber": 89
  },
  {
    "__docId__": 246,
    "kind": "testFile",
    "name": "test/examples.js",
    "content": "/*\n * Test conversion on example files.\n */\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst jsonld = require('jsonld');\nconst chai = require('chai');\nconst Ajv = require('ajv');\n\nconst phyx = require('../src');\n\nconst expect = chai.expect;\n\n/*\n * Constants\n */\n// If REPLACE_EXISTING is set to true, we replace the existing JSON-LD and N-Quads\n// files rather than comparing them -- not a good way to test, but useful when\n// the output has changed.\nconst REPLACE_EXISTING = false;\n\n/**\n * Test whether conversion of Phyx files to an OWL ontology occurs predictably.\n */\n\ndescribe('PhyxWrapper', function () {\n  let brochu2003owl;\n  describe('convert brochu_2003.json to an OWL ontology', function () {\n    const jsonFilename = path.resolve(__dirname, './examples/correct/brochu_2003.json');\n    const jsonldFilename = path.resolve(__dirname, './examples/correct/brochu_2003.jsonld');\n\n    let brochu2003;\n\n    it('should be able to load brochu_2003.json', function () {\n      brochu2003 = JSON.parse(fs.readFileSync(jsonFilename));\n      expect(brochu2003).to.be.an('object');\n    });\n\n    it('should be able to convert brochu_2003.json to an OWL Ontology', function () {\n      this.timeout(10000);\n      brochu2003owl = new phyx.PhyxWrapper(brochu2003).asOWLOntology('http://example.org/brochu_2003.json#');\n      if (REPLACE_EXISTING) {\n        fs.writeFileSync(\n          jsonldFilename,\n          JSON.stringify(brochu2003owl, null, 2)\n        );\n      }\n      expect(brochu2003owl).to.be.an('object');\n    });\n\n    it('should generate the same OWL ontology as it generated earlier', function () {\n      const expectedBrochu2003 = JSON.parse(fs.readFileSync(jsonldFilename));\n      expect(brochu2003owl).to.be.deep.equal(expectedBrochu2003);\n    });\n  });\n  describe('convert brochu_2003.jsonld to n-quads', function () {\n    const nqFilename = path.resolve(__dirname, './examples/correct/brochu_2003.nq');\n\n    let brochu2003nq;\n    it('should be able to convert brochu_2003.json via JSON-LD to n-quads', function () {\n      this.timeout(10000);\n\n      // JSON-LD readers don't usually handle relative @context easily, so\n      // instead let's replace the entire @context with the local context file.\n      brochu2003owl['@context'] = JSON.parse(fs.readFileSync(\n        path.resolve(__dirname, path.join('examples', 'correct', brochu2003owl['@context']))\n      ));\n\n      return jsonld.toRDF(brochu2003owl, { format: 'application/n-quads' }).then((rdf) => {\n        brochu2003nq = rdf;\n        if (REPLACE_EXISTING) fs.writeFileSync(nqFilename, brochu2003nq);\n        expect(brochu2003nq).to.be.a('string');\n      });\n    });\n\n    it('should generate the same n-quads ontology as it generated earlier', function () {\n      const expectedBrochu2003nq = fs.readFileSync(nqFilename).toString();\n      expect(brochu2003nq).to.be.deep.equal(expectedBrochu2003nq);\n    });\n  });\n\n  describe('Test all example Phyx files', function () {\n    const examples = fs.readdirSync(path.resolve(__dirname, './examples'));\n    const jsonlds = examples.filter(filename => filename.toLowerCase().endsWith('.json'));\n    const ajv = new Ajv();\n    const validator = ajv.compile(\n      JSON.parse(\n        fs.readFileSync(\n          path.resolve(__dirname, '../docs/context/development/schema.json')\n        )\n      )\n    );\n\n    jsonlds.forEach((filename) => {\n      describe(`Example file ${filename}`, function () {\n        it('should validate against our JSON schema', function () {\n          const phyxContent = JSON.parse(\n            fs.readFileSync(\n              path.resolve(__dirname, `./examples/correct/${filename}`)\n            )\n          );\n          const valid = validator(phyxContent);\n          expect(validator.errors).to.be.null;\n          expect(valid).to.be.true;\n        });\n      });\n    });\n  });\n});\n",
    "static": true,
    "longname": "/home/runner/work/phyx.js/phyx.js/test/examples.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 247,
    "kind": "test",
    "name": "describe12",
    "testId": 12,
    "memberof": "test/examples.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/examples.js~describe12",
    "access": null,
    "description": "Test whether conversion of Phyx files to an OWL ontology occurs predictably.",
    "lineNumber": 28
  },
  {
    "__docId__": 248,
    "kind": "test",
    "name": "describe13",
    "testId": 13,
    "memberof": "test/examples.js~describe12",
    "testDepth": 1,
    "static": true,
    "longname": "test/examples.js~describe12.describe13",
    "access": null,
    "description": "convert brochu_2003.json to an OWL ontology",
    "lineNumber": 30
  },
  {
    "__docId__": 249,
    "kind": "test",
    "name": "it14",
    "testId": 14,
    "memberof": "test/examples.js~describe12.describe13",
    "testDepth": 2,
    "static": true,
    "longname": "test/examples.js~describe12.describe13.it14",
    "access": null,
    "description": "should be able to load brochu_2003.json",
    "lineNumber": 36
  },
  {
    "__docId__": 250,
    "kind": "test",
    "name": "it15",
    "testId": 15,
    "memberof": "test/examples.js~describe12.describe13",
    "testDepth": 2,
    "static": true,
    "longname": "test/examples.js~describe12.describe13.it15",
    "access": null,
    "description": "should be able to convert brochu_2003.json to an OWL Ontology",
    "lineNumber": 41
  },
  {
    "__docId__": 251,
    "kind": "test",
    "name": "it16",
    "testId": 16,
    "memberof": "test/examples.js~describe12.describe13",
    "testDepth": 2,
    "static": true,
    "longname": "test/examples.js~describe12.describe13.it16",
    "access": null,
    "description": "should generate the same OWL ontology as it generated earlier",
    "lineNumber": 53
  },
  {
    "__docId__": 252,
    "kind": "test",
    "name": "describe17",
    "testId": 17,
    "memberof": "test/examples.js~describe12",
    "testDepth": 1,
    "static": true,
    "longname": "test/examples.js~describe12.describe17",
    "access": null,
    "description": "convert brochu_2003.jsonld to n-quads",
    "lineNumber": 58
  },
  {
    "__docId__": 253,
    "kind": "test",
    "name": "it18",
    "testId": 18,
    "memberof": "test/examples.js~describe12.describe17",
    "testDepth": 2,
    "static": true,
    "longname": "test/examples.js~describe12.describe17.it18",
    "access": null,
    "description": "should be able to convert brochu_2003.json via JSON-LD to n-quads",
    "lineNumber": 62
  },
  {
    "__docId__": 254,
    "kind": "test",
    "name": "it19",
    "testId": 19,
    "memberof": "test/examples.js~describe12.describe17",
    "testDepth": 2,
    "static": true,
    "longname": "test/examples.js~describe12.describe17.it19",
    "access": null,
    "description": "should generate the same n-quads ontology as it generated earlier",
    "lineNumber": 78
  },
  {
    "__docId__": 255,
    "kind": "test",
    "name": "describe20",
    "testId": 20,
    "memberof": "test/examples.js~describe12",
    "testDepth": 1,
    "static": true,
    "longname": "test/examples.js~describe12.describe20",
    "access": null,
    "description": "Test all example Phyx files",
    "lineNumber": 84
  },
  {
    "__docId__": 256,
    "kind": "test",
    "name": "describe21",
    "testId": 21,
    "memberof": "test/examples.js~describe12.describe20",
    "testDepth": 2,
    "static": true,
    "longname": "test/examples.js~describe12.describe20.describe21",
    "access": null,
    "lineNumber": 97
  },
  {
    "__docId__": 257,
    "kind": "test",
    "name": "it22",
    "testId": 22,
    "memberof": "test/examples.js~describe12.describe20.describe21",
    "testDepth": 3,
    "static": true,
    "longname": "test/examples.js~describe12.describe20.describe21.it22",
    "access": null,
    "description": "should validate against our JSON schema",
    "lineNumber": 98
  },
  {
    "__docId__": 258,
    "kind": "testFile",
    "name": "test/jphyloref.js",
    "content": "/*\n * Use JPhyloRef to ensure that the expected JSON-LD files pass testing.\n * A different test, `examples.js`, will then test whether the current Phyx.js\n * produces a file identical to the expected JSON-LD files.\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst childProcess = require('child_process');\n\nconst Downloader = require('nodejs-file-downloader');\nconst chai = require('chai');\n\nconst expect = chai.expect;\n\n/*\n * Constants\n */\n// The version of JPhyloRef to download.\nconst JPHYLOREF_VERSION = '0.4.0';\n\n// The URL from where JPhyloRef should be downloaded.\nconst JPHYLOREF_URL = `https://repo.maven.apache.org/maven2/org/phyloref/jphyloref/${JPHYLOREF_VERSION}/jphyloref-${JPHYLOREF_VERSION}.jar`;\n// Where should the JPhyloRef be stored?\nconst JPHYLOREF_PATH = path.resolve(__dirname, `jphyloref-${JPHYLOREF_VERSION}.jar`);\n\n/**\n * Test whether the expected JSON-LD files pass testing using JPhyloRef.\n */\n\ndescribe('JPhyloRef', function () {\n  describe('download JPhyloRef', function () {\n    // TODO: we should eventually use SHA to ensure that we have the expected file.\n    if (\n      fs.existsSync(JPHYLOREF_PATH)\n      && fs.statSync(JPHYLOREF_PATH).size > 0\n    ) {\n      it('has already been downloaded', function () {\n        expect(true);\n      });\n    } else {\n      it('should be downloadable', function () {\n        this.timeout(10000);\n        // Download JPhyloRef from Maven and save it to JPHYLOREF_PATH.\n        return new Downloader({\n          url: JPHYLOREF_URL,\n          directory: path.dirname(JPHYLOREF_PATH),\n          fileName: path.basename(JPHYLOREF_PATH),\n        }).download();\n      });\n    }\n  });\n\n  describe('test example JSON-LD files using JPhyloRef', function () {\n    fs.readdirSync(path.resolve(__dirname, 'examples', 'correct'))\n      .filter(filename => filename.endsWith('.nq'))\n      .forEach((filename) => {\n        it(`testing ${filename}`, function () {\n          this.timeout(20000);\n\n          // Start JPhyloRef to test filename.\n          const filePath = path.resolve(__dirname, 'examples', 'correct', filename);\n          const child = childProcess.spawnSync(\n            'java',\n            [\n              '-jar', JPHYLOREF_PATH,\n              'test', filePath,\n            ],\n            {\n              encoding: 'utf8',\n              shell: true,\n            }\n          );\n          const matches = /Testing complete:(\\d+) successes, (\\d+) failures, (\\d+) failures marked TODO, (\\d+) skipped./.exec(child.stderr);\n\n          expect(matches, `Test result line not found in STDERR <${child.stderr}>`).to.have.lengthOf(5);\n\n          const countSuccess = Number(matches[1]);\n          const countFailure = Number(matches[2]);\n          const countTODOs = Number(matches[3]);\n          // const countSkipped = Number(matches[4]);\n\n          expect(countSuccess, 'Expected one or more successes').to.be.greaterThan(0);\n          expect(countFailure, 'Expected zero failures').to.equal(0);\n          expect(countTODOs, 'Expected zero TODOs').to.equal(0);\n\n          expect(child.status).to.equal(0);\n        });\n      });\n  });\n});\n",
    "static": true,
    "longname": "/home/runner/work/phyx.js/phyx.js/test/jphyloref.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 259,
    "kind": "test",
    "name": "describe23",
    "testId": 23,
    "memberof": "test/jphyloref.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/jphyloref.js~describe23",
    "access": null,
    "description": "Test whether the expected JSON-LD files pass testing using JPhyloRef.",
    "lineNumber": 31
  },
  {
    "__docId__": 260,
    "kind": "test",
    "name": "describe24",
    "testId": 24,
    "memberof": "test/jphyloref.js~describe23",
    "testDepth": 1,
    "static": true,
    "longname": "test/jphyloref.js~describe23.describe24",
    "access": null,
    "description": "download JPhyloRef",
    "lineNumber": 32
  },
  {
    "__docId__": 261,
    "kind": "test",
    "name": "it25",
    "testId": 25,
    "memberof": "test/jphyloref.js~describe23.describe24",
    "testDepth": 2,
    "static": true,
    "longname": "test/jphyloref.js~describe23.describe24.it25",
    "access": null,
    "description": "has already been downloaded",
    "lineNumber": 38
  },
  {
    "__docId__": 262,
    "kind": "test",
    "name": "it26",
    "testId": 26,
    "memberof": "test/jphyloref.js~describe23.describe24",
    "testDepth": 2,
    "static": true,
    "longname": "test/jphyloref.js~describe23.describe24.it26",
    "access": null,
    "description": "should be downloadable",
    "lineNumber": 42
  },
  {
    "__docId__": 263,
    "kind": "test",
    "name": "describe27",
    "testId": 27,
    "memberof": "test/jphyloref.js~describe23",
    "testDepth": 1,
    "static": true,
    "longname": "test/jphyloref.js~describe23.describe27",
    "access": null,
    "description": "test example JSON-LD files using JPhyloRef",
    "lineNumber": 54
  },
  {
    "__docId__": 264,
    "kind": "test",
    "name": "it28",
    "testId": 28,
    "memberof": "test/jphyloref.js~describe23.describe27",
    "testDepth": 2,
    "static": true,
    "longname": "test/jphyloref.js~describe23.describe27.it28",
    "access": null,
    "lineNumber": 58
  },
  {
    "__docId__": 265,
    "kind": "testFile",
    "name": "test/phylogenies.js",
    "content": "/*\n * Test phylogenies.\n */\n\n// Load phyx.js, our PHYX library, and chai for testing.\nconst chai = require('chai');\nconst phyx = require('../src');\n\n// Make it easier to access owlterms.\nconst owlterms = require('../src/utils/owlterms');\n\n// Use Chai's expect API for testing.\nconst expect = chai.expect;\n\n/*\n * These tests focus on three aspects of PhylogenyWrapper:\n *  - Whether it can detect errors in an input Newick string.\n *  - Retrieve taxonomic units from the phylogeny based on either their node label\n *    or on the additional properties associated with the phylogeny.\n *  - Whether we can match specifiers with nodes on the phylogeny if they share\n *    taxonomic units that match.\n */\n\ndescribe('PhylogenyWrapper', function () {\n  describe('#constructor', function () {\n    describe('when used to wrap an empty object', function () {\n      it('should return a PhylogenyWrapper object', function () {\n        expect(new phyx.PhylogenyWrapper({}))\n          .to.be.an.instanceOf(phyx.PhylogenyWrapper);\n      });\n    });\n  });\n\n  describe('#getErrorsInNewickString', function () {\n    describe('when given a correct Newick string', function () {\n      const correctNewickStrings = [\n        '(A:3, B:5, (C:6, N:7));',\n      ];\n\n      it('should return an empty list of errors', function () {\n        correctNewickStrings.forEach((str) => {\n          expect(phyx.PhylogenyWrapper.getErrorsInNewickString(str)).to.be.empty;\n        });\n      });\n    });\n\n    describe('when given an empty Newick string', function () {\n      const emptyNewickStrings = [\n        '()',\n        '();  ',\n      ];\n\n      it('should return a single \"No phylogeny entered\" error', function () {\n        emptyNewickStrings.forEach((newick) => {\n          const errors = phyx.PhylogenyWrapper.getErrorsInNewickString(newick);\n          expect(errors).to.have.length(1);\n          expect(errors[0].title).to.equal('No phylogeny entered');\n        });\n      });\n    });\n\n    describe('when given an unbalanced Newick string', function () {\n      const unbalancedNewickString = [\n        {\n          newick: '(A, B))',\n          expected: 'You have 1 too few open parentheses',\n        },\n        {\n          newick: '(A, (B, (C, D))',\n          expected: 'You have 1 too many open parentheses',\n        },\n        {\n          newick: '(A, (B, (C, (((D))',\n          expected: 'You have 4 too many open parentheses',\n        },\n      ];\n\n      it('should report how many parentheses are missing', function () {\n        unbalancedNewickString.forEach((entry) => {\n          const errors = phyx.PhylogenyWrapper.getErrorsInNewickString(entry.newick);\n\n          // We should get two errors.\n          expect(errors).to.have.lengthOf(2);\n\n          // Should include an error about the unbalanced parentheses.\n          expect(errors[0].title).to.equal('Unbalanced parentheses in Newick string');\n          expect(errors[0].message).to.equal(entry.expected);\n\n          // Should include an error passed on from the Newick parser.\n          expect(errors[1].title).to.equal('Error parsing phylogeny');\n          expect(errors[1].message).to.include('An error occured while parsing this phylogeny:');\n        });\n      });\n    });\n\n    describe('when given an incomplete Newick string', function () {\n      const incompleteNewickStrings = [\n        ';',\n        '))(A, (B, ',\n      ];\n\n      it('should report an error parsing the phylogeny', function () {\n        incompleteNewickStrings.forEach((newick) => {\n          const errors = phyx.PhylogenyWrapper.getErrorsInNewickString(newick);\n\n          expect(errors).to.have.lengthOf(1);\n          expect(errors[0].title).to.equal('Error parsing phylogeny');\n          expect(errors[0].message).to.include('An error occured while parsing this phylogeny:');\n        });\n      });\n    });\n  });\n\n  describe('#getNodeLabels', function () {\n    const tests = [\n      {\n        // Note that 'newick' is the input for this test.\n        newick: '(A, (B, (C, D))E, F, (G, (H, I, J)K, L)M, N)O',\n        // The following keys indicate the expected all/internal/terminal node labels\n        // for the given Newick string.\n        nodeLabels: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O'],\n        internalNodeLabels: ['E', 'K', 'M', 'O'],\n        terminalNodeLabels: ['A', 'B', 'C', 'D', 'F', 'G', 'H', 'I', 'J', 'L', 'N'],\n      },\n    ];\n\n    tests.forEach((test) => {\n      const wrapper = new phyx.PhylogenyWrapper({ newick: test.newick });\n\n      describe('For a particular Newick phylogeny', function () {\n        it('should return a list of all node labels by default', function () {\n          expect(wrapper.getNodeLabels().sort())\n            .to.have.members(test.nodeLabels.sort());\n        });\n\n        it('should return a list of internal labels when asked for internal labels', function () {\n          expect(wrapper.getNodeLabels('internal').sort())\n            .to.have.members(test.internalNodeLabels.sort());\n        });\n\n        it('should return a list of terminal labels when asked for terminal labels', function () {\n          expect(wrapper.getNodeLabels('terminal').sort())\n            .to.have.members(test.terminalNodeLabels.sort());\n        });\n      });\n    });\n  });\n\n  describe('given a particular phylogeny with additional node properties', function () {\n    const wrapper = new phyx.PhylogenyWrapper({\n      newick: '((MVZ225749, MVZ191016), Rana boylii)',\n      additionalNodeProperties: {\n        MVZ225749: {\n          representsTaxonomicUnits: [{\n            '@type': [\n              phyx.TaxonomicUnitWrapper.TYPE_SPECIMEN,\n            ],\n            nameString: 'Rana luteiventris',\n            occurrenceID: 'MVZ:225749',\n          }],\n        },\n        MVZ191016: {\n          representsTaxonomicUnits: [{\n            '@type': [\n              phyx.TaxonomicUnitWrapper.TYPE_SPECIMEN,\n            ],\n            nameString: 'Rana luteiventris',\n            occurrenceID: 'MVZ:191016',\n          }],\n        },\n      },\n    });\n\n    describe('#getNodeLabels', function () {\n      it('should return the list of node labels from the Newick string', function () {\n        expect(wrapper.getNodeLabels().sort())\n          .to.have.members([\n            'MVZ191016',\n            'MVZ225749',\n            'Rana boylii',\n          ]);\n      });\n    });\n\n    describe('#getTaxonomicUnitsForNodeLabel', function () {\n      it('should return the list of taxonomic units using information from additional node properties', function () {\n        expect(wrapper.getTaxonomicUnitsForNodeLabel('MVZ191016')).to.deep.equal([{\n          '@type': [\n            phyx.TaxonomicUnitWrapper.TYPE_SPECIMEN,\n          ],\n          nameString: 'Rana luteiventris',\n          occurrenceID: 'MVZ:191016',\n        }]);\n\n        expect(wrapper.getTaxonomicUnitsForNodeLabel('MVZ225749')).to.deep.equal([{\n          '@type': [\n            phyx.TaxonomicUnitWrapper.TYPE_SPECIMEN,\n          ],\n          nameString: 'Rana luteiventris',\n          occurrenceID: 'MVZ:225749',\n        }]);\n\n        expect(wrapper.getTaxonomicUnitsForNodeLabel('Rana boylii')).to.deep.equal([{\n          '@type': owlterms.TDWG_VOC_TAXON_CONCEPT,\n          label: 'Rana boylii',\n          hasName: {\n            '@type': 'http://rs.tdwg.org/ontology/voc/TaxonName#TaxonName',\n            label: 'Rana boylii',\n            nameComplete: 'Rana boylii',\n            genusPart: 'Rana',\n            specificEpithet: 'boylii',\n          },\n        }]);\n      });\n    });\n\n    describe('#getNodeLabelsMatchedBySpecifier', function () {\n      it('should match a specifier to MVZ225749 based on occurrence ID', function () {\n        const specifier1 = {\n          '@type': phyx.TaxonomicUnitWrapper.TYPE_SPECIMEN,\n          occurrenceID: 'MVZ:225749',\n        };\n        expect(wrapper.getNodeLabelsMatchedBySpecifier(specifier1))\n          .to.have.members(['MVZ225749']);\n      });\n\n      it('should match a specifier to MVZ191016 based on occurrence ID', function () {\n        const specifier2 = {\n          '@type': phyx.TaxonomicUnitWrapper.TYPE_SPECIMEN,\n          occurrenceID: 'MVZ:191016',\n        };\n\n        expect(wrapper.getNodeLabelsMatchedBySpecifier(specifier2))\n          .to.have.members(['MVZ191016']);\n      });\n\n      it('should match a specifier to node \"Rana boylii\" based on the parsed scientific name', function () {\n        const specifier3 = {\n          '@type': phyx.TaxonomicUnitWrapper.TYPE_TAXON_CONCEPT,\n          nameString: 'Rana boylii',\n        };\n\n        expect(wrapper.getNodeLabelsMatchedBySpecifier(specifier3))\n          .to.have.members(['Rana boylii']);\n      });\n    });\n  });\n\n  describe('#asJSONLD', function () {\n    it('should preserve an existing @id on input phylogenies', function () {\n      const jsonld = new phyx.PhylogenyWrapper({\n        '@id': '#providedId',\n        newick: '((Homo_sapiens, Panthera_tigris), Mus_musculus)',\n      }).asJSONLD('#phylogeny0');\n      expect(jsonld).to.have.property('@id');\n      expect(jsonld['@id']).to.equal('#providedId');\n    });\n    it('should generate a new @id on input phylorefs', function () {\n      const jsonld = new phyx.PhylogenyWrapper({\n        newick: '((Homo_sapiens, Panthera_tigris), Mus_musculus)',\n      }, owlterms.ICZN_CODE).asJSONLD('#phylogeny0');\n      expect(jsonld).to.have.property('@id');\n      expect(jsonld['@id']).to.equal('#phylogeny0');\n    });\n    it('should generate the phylogeny in JSON-LD as expected', function () {\n      const expectedResults = [\n        {\n          newick: '((Homo_sapiens, Panthera_tigris), Mus_musculus)',\n          jsonld: {\n            '@id': '#',\n            '@type': owlterms.PHYLOREFERENCE_PHYLOGENY,\n            hasRootNode: { '@id': '#_node0' },\n            newick: '((Homo_sapiens, Panthera_tigris), Mus_musculus)',\n            nodes: [\n              {\n                '@id': '#_node0',\n                children: ['#_node1', '#_node2'],\n                'rdf:type': [{ '@id': owlterms.CDAO_NODE }],\n              },\n              {\n                '@id': '#_node1',\n                'rdf:type': [\n                  { '@id': owlterms.CDAO_NODE },\n                  {\n                    '@type': owlterms.OWL_RESTRICTION,\n                    onProperty: owlterms.CDAO_REPRESENTS_TU,\n                    someValuesFrom: {\n                      '@type': owlterms.OWL_RESTRICTION,\n                      onProperty: owlterms.TDWG_VOC_HAS_NAME,\n                      someValuesFrom: {\n                        '@type': owlterms.OWL_CLASS,\n                        intersectionOf: [{\n                          '@type': owlterms.OWL_RESTRICTION,\n                          hasValue: 'Mus musculus',\n                          onProperty: owlterms.TDWG_VOC_NAME_COMPLETE,\n                        }, {\n                          '@type': owlterms.OWL_RESTRICTION,\n                          hasValue: {\n                            '@id': owlterms.ICZN_CODE,\n                          },\n                          onProperty: owlterms.NOMENCLATURAL_CODE,\n                        }],\n                      },\n                    },\n                  },\n                ],\n                labels: ['Mus_musculus'],\n                parent: '#_node0',\n                representsTaxonomicUnits: [{\n                  '@type': owlterms.TDWG_VOC_TAXON_CONCEPT,\n                  hasName: {\n                    '@type': owlterms.TDWG_VOC_TAXON_NAME,\n                    genusPart: 'Mus',\n                    label: 'Mus_musculus',\n                    nameComplete: 'Mus musculus',\n                    nomenclaturalCode: owlterms.ICZN_CODE,\n                    specificEpithet: 'musculus',\n                  },\n                  label: 'Mus_musculus',\n                }],\n                siblings: ['#_node2'],\n              },\n              {\n                '@id': '#_node2',\n                children: ['#_node3', '#_node4'],\n                'rdf:type': [{ '@id': owlterms.CDAO_NODE }],\n                parent: '#_node0',\n                siblings: ['#_node1'],\n              },\n              {\n                '@id': '#_node3',\n                'rdf:type': [\n                  { '@id': owlterms.CDAO_NODE },\n                  {\n                    '@type': owlterms.OWL_RESTRICTION,\n                    onProperty: owlterms.CDAO_REPRESENTS_TU,\n                    someValuesFrom: {\n                      '@type': owlterms.OWL_RESTRICTION,\n                      onProperty: owlterms.TDWG_VOC_HAS_NAME,\n                      someValuesFrom: {\n                        '@type': owlterms.OWL_CLASS,\n                        intersectionOf: [{\n                          '@type': owlterms.OWL_RESTRICTION,\n                          hasValue: 'Panthera tigris',\n                          onProperty: owlterms.TDWG_VOC_NAME_COMPLETE,\n                        }, {\n                          '@type': owlterms.OWL_RESTRICTION,\n                          hasValue: {\n                            '@id': owlterms.ICZN_CODE,\n                          },\n                          onProperty: owlterms.NOMENCLATURAL_CODE,\n                        }],\n                      },\n                    },\n                  },\n                ],\n                labels: ['Panthera_tigris'],\n                parent: '#_node2',\n                representsTaxonomicUnits: [{\n                  '@type': owlterms.TDWG_VOC_TAXON_CONCEPT,\n                  hasName: {\n                    '@type': owlterms.TDWG_VOC_TAXON_NAME,\n                    genusPart: 'Panthera',\n                    label: 'Panthera_tigris',\n                    nameComplete: 'Panthera tigris',\n                    nomenclaturalCode: owlterms.ICZN_CODE,\n                    specificEpithet: 'tigris',\n                  },\n                  label: 'Panthera_tigris',\n                }],\n                siblings: ['#_node4'],\n              },\n              {\n                '@id': '#_node4',\n                'rdf:type': [\n                  { '@id': owlterms.CDAO_NODE },\n                  {\n                    '@type': owlterms.OWL_RESTRICTION,\n                    onProperty: owlterms.CDAO_REPRESENTS_TU,\n                    someValuesFrom: {\n                      '@type': owlterms.OWL_RESTRICTION,\n                      onProperty: owlterms.TDWG_VOC_HAS_NAME,\n                      someValuesFrom: {\n                        '@type': owlterms.OWL_CLASS,\n                        intersectionOf: [{\n                          '@type': owlterms.OWL_RESTRICTION,\n                          hasValue: 'Homo sapiens',\n                          onProperty: owlterms.TDWG_VOC_NAME_COMPLETE,\n                        }, {\n                          '@type': owlterms.OWL_RESTRICTION,\n                          hasValue: {\n                            '@id': owlterms.ICZN_CODE,\n                          },\n                          onProperty: owlterms.NOMENCLATURAL_CODE,\n                        }],\n                      },\n                    },\n                  },\n                ],\n                labels: ['Homo_sapiens'],\n                parent: '#_node2',\n                representsTaxonomicUnits: [\n                  {\n                    '@type': owlterms.TDWG_VOC_TAXON_CONCEPT,\n                    hasName: {\n                      '@type': owlterms.TDWG_VOC_TAXON_NAME,\n                      genusPart: 'Homo',\n                      label: 'Homo_sapiens',\n                      nameComplete: 'Homo sapiens',\n                      nomenclaturalCode: owlterms.ICZN_CODE,\n                      specificEpithet: 'sapiens',\n                    },\n                    label: 'Homo_sapiens',\n                  },\n                ],\n                siblings: ['#_node3'],\n              },\n            ],\n          },\n        },\n      ];\n\n      expectedResults.forEach((expected) => {\n        const wrapper = new phyx.PhylogenyWrapper({\n          '@id': '#',\n          newick: expected.newick,\n        }, owlterms.ICZN_CODE);\n        expect(wrapper.asJSONLD('#phylogeny0')).to.deep.equal(expected.jsonld);\n      });\n    });\n  });\n\n  describe('#getParsedNewickWithIRIs', function () {\n    const tests = [\n      {\n        newick: '(((A, B)C, D)E, F)G',\n        result: {\n          json: {\n            '@id': '_node0',\n            name: 'G',\n            label: 'G',\n            children: [\n              { '@id': '_node1', name: 'F', label: 'F' },\n              {\n                '@id': '_node2',\n                name: 'E',\n                label: 'E',\n                children: [\n                  { '@id': '_node3', name: 'D', label: 'D' },\n                  {\n                    '@id': '_node4',\n                    name: 'C',\n                    label: 'C',\n                    children: [\n                      { '@id': '_node5', name: 'B', label: 'B' },\n                      { '@id': '_node6', name: 'A', label: 'A' },\n                    ],\n                  },\n                ],\n              },\n            ],\n          },\n        },\n      },\n    ];\n\n    tests.forEach((test) => {\n      it('should be able to parse a provided Newick string as expected', function () {\n        expect(new phyx.PhylogenyWrapper({ newick: test.newick }).getParsedNewickWithIRIs(''))\n          .to.deep.equal(test.result);\n      });\n    });\n  });\n});\n",
    "static": true,
    "longname": "/home/runner/work/phyx.js/phyx.js/test/phylogenies.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 266,
    "kind": "test",
    "name": "describe29",
    "testId": 29,
    "memberof": "test/phylogenies.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/phylogenies.js~describe29",
    "access": null,
    "description": "PhylogenyWrapper",
    "lineNumber": 24
  },
  {
    "__docId__": 267,
    "kind": "test",
    "name": "describe30",
    "testId": 30,
    "memberof": "test/phylogenies.js~describe29",
    "testDepth": 1,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe30",
    "access": null,
    "description": "#constructor",
    "lineNumber": 25
  },
  {
    "__docId__": 268,
    "kind": "test",
    "name": "describe31",
    "testId": 31,
    "memberof": "test/phylogenies.js~describe29.describe30",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe30.describe31",
    "access": null,
    "description": "when used to wrap an empty object",
    "lineNumber": 26
  },
  {
    "__docId__": 269,
    "kind": "test",
    "name": "it32",
    "testId": 32,
    "memberof": "test/phylogenies.js~describe29.describe30.describe31",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe30.describe31.it32",
    "access": null,
    "description": "should return a PhylogenyWrapper object",
    "lineNumber": 27
  },
  {
    "__docId__": 270,
    "kind": "test",
    "name": "describe33",
    "testId": 33,
    "memberof": "test/phylogenies.js~describe29",
    "testDepth": 1,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe33",
    "access": null,
    "description": "#getErrorsInNewickString",
    "lineNumber": 34
  },
  {
    "__docId__": 271,
    "kind": "test",
    "name": "describe34",
    "testId": 34,
    "memberof": "test/phylogenies.js~describe29.describe33",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe33.describe34",
    "access": null,
    "description": "when given a correct Newick string",
    "lineNumber": 35
  },
  {
    "__docId__": 272,
    "kind": "test",
    "name": "it35",
    "testId": 35,
    "memberof": "test/phylogenies.js~describe29.describe33.describe34",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe33.describe34.it35",
    "access": null,
    "description": "should return an empty list of errors",
    "lineNumber": 40
  },
  {
    "__docId__": 273,
    "kind": "test",
    "name": "describe36",
    "testId": 36,
    "memberof": "test/phylogenies.js~describe29.describe33",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe33.describe36",
    "access": null,
    "description": "when given an empty Newick string",
    "lineNumber": 47
  },
  {
    "__docId__": 274,
    "kind": "test",
    "name": "it37",
    "testId": 37,
    "memberof": "test/phylogenies.js~describe29.describe33.describe36",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe33.describe36.it37",
    "access": null,
    "description": "should return a single \"No phylogeny entered\" error",
    "lineNumber": 53
  },
  {
    "__docId__": 275,
    "kind": "test",
    "name": "describe38",
    "testId": 38,
    "memberof": "test/phylogenies.js~describe29.describe33",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe33.describe38",
    "access": null,
    "description": "when given an unbalanced Newick string",
    "lineNumber": 62
  },
  {
    "__docId__": 276,
    "kind": "test",
    "name": "it39",
    "testId": 39,
    "memberof": "test/phylogenies.js~describe29.describe33.describe38",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe33.describe38.it39",
    "access": null,
    "description": "should report how many parentheses are missing",
    "lineNumber": 78
  },
  {
    "__docId__": 277,
    "kind": "test",
    "name": "describe40",
    "testId": 40,
    "memberof": "test/phylogenies.js~describe29.describe33",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe33.describe40",
    "access": null,
    "description": "when given an incomplete Newick string",
    "lineNumber": 96
  },
  {
    "__docId__": 278,
    "kind": "test",
    "name": "it41",
    "testId": 41,
    "memberof": "test/phylogenies.js~describe29.describe33.describe40",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe33.describe40.it41",
    "access": null,
    "description": "should report an error parsing the phylogeny",
    "lineNumber": 102
  },
  {
    "__docId__": 279,
    "kind": "test",
    "name": "describe42",
    "testId": 42,
    "memberof": "test/phylogenies.js~describe29",
    "testDepth": 1,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe42",
    "access": null,
    "description": "#getNodeLabels",
    "lineNumber": 114
  },
  {
    "__docId__": 280,
    "kind": "test",
    "name": "describe43",
    "testId": 43,
    "memberof": "test/phylogenies.js~describe29.describe42",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe42.describe43",
    "access": null,
    "description": "For a particular Newick phylogeny",
    "lineNumber": 130
  },
  {
    "__docId__": 281,
    "kind": "test",
    "name": "it44",
    "testId": 44,
    "memberof": "test/phylogenies.js~describe29.describe42.describe43",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe42.describe43.it44",
    "access": null,
    "description": "should return a list of all node labels by default",
    "lineNumber": 131
  },
  {
    "__docId__": 282,
    "kind": "test",
    "name": "it45",
    "testId": 45,
    "memberof": "test/phylogenies.js~describe29.describe42.describe43",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe42.describe43.it45",
    "access": null,
    "description": "should return a list of internal labels when asked for internal labels",
    "lineNumber": 136
  },
  {
    "__docId__": 283,
    "kind": "test",
    "name": "it46",
    "testId": 46,
    "memberof": "test/phylogenies.js~describe29.describe42.describe43",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe42.describe43.it46",
    "access": null,
    "description": "should return a list of terminal labels when asked for terminal labels",
    "lineNumber": 141
  },
  {
    "__docId__": 284,
    "kind": "test",
    "name": "describe47",
    "testId": 47,
    "memberof": "test/phylogenies.js~describe29",
    "testDepth": 1,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe47",
    "access": null,
    "description": "given a particular phylogeny with additional node properties",
    "lineNumber": 149
  },
  {
    "__docId__": 285,
    "kind": "test",
    "name": "describe48",
    "testId": 48,
    "memberof": "test/phylogenies.js~describe29.describe47",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe47.describe48",
    "access": null,
    "description": "#getNodeLabels",
    "lineNumber": 174
  },
  {
    "__docId__": 286,
    "kind": "test",
    "name": "it49",
    "testId": 49,
    "memberof": "test/phylogenies.js~describe29.describe47.describe48",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe47.describe48.it49",
    "access": null,
    "description": "should return the list of node labels from the Newick string",
    "lineNumber": 175
  },
  {
    "__docId__": 287,
    "kind": "test",
    "name": "describe50",
    "testId": 50,
    "memberof": "test/phylogenies.js~describe29.describe47",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe47.describe50",
    "access": null,
    "description": "#getTaxonomicUnitsForNodeLabel",
    "lineNumber": 185
  },
  {
    "__docId__": 288,
    "kind": "test",
    "name": "it51",
    "testId": 51,
    "memberof": "test/phylogenies.js~describe29.describe47.describe50",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe47.describe50.it51",
    "access": null,
    "description": "should return the list of taxonomic units using information from additional node properties",
    "lineNumber": 186
  },
  {
    "__docId__": 289,
    "kind": "test",
    "name": "describe52",
    "testId": 52,
    "memberof": "test/phylogenies.js~describe29.describe47",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe47.describe52",
    "access": null,
    "description": "#getNodeLabelsMatchedBySpecifier",
    "lineNumber": 217
  },
  {
    "__docId__": 290,
    "kind": "test",
    "name": "it53",
    "testId": 53,
    "memberof": "test/phylogenies.js~describe29.describe47.describe52",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe47.describe52.it53",
    "access": null,
    "description": "should match a specifier to MVZ225749 based on occurrence ID",
    "lineNumber": 218
  },
  {
    "__docId__": 291,
    "kind": "test",
    "name": "it54",
    "testId": 54,
    "memberof": "test/phylogenies.js~describe29.describe47.describe52",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe47.describe52.it54",
    "access": null,
    "description": "should match a specifier to MVZ191016 based on occurrence ID",
    "lineNumber": 227
  },
  {
    "__docId__": 292,
    "kind": "test",
    "name": "it55",
    "testId": 55,
    "memberof": "test/phylogenies.js~describe29.describe47.describe52",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe47.describe52.it55",
    "access": null,
    "description": "should match a specifier to node \"Rana boylii\" based on the parsed scientific name",
    "lineNumber": 237
  },
  {
    "__docId__": 293,
    "kind": "test",
    "name": "describe56",
    "testId": 56,
    "memberof": "test/phylogenies.js~describe29",
    "testDepth": 1,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe56",
    "access": null,
    "description": "#asJSONLD",
    "lineNumber": 249
  },
  {
    "__docId__": 294,
    "kind": "test",
    "name": "it57",
    "testId": 57,
    "memberof": "test/phylogenies.js~describe29.describe56",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe56.it57",
    "access": null,
    "description": "should preserve an existing @id on input phylogenies",
    "lineNumber": 250
  },
  {
    "__docId__": 295,
    "kind": "test",
    "name": "it58",
    "testId": 58,
    "memberof": "test/phylogenies.js~describe29.describe56",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe56.it58",
    "access": null,
    "description": "should generate a new @id on input phylorefs",
    "lineNumber": 258
  },
  {
    "__docId__": 296,
    "kind": "test",
    "name": "it59",
    "testId": 59,
    "memberof": "test/phylogenies.js~describe29.describe56",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe56.it59",
    "access": null,
    "description": "should generate the phylogeny in JSON-LD as expected",
    "lineNumber": 265
  },
  {
    "__docId__": 297,
    "kind": "test",
    "name": "describe60",
    "testId": 60,
    "memberof": "test/phylogenies.js~describe29",
    "testDepth": 1,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe60",
    "access": null,
    "description": "#getParsedNewickWithIRIs",
    "lineNumber": 433
  },
  {
    "__docId__": 298,
    "kind": "test",
    "name": "it61",
    "testId": 61,
    "memberof": "test/phylogenies.js~describe29.describe60",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylogenies.js~describe29.describe60.it61",
    "access": null,
    "description": "should be able to parse a provided Newick string as expected",
    "lineNumber": 468
  },
  {
    "__docId__": 299,
    "kind": "testFile",
    "name": "test/phylorefs.js",
    "content": "/*\n * Test phyloreferences.\n */\n\n// Require phyx.js, our PHYX library, and Chai for testing.\nconst chai = require('chai');\nconst phyx = require('../src');\n\n// Use owlterms so we don't have to repeat OWL terms.\nconst owlterms = require('../src/utils/owlterms');\n\n// We use Chai's Expect API.\nconst expect = chai.expect;\n\n/*\n * Phyloref tests cover three aspects of phyloreferences:\n *  - Whether we can create a phyloref with a particular set of specifiers,\n *    and whether we can correctly change the type of a specifer (from 'External'\n *    to 'Internal'), delete specifiers, and retrieve specifier labels.\n *  - Whether we can determine to which node a phyloref is expected to resolve to\n *    by using additionalNodeProperties.\n *  - Whether we can update the phyloref's status several times and retrieve the\n *    full history of its status changes.\n */\n\ndescribe('PhylorefWrapper', function () {\n  // Some specifiers to use in testing.\n  const specifier1 = {\n    '@type': phyx.TaxonomicUnitWrapper.TYPE_SPECIMEN,\n    occurrenceID: 'MVZ:225749',\n  };\n  const specifier2 = {\n    '@type': phyx.TaxonomicUnitWrapper.TYPE_SPECIMEN,\n    occurrenceID: 'MVZ:191016',\n  };\n  const specifier3 = {\n    '@type': phyx.TaxonomicUnitWrapper.TYPE_TAXON_CONCEPT,\n    hasName: {\n      '@type': phyx.TaxonNameWrapper.TYPE_TAXON_NAME,\n      nomenclaturalCode: owlterms.ICZN_CODE,\n      nameComplete: 'Rana boylii',\n    },\n  };\n  const specifier4 = {\n    '@type': phyx.TaxonomicUnitWrapper.TYPE_TAXON_CONCEPT,\n    hasName: {\n      '@type': phyx.TaxonNameWrapper.TYPE_TAXON_NAME,\n      nomenclaturalCode: owlterms.ICN_CODE,\n      nameComplete: 'Mangifera indica',\n    },\n  };\n\n  describe('given an empty phyloreference', function () {\n    const wrapper = new phyx.PhylorefWrapper({});\n\n    describe('#constructor', function () {\n      it('should return a PhylorefWrapper', function () {\n        expect(wrapper).to.be.an.instanceOf(phyx.PhylorefWrapper);\n      });\n    });\n\n    describe('#label', function () {\n      it('should return undefined', function () {\n        expect(wrapper.label).to.be.undefined;\n      });\n\n      it('should be settable by assigning to .label', function () {\n        wrapper.label = 'phyloref1';\n        expect(wrapper.label).equals('phyloref1');\n      });\n    });\n\n    describe('#specifiers', function () {\n      it('should initially return an empty list', function () {\n        expect(wrapper.specifiers).to.be.empty;\n      });\n\n      it('should initially return a nomenclatural code of unknown', function () {\n        expect(wrapper.defaultNomenCode).to.equal(owlterms.UNKNOWN_CODE);\n      });\n\n      describe('when a new external specifier is added using .externalSpecifiers', function () {\n        it('should return a list with the new specifier', function () {\n          wrapper.externalSpecifiers.push(specifier3);\n          expect(wrapper.specifiers).to.deep.equal([specifier3]);\n        });\n\n        it('should return a nomenclatural code of ICZN', function () {\n          expect(wrapper.defaultNomenCode).to.equal(owlterms.ICZN_CODE);\n        });\n      });\n\n      describe('when a new external specifier is added using .externalSpecifiers', function () {\n        it('should return a list with the new specifier', function () {\n          wrapper.externalSpecifiers.push(specifier2);\n          expect(wrapper.specifiers).to.deep.equal([specifier3, specifier2]);\n        });\n\n        it('should return two nomenclatural codes, one for each specifier', function () {\n          expect(wrapper.uniqNomenCodes).to.have.lengthOf(2);\n          expect(wrapper.uniqNomenCodes).to.include(owlterms.ICZN_CODE);\n          expect(wrapper.uniqNomenCodes).to.include(owlterms.UNKNOWN_CODE);\n        });\n\n        it('should still return a nomenclatural code of ICZN', function () {\n          expect(wrapper.defaultNomenCode).to.equal(owlterms.ICZN_CODE);\n        });\n      });\n\n      describe('when a new internal specifier is added using .internalSpecifiers', function () {\n        it('should return a list with the new specifier', function () {\n          wrapper.internalSpecifiers.push(specifier4);\n          expect(wrapper.specifiers).to.deep.equal([specifier4, specifier3, specifier2]);\n        });\n\n        it('should return three nomenclatural codes, one for each specifier', function () {\n          expect(wrapper.uniqNomenCodes).to.have.lengthOf(3);\n          expect(wrapper.uniqNomenCodes).to.include(owlterms.ICZN_CODE);\n          expect(wrapper.uniqNomenCodes).to.include(owlterms.UNKNOWN_CODE);\n          expect(wrapper.uniqNomenCodes).to.include(owlterms.ICN_CODE);\n        });\n\n        it('should change to a default nomenclatural code of owlterms.UNKNOWN_CODE', function () {\n          expect(wrapper.defaultNomenCode).to.equal(owlterms.UNKNOWN_CODE);\n        });\n      });\n\n      describe('when specifiers are deleted using .deleteSpecifier', function () {\n        it('should return the updated list', function () {\n          // Delete an external specifier.\n          wrapper.deleteSpecifier(specifier2);\n          // Delete an internal specifier.\n          wrapper.deleteSpecifier(specifier4);\n\n          // Only the first specifier should be left.\n          expect(wrapper.specifiers).to.deep.equal([specifier3]);\n        });\n      });\n\n      describe('when a specifier is added using .externalSpecifiers', function () {\n        it('should return the updated list', function () {\n          wrapper.externalSpecifiers.push(specifier1);\n          expect(wrapper.specifiers).to.deep.equal([specifier3, specifier1]);\n        });\n      });\n\n      describe('when a specifier is changed to an internal specifier using .setSpecifierType', function () {\n        it('should remain in the list of specifiers', function () {\n          wrapper.setSpecifierType(specifier1, 'Internal');\n          expect(wrapper.specifiers).to.deep.equal([specifier1, specifier3]);\n        });\n      });\n\n      describe('when a specifier is added using .internalSpecifiers', function () {\n        it('should be included in the list of all specifiers', function () {\n          wrapper.internalSpecifiers.push(specifier2);\n          expect(wrapper.specifiers).to.deep.equal([specifier1, specifier2, specifier3]);\n        });\n      });\n    });\n\n    describe('#getSpecifierType', function () {\n      it('should return the correct specifier type for each specifier', function () {\n        expect(wrapper.getSpecifierType(specifier1)).to.equal('Internal');\n        expect(wrapper.getSpecifierType(specifier2)).to.equal('Internal');\n        expect(wrapper.getSpecifierType(specifier3)).to.equal('External');\n      });\n    });\n\n    describe('#getSpecifierLabel as TaxonomicUnitWrapper', function () {\n      it('should return the correct label for each specifier', function () {\n        expect((new phyx.TaxonomicUnitWrapper(specifier1)).label).to.equal('Specimen MVZ:225749');\n        expect((new phyx.TaxonomicUnitWrapper(specifier2)).label).to.equal('Specimen MVZ:191016');\n        expect((new phyx.TaxonomicUnitWrapper(specifier3)).label).to.equal('Rana boylii');\n      });\n    });\n  });\n\n  describe('given a particular phylogeny', function () {\n    // Some phylogenies to use in testing.\n    const phylogeny1 = {\n      newick: '((MVZ225749, MVZ191016)Test, \"Rana boylii\")',\n      additionalNodeProperties: {\n        Test: {\n          expectedPhyloreferenceNamed: 'phyloref1',\n        },\n      },\n    };\n\n    describe('#getExpectedNodeLabels', function () {\n      it('should be able to determine expected node labels for a phylogeny', function () {\n        const phyloref1 = new phyx.PhylorefWrapper({\n          label: 'phyloref1',\n          internalSpecifiers: [specifier1, specifier2],\n          externalSpecifiers: [specifier3],\n        });\n\n        expect(phyloref1.getExpectedNodeLabels(phylogeny1))\n          .to.deep.equal(['Test']);\n      });\n    });\n  });\n\n  describe('given an empty phyloreference', function () {\n    const wrapper = new phyx.PhylorefWrapper({});\n\n    describe('#getCurrentStatus', function () {\n      it('should return \"pso:draft\" as the default initial status', function () {\n        // Initially, an empty phyloref should report a status of 'pso:draft'.\n        expect(wrapper.getCurrentStatus().statusCURIE).to.equal('pso:draft');\n      });\n    });\n\n    describe('#setStatus', function () {\n      it('should throw an error if given a mistyped status', function () {\n        expect(function () { wrapper.setStatus('pso:retracted-from_publication'); })\n          .to.throw(\n            TypeError,\n            'setStatus() called with invalid status CURIE \\'pso:retracted-from_publication\\'',\n            'PhylorefWrapper throws TypeError on a mistyped status'\n          );\n      });\n    });\n\n    describe('#getStatusChanges', function () {\n      it('should return the empty list', function () {\n        expect(wrapper.getStatusChanges()).to.be.empty;\n      });\n\n      describe('when modified by using .setStatus', function () {\n        it('should return the updated list', function () {\n          wrapper.setStatus('pso:final-draft');\n          wrapper.setStatus('pso:under-review');\n          wrapper.setStatus('pso:submitted');\n          wrapper.setStatus('pso:published');\n          wrapper.setStatus('pso:retracted-from-publication');\n\n          // And see if we get the statuses back in the correct order.\n          const statusChanges = wrapper.getStatusChanges();\n          expect(statusChanges.length, 'number of status changes should be 5').to.equal(5);\n          expect(statusChanges[0].statusCURIE, 'first status change should be \"pso:final-draft\"').to.equal('pso:final-draft');\n          expect(statusChanges[1].statusCURIE, 'second status change should be \"pso:under-review\"').to.equal('pso:under-review');\n          expect(statusChanges[2].statusCURIE, 'third status change should be a \"pso:submitted\"').to.equal('pso:submitted');\n          expect(statusChanges[3].statusCURIE, 'fourth status change should be a \"pso:published\"').to.equal('pso:published');\n          expect(statusChanges[4].statusCURIE, 'fifth status change should be a \"pso:retracted-from-publication\"').to.equal('pso:retracted-from-publication');\n        });\n      });\n    });\n  });\n\n  describe('#asJSONLD', function () {\n    it('should preserve an existing @id on input phylorefs', function () {\n      const jsonld = new phyx.PhylorefWrapper({\n        '@id': '#providedId',\n        internalSpecifiers: [specifier1],\n        externalSpecifiers: [specifier2],\n      }).asJSONLD('#phyloref0');\n      expect(jsonld).to.have.property('@id');\n      expect(jsonld['@id']).to.equal('#providedId');\n    });\n    it('should generate a new @id on input phylorefs', function () {\n      const jsonld = new phyx.PhylorefWrapper({\n        internalSpecifiers: [specifier1],\n        externalSpecifiers: [specifier2],\n      }).asJSONLD('#phyloref0');\n      expect(jsonld).to.have.property('@id');\n      expect(jsonld['@id']).to.equal('#phyloref0');\n    });\n    it('should generate the expected equivClass expression for 1 int, 1 ext phyloref', function () {\n      const jsonld = new phyx.PhylorefWrapper({\n        internalSpecifiers: [specifier1],\n        externalSpecifiers: [specifier2],\n      }).asJSONLD('#');\n      expect(jsonld).to.have.property('equivalentClass');\n      expect(jsonld.equivalentClass).to.deep.equal({\n        '@type': owlterms.OWL_CLASS,\n        intersectionOf: [\n          {\n            '@type': owlterms.OWL_RESTRICTION,\n            onProperty: owlterms.PHYLOREF_INCLUDES_TU,\n            someValuesFrom: {\n              '@type': owlterms.OWL_RESTRICTION,\n              hasValue: 'MVZ:225749',\n              onProperty: owlterms.DWC_OCCURRENCE_ID,\n            },\n          },\n          {\n            '@type': owlterms.OWL_RESTRICTION,\n            onProperty: owlterms.PHYLOREF_EXCLUDES_TU,\n            someValuesFrom: {\n              '@type': owlterms.OWL_RESTRICTION,\n              hasValue: 'MVZ:191016',\n              onProperty: owlterms.DWC_OCCURRENCE_ID,\n            },\n          },\n        ],\n      });\n    });\n\n    it('should generate the expected equivClass expression for 2 int phyloref', function () {\n      const jsonld = new phyx.PhylorefWrapper({\n        internalSpecifiers: [specifier2, specifier3],\n      }).asJSONLD('#');\n      expect(jsonld).to.have.property('equivalentClass');\n      expect(jsonld.equivalentClass).to.deep.equal({\n        '@type': owlterms.OWL_RESTRICTION,\n        onProperty: owlterms.CDAO_HAS_CHILD,\n        someValuesFrom: {\n          '@type': owlterms.OWL_CLASS,\n          intersectionOf: [\n            {\n              '@type': owlterms.OWL_RESTRICTION,\n              onProperty: owlterms.PHYLOREF_EXCLUDES_TU,\n              someValuesFrom: {\n                '@type': owlterms.OWL_RESTRICTION,\n                hasValue: 'MVZ:191016',\n                onProperty: owlterms.DWC_OCCURRENCE_ID,\n              },\n            },\n            {\n              '@type': owlterms.OWL_RESTRICTION,\n              onProperty: owlterms.PHYLOREF_INCLUDES_TU,\n              someValuesFrom: {\n                '@type': owlterms.OWL_RESTRICTION,\n                onProperty: owlterms.TDWG_VOC_HAS_NAME,\n                someValuesFrom: {\n                  '@type': owlterms.OWL_CLASS,\n                  intersectionOf: [{\n                    '@type': owlterms.OWL_RESTRICTION,\n                    hasValue: 'Rana boylii',\n                    onProperty: owlterms.TDWG_VOC_NAME_COMPLETE,\n                  }, {\n                    '@type': owlterms.OWL_RESTRICTION,\n                    hasValue: {\n                      '@id': owlterms.ICZN_CODE,\n                    },\n                    onProperty: owlterms.NOMENCLATURAL_CODE,\n                  }],\n                },\n              },\n            },\n          ],\n        },\n      });\n    });\n  });\n});\n",
    "static": true,
    "longname": "/home/runner/work/phyx.js/phyx.js/test/phylorefs.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 300,
    "kind": "test",
    "name": "describe62",
    "testId": 62,
    "memberof": "test/phylorefs.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/phylorefs.js~describe62",
    "access": null,
    "description": "PhylorefWrapper",
    "lineNumber": 26
  },
  {
    "__docId__": 301,
    "kind": "test",
    "name": "describe63",
    "testId": 63,
    "memberof": "test/phylorefs.js~describe62",
    "testDepth": 1,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63",
    "access": null,
    "description": "given an empty phyloreference",
    "lineNumber": 53
  },
  {
    "__docId__": 302,
    "kind": "test",
    "name": "describe64",
    "testId": 64,
    "memberof": "test/phylorefs.js~describe62.describe63",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe64",
    "access": null,
    "description": "#constructor",
    "lineNumber": 56
  },
  {
    "__docId__": 303,
    "kind": "test",
    "name": "it65",
    "testId": 65,
    "memberof": "test/phylorefs.js~describe62.describe63.describe64",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe64.it65",
    "access": null,
    "description": "should return a PhylorefWrapper",
    "lineNumber": 57
  },
  {
    "__docId__": 304,
    "kind": "test",
    "name": "describe66",
    "testId": 66,
    "memberof": "test/phylorefs.js~describe62.describe63",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe66",
    "access": null,
    "description": "#label",
    "lineNumber": 62
  },
  {
    "__docId__": 305,
    "kind": "test",
    "name": "it67",
    "testId": 67,
    "memberof": "test/phylorefs.js~describe62.describe63.describe66",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe66.it67",
    "access": null,
    "description": "should return undefined",
    "lineNumber": 63
  },
  {
    "__docId__": 306,
    "kind": "test",
    "name": "it68",
    "testId": 68,
    "memberof": "test/phylorefs.js~describe62.describe63.describe66",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe66.it68",
    "access": null,
    "description": "should be settable by assigning to .label",
    "lineNumber": 67
  },
  {
    "__docId__": 307,
    "kind": "test",
    "name": "describe69",
    "testId": 69,
    "memberof": "test/phylorefs.js~describe62.describe63",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe69",
    "access": null,
    "description": "#specifiers",
    "lineNumber": 73
  },
  {
    "__docId__": 308,
    "kind": "test",
    "name": "it70",
    "testId": 70,
    "memberof": "test/phylorefs.js~describe62.describe63.describe69",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe69.it70",
    "access": null,
    "description": "should initially return an empty list",
    "lineNumber": 74
  },
  {
    "__docId__": 309,
    "kind": "test",
    "name": "it71",
    "testId": 71,
    "memberof": "test/phylorefs.js~describe62.describe63.describe69",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe69.it71",
    "access": null,
    "description": "should initially return a nomenclatural code of unknown",
    "lineNumber": 78
  },
  {
    "__docId__": 310,
    "kind": "test",
    "name": "describe72",
    "testId": 72,
    "memberof": "test/phylorefs.js~describe62.describe63.describe69",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe69.describe72",
    "access": null,
    "description": "when a new external specifier is added using .externalSpecifiers",
    "lineNumber": 82
  },
  {
    "__docId__": 311,
    "kind": "test",
    "name": "it73",
    "testId": 73,
    "memberof": "test/phylorefs.js~describe62.describe63.describe69.describe72",
    "testDepth": 4,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe69.describe72.it73",
    "access": null,
    "description": "should return a list with the new specifier",
    "lineNumber": 83
  },
  {
    "__docId__": 312,
    "kind": "test",
    "name": "it74",
    "testId": 74,
    "memberof": "test/phylorefs.js~describe62.describe63.describe69.describe72",
    "testDepth": 4,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe69.describe72.it74",
    "access": null,
    "description": "should return a nomenclatural code of ICZN",
    "lineNumber": 88
  },
  {
    "__docId__": 313,
    "kind": "test",
    "name": "describe75",
    "testId": 75,
    "memberof": "test/phylorefs.js~describe62.describe63.describe69",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe69.describe75",
    "access": null,
    "description": "when a new external specifier is added using .externalSpecifiers",
    "lineNumber": 93
  },
  {
    "__docId__": 314,
    "kind": "test",
    "name": "it76",
    "testId": 76,
    "memberof": "test/phylorefs.js~describe62.describe63.describe69.describe75",
    "testDepth": 4,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe69.describe75.it76",
    "access": null,
    "description": "should return a list with the new specifier",
    "lineNumber": 94
  },
  {
    "__docId__": 315,
    "kind": "test",
    "name": "it77",
    "testId": 77,
    "memberof": "test/phylorefs.js~describe62.describe63.describe69.describe75",
    "testDepth": 4,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe69.describe75.it77",
    "access": null,
    "description": "should return two nomenclatural codes, one for each specifier",
    "lineNumber": 99
  },
  {
    "__docId__": 316,
    "kind": "test",
    "name": "it78",
    "testId": 78,
    "memberof": "test/phylorefs.js~describe62.describe63.describe69.describe75",
    "testDepth": 4,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe69.describe75.it78",
    "access": null,
    "description": "should still return a nomenclatural code of ICZN",
    "lineNumber": 105
  },
  {
    "__docId__": 317,
    "kind": "test",
    "name": "describe79",
    "testId": 79,
    "memberof": "test/phylorefs.js~describe62.describe63.describe69",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe69.describe79",
    "access": null,
    "description": "when a new internal specifier is added using .internalSpecifiers",
    "lineNumber": 110
  },
  {
    "__docId__": 318,
    "kind": "test",
    "name": "it80",
    "testId": 80,
    "memberof": "test/phylorefs.js~describe62.describe63.describe69.describe79",
    "testDepth": 4,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe69.describe79.it80",
    "access": null,
    "description": "should return a list with the new specifier",
    "lineNumber": 111
  },
  {
    "__docId__": 319,
    "kind": "test",
    "name": "it81",
    "testId": 81,
    "memberof": "test/phylorefs.js~describe62.describe63.describe69.describe79",
    "testDepth": 4,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe69.describe79.it81",
    "access": null,
    "description": "should return three nomenclatural codes, one for each specifier",
    "lineNumber": 116
  },
  {
    "__docId__": 320,
    "kind": "test",
    "name": "it82",
    "testId": 82,
    "memberof": "test/phylorefs.js~describe62.describe63.describe69.describe79",
    "testDepth": 4,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe69.describe79.it82",
    "access": null,
    "description": "should change to a default nomenclatural code of owlterms.UNKNOWN_CODE",
    "lineNumber": 123
  },
  {
    "__docId__": 321,
    "kind": "test",
    "name": "describe83",
    "testId": 83,
    "memberof": "test/phylorefs.js~describe62.describe63.describe69",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe69.describe83",
    "access": null,
    "description": "when specifiers are deleted using .deleteSpecifier",
    "lineNumber": 128
  },
  {
    "__docId__": 322,
    "kind": "test",
    "name": "it84",
    "testId": 84,
    "memberof": "test/phylorefs.js~describe62.describe63.describe69.describe83",
    "testDepth": 4,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe69.describe83.it84",
    "access": null,
    "description": "should return the updated list",
    "lineNumber": 129
  },
  {
    "__docId__": 323,
    "kind": "test",
    "name": "describe85",
    "testId": 85,
    "memberof": "test/phylorefs.js~describe62.describe63.describe69",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe69.describe85",
    "access": null,
    "description": "when a specifier is added using .externalSpecifiers",
    "lineNumber": 140
  },
  {
    "__docId__": 324,
    "kind": "test",
    "name": "it86",
    "testId": 86,
    "memberof": "test/phylorefs.js~describe62.describe63.describe69.describe85",
    "testDepth": 4,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe69.describe85.it86",
    "access": null,
    "description": "should return the updated list",
    "lineNumber": 141
  },
  {
    "__docId__": 325,
    "kind": "test",
    "name": "describe87",
    "testId": 87,
    "memberof": "test/phylorefs.js~describe62.describe63.describe69",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe69.describe87",
    "access": null,
    "description": "when a specifier is changed to an internal specifier using .setSpecifierType",
    "lineNumber": 147
  },
  {
    "__docId__": 326,
    "kind": "test",
    "name": "it88",
    "testId": 88,
    "memberof": "test/phylorefs.js~describe62.describe63.describe69.describe87",
    "testDepth": 4,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe69.describe87.it88",
    "access": null,
    "description": "should remain in the list of specifiers",
    "lineNumber": 148
  },
  {
    "__docId__": 327,
    "kind": "test",
    "name": "describe89",
    "testId": 89,
    "memberof": "test/phylorefs.js~describe62.describe63.describe69",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe69.describe89",
    "access": null,
    "description": "when a specifier is added using .internalSpecifiers",
    "lineNumber": 154
  },
  {
    "__docId__": 328,
    "kind": "test",
    "name": "it90",
    "testId": 90,
    "memberof": "test/phylorefs.js~describe62.describe63.describe69.describe89",
    "testDepth": 4,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe69.describe89.it90",
    "access": null,
    "description": "should be included in the list of all specifiers",
    "lineNumber": 155
  },
  {
    "__docId__": 329,
    "kind": "test",
    "name": "describe91",
    "testId": 91,
    "memberof": "test/phylorefs.js~describe62.describe63",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe91",
    "access": null,
    "description": "#getSpecifierType",
    "lineNumber": 162
  },
  {
    "__docId__": 330,
    "kind": "test",
    "name": "it92",
    "testId": 92,
    "memberof": "test/phylorefs.js~describe62.describe63.describe91",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe91.it92",
    "access": null,
    "description": "should return the correct specifier type for each specifier",
    "lineNumber": 163
  },
  {
    "__docId__": 331,
    "kind": "test",
    "name": "describe93",
    "testId": 93,
    "memberof": "test/phylorefs.js~describe62.describe63",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe93",
    "access": null,
    "description": "#getSpecifierLabel as TaxonomicUnitWrapper",
    "lineNumber": 170
  },
  {
    "__docId__": 332,
    "kind": "test",
    "name": "it94",
    "testId": 94,
    "memberof": "test/phylorefs.js~describe62.describe63.describe93",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe63.describe93.it94",
    "access": null,
    "description": "should return the correct label for each specifier",
    "lineNumber": 171
  },
  {
    "__docId__": 333,
    "kind": "test",
    "name": "describe95",
    "testId": 95,
    "memberof": "test/phylorefs.js~describe62",
    "testDepth": 1,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe95",
    "access": null,
    "description": "given a particular phylogeny",
    "lineNumber": 179
  },
  {
    "__docId__": 334,
    "kind": "test",
    "name": "describe96",
    "testId": 96,
    "memberof": "test/phylorefs.js~describe62.describe95",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe95.describe96",
    "access": null,
    "description": "#getExpectedNodeLabels",
    "lineNumber": 190
  },
  {
    "__docId__": 335,
    "kind": "test",
    "name": "it97",
    "testId": 97,
    "memberof": "test/phylorefs.js~describe62.describe95.describe96",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe95.describe96.it97",
    "access": null,
    "description": "should be able to determine expected node labels for a phylogeny",
    "lineNumber": 191
  },
  {
    "__docId__": 336,
    "kind": "test",
    "name": "describe98",
    "testId": 98,
    "memberof": "test/phylorefs.js~describe62",
    "testDepth": 1,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe98",
    "access": null,
    "description": "given an empty phyloreference",
    "lineNumber": 204
  },
  {
    "__docId__": 337,
    "kind": "test",
    "name": "describe99",
    "testId": 99,
    "memberof": "test/phylorefs.js~describe62.describe98",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe98.describe99",
    "access": null,
    "description": "#getCurrentStatus",
    "lineNumber": 207
  },
  {
    "__docId__": 338,
    "kind": "test",
    "name": "it100",
    "testId": 100,
    "memberof": "test/phylorefs.js~describe62.describe98.describe99",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe98.describe99.it100",
    "access": null,
    "description": "should return \"pso:draft\" as the default initial status",
    "lineNumber": 208
  },
  {
    "__docId__": 339,
    "kind": "test",
    "name": "describe101",
    "testId": 101,
    "memberof": "test/phylorefs.js~describe62.describe98",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe98.describe101",
    "access": null,
    "description": "#setStatus",
    "lineNumber": 214
  },
  {
    "__docId__": 340,
    "kind": "test",
    "name": "it102",
    "testId": 102,
    "memberof": "test/phylorefs.js~describe62.describe98.describe101",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe98.describe101.it102",
    "access": null,
    "description": "should throw an error if given a mistyped status",
    "lineNumber": 215
  },
  {
    "__docId__": 341,
    "kind": "test",
    "name": "describe103",
    "testId": 103,
    "memberof": "test/phylorefs.js~describe62.describe98",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe98.describe103",
    "access": null,
    "description": "#getStatusChanges",
    "lineNumber": 225
  },
  {
    "__docId__": 342,
    "kind": "test",
    "name": "it104",
    "testId": 104,
    "memberof": "test/phylorefs.js~describe62.describe98.describe103",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe98.describe103.it104",
    "access": null,
    "description": "should return the empty list",
    "lineNumber": 226
  },
  {
    "__docId__": 343,
    "kind": "test",
    "name": "describe105",
    "testId": 105,
    "memberof": "test/phylorefs.js~describe62.describe98.describe103",
    "testDepth": 3,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe98.describe103.describe105",
    "access": null,
    "description": "when modified by using .setStatus",
    "lineNumber": 230
  },
  {
    "__docId__": 344,
    "kind": "test",
    "name": "it106",
    "testId": 106,
    "memberof": "test/phylorefs.js~describe62.describe98.describe103.describe105",
    "testDepth": 4,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe98.describe103.describe105.it106",
    "access": null,
    "description": "should return the updated list",
    "lineNumber": 231
  },
  {
    "__docId__": 345,
    "kind": "test",
    "name": "describe107",
    "testId": 107,
    "memberof": "test/phylorefs.js~describe62",
    "testDepth": 1,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe107",
    "access": null,
    "description": "#asJSONLD",
    "lineNumber": 251
  },
  {
    "__docId__": 346,
    "kind": "test",
    "name": "it108",
    "testId": 108,
    "memberof": "test/phylorefs.js~describe62.describe107",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe107.it108",
    "access": null,
    "description": "should preserve an existing @id on input phylorefs",
    "lineNumber": 252
  },
  {
    "__docId__": 347,
    "kind": "test",
    "name": "it109",
    "testId": 109,
    "memberof": "test/phylorefs.js~describe62.describe107",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe107.it109",
    "access": null,
    "description": "should generate a new @id on input phylorefs",
    "lineNumber": 261
  },
  {
    "__docId__": 348,
    "kind": "test",
    "name": "it110",
    "testId": 110,
    "memberof": "test/phylorefs.js~describe62.describe107",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe107.it110",
    "access": null,
    "description": "should generate the expected equivClass expression for 1 int, 1 ext phyloref",
    "lineNumber": 269
  },
  {
    "__docId__": 349,
    "kind": "test",
    "name": "it111",
    "testId": 111,
    "memberof": "test/phylorefs.js~describe62.describe107",
    "testDepth": 2,
    "static": true,
    "longname": "test/phylorefs.js~describe62.describe107.it111",
    "access": null,
    "description": "should generate the expected equivClass expression for 2 int phyloref",
    "lineNumber": 300
  },
  {
    "__docId__": 350,
    "kind": "testFile",
    "name": "test/scripts/phyx2owl.js",
    "content": "/*\n * Test conversion to OWL using the phyx2owl.js script.\n */\n\nconst child = require('child_process');\nconst path = require('path');\nconst fs = require('fs');\n\nconst chai = require('chai');\n\nconst expect = chai.expect;\n\n/*\n * Test whether we can convert Phyx files to OWL in JSON-LD using phyx2owl.js.\n */\n\nconst PHYX2OWL_JS = 'bin/phyx2owl.js';\n\ndescribe(PHYX2OWL_JS, function () {\n  it('should work without any arguments', function () {\n    const result = child.spawnSync(PHYX2OWL_JS, [], {\n      encoding: 'utf-8',\n      stdio: 'pipe',\n    });\n    expect(result.status).to.equal(1);\n    expect(result.stdout).to.be.empty;\n    expect(result.stderr).to.contain('No input files provided.');\n  });\n  it('should support `--help`', function () {\n    const result = child.spawnSync(PHYX2OWL_JS, ['--help'], {\n      encoding: 'utf-8',\n      stdio: 'pipe',\n    });\n    expect(result.status).to.equal(0);\n    expect(result.stderr).to.be.empty;\n    expect(result.stdout).to.contain('phyx2owl.js [files or directories to convert into OWL ontologies]');\n  });\n  it('should be able to convert `brochu_2003.json`', function () {\n    const PHYX_FILE = path.resolve(__dirname, '../examples/correct/brochu_2003.json');\n    const OWL_FILE = path.resolve(__dirname, '../examples/correct/brochu_2003.owl');\n    const EXPECTED_OWL_FILE = path.resolve(__dirname, '../examples/correct/brochu_2003.jsonld');\n\n    // If there is already a '../examples/brochu_2003.json' file, we should delete it.\n    if (fs.existsSync(OWL_FILE)) fs.unlinkSync(OWL_FILE);\n    expect(fs.existsSync(OWL_FILE)).to.be.false;\n\n    // Convert brochu_2003.json to brochu_2003.owl.\n    // Because of the way in which we test brochu_2003.owl in test/examples.js,\n    // we need to set a base IRI as well.\n    const result = child.spawnSync(PHYX2OWL_JS, [PHYX_FILE, '--base-iri', 'http://example.org/brochu_2003.json#'], {\n      encoding: 'utf-8',\n      stdio: 'pipe',\n    });\n    expect(result.status).to.equal(0);\n    expect(result.stdout).to.contain('1 files converted successfully.');\n    expect(result.stderr).to.be.empty;\n\n    expect(fs.existsSync(OWL_FILE), `File ${OWL_FILE} was not generated.`).to.be.true;\n\n    // Make sure that the generated file *looks* like a JSON-LD file.\n    const jsonldContent = JSON.parse(fs.readFileSync(OWL_FILE, 'utf8'));\n    expect(jsonldContent).to.be.an('object').that.has.any.keys('@context');\n    expect(jsonldContent['@context']).to.not.be.empty;\n\n    // Make sure that the generated file is identical to the expected one.\n    const expectedContent = JSON.parse(fs.readFileSync(EXPECTED_OWL_FILE, 'utf8'));\n    expect(jsonldContent).to.deep.equal(expectedContent);\n  });\n  it('should be able to convert the entire `test/examples/correct` directory', function () {\n    const EXAMPLE_DIR = path.resolve(__dirname, '../examples/correct');\n    const jsonFilesInExamples = fs.readdirSync(EXAMPLE_DIR, 'utf8')\n      .filter(fileName => fileName.toLowerCase().endsWith('.json'));\n\n    const result = child.spawnSync(PHYX2OWL_JS, [EXAMPLE_DIR], {\n      encoding: 'utf-8',\n      stdio: 'pipe',\n    });\n    expect(result.status).to.equal(0);\n    expect(result.stdout).to.match(/\\d+ files converted successfully./);\n    expect(result.stderr).to.be.empty;\n\n    const regexMatch = result.stdout.match(/(\\d+) files converted successfully./);\n    const fileCount = Number(regexMatch[1]);\n    expect(fileCount).to.be.greaterThan(0);\n    expect(fileCount).to.equal(jsonFilesInExamples.length);\n\n    // Make sure that the generated files *look* like JSON-LD files.\n    const jsonldInExamples = fs.readdirSync(EXAMPLE_DIR, 'utf8')\n      .filter(fileName => fileName.toLowerCase().endsWith('.owl'))\n      .map(owlFilename => JSON.parse(fs.readFileSync(path.resolve(EXAMPLE_DIR, owlFilename), 'utf8')));\n\n    jsonldInExamples.forEach((jsonld) => {\n      expect(jsonld).to.be.an('object').that.has.any.keys('@context');\n      expect(jsonld['@context']).to.not.be.empty;\n    });\n  });\n  // This is where we should test the recursive directory functionality. However,\n  // doing that would require using `test/examples` (which isn't recursive),\n  // using `test/` or the root project directory (potentially messing with other\n  // test scripts). We could potentially create a separate recursive hierarchy to\n  // test this, but that seems unnecessary. So we won't test this functionality\n  // for now, but will add a test if we find a replicable bug in the future.\n  it('should give an error if no JSON files could be found', function () {\n    const result = child.spawnSync(PHYX2OWL_JS, [__dirname], {\n      encoding: 'utf-8',\n      stdio: 'pipe',\n    });\n    expect(result.status).to.equal(1);\n    expect(result.stdout).to.be.empty;\n    expect(result.stderr).to.contain('Input files do not exist or consist of directories that do not contain JSON files: ');\n  });\n});\n",
    "static": true,
    "longname": "/home/runner/work/phyx.js/phyx.js/test/scripts/phyx2owl.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 351,
    "kind": "test",
    "name": "describe112",
    "testId": 112,
    "memberof": "test/scripts/phyx2owl.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/scripts/phyx2owl.js~describe112",
    "access": null,
    "lineNumber": 19
  },
  {
    "__docId__": 352,
    "kind": "test",
    "name": "it113",
    "testId": 113,
    "memberof": "test/scripts/phyx2owl.js~describe112",
    "testDepth": 1,
    "static": true,
    "longname": "test/scripts/phyx2owl.js~describe112.it113",
    "access": null,
    "description": "should work without any arguments",
    "lineNumber": 20
  },
  {
    "__docId__": 353,
    "kind": "test",
    "name": "it114",
    "testId": 114,
    "memberof": "test/scripts/phyx2owl.js~describe112",
    "testDepth": 1,
    "static": true,
    "longname": "test/scripts/phyx2owl.js~describe112.it114",
    "access": null,
    "description": "should support `--help`",
    "lineNumber": 29
  },
  {
    "__docId__": 354,
    "kind": "test",
    "name": "it115",
    "testId": 115,
    "memberof": "test/scripts/phyx2owl.js~describe112",
    "testDepth": 1,
    "static": true,
    "longname": "test/scripts/phyx2owl.js~describe112.it115",
    "access": null,
    "description": "should be able to convert `brochu_2003.json`",
    "lineNumber": 38
  },
  {
    "__docId__": 355,
    "kind": "test",
    "name": "it116",
    "testId": 116,
    "memberof": "test/scripts/phyx2owl.js~describe112",
    "testDepth": 1,
    "static": true,
    "longname": "test/scripts/phyx2owl.js~describe112.it116",
    "access": null,
    "description": "should be able to convert the entire `test/examples/correct` directory",
    "lineNumber": 69
  },
  {
    "__docId__": 356,
    "kind": "test",
    "name": "it117",
    "testId": 117,
    "memberof": "test/scripts/phyx2owl.js~describe112",
    "testDepth": 1,
    "static": true,
    "longname": "test/scripts/phyx2owl.js~describe112.it117",
    "access": null,
    "description": "should give an error if no JSON files could be found",
    "lineNumber": 103
  },
  {
    "__docId__": 357,
    "kind": "testFile",
    "name": "test/scripts/resolve.js",
    "content": "/*\n * Test resolution against the Open Tree of Life via the resolve script.\n */\n\nconst child = require('child_process');\nconst path = require('path');\n\nconst lodash = require('lodash');\nconst chai = require('chai');\n\nconst expect = chai.expect;\n\n/*\n * Test whether we can use the resolve script to resolve phylorefs against\n * the Open Tree of Life.\n */\n\nconst RESOLVE_JS = 'bin/resolve.js';\n\ndescribe('bin/resolve.js', function () {\n  it('should work without any arguments', function () {\n    const result = child.spawnSync(RESOLVE_JS, [], {\n      encoding: 'utf-8',\n      stdio: 'pipe',\n    });\n    expect(result.status).to.equal(1);\n    expect(result.stdout).to.be.empty;\n    expect(result.stderr).to.contain('No input files provided.');\n  });\n  it('should support `--help`', function () {\n    const result = child.spawnSync(RESOLVE_JS, ['--help'], {\n      encoding: 'utf-8',\n      stdio: 'pipe',\n    });\n    expect(result.status).to.equal(0);\n    expect(result.stderr).to.be.empty;\n    expect(result.stdout).to.contain('resolve.js [files to resolve on the Open Tree of Life]');\n  });\n  it('should provide the expected results on the `brochu_2003.json` example file', function () {\n    var resultObj; // eslint-disable-line no-var\n\n    this.timeout(20000); // Take up to 20 seconds to run this.\n\n    const result = child.spawnSync(RESOLVE_JS, [path.resolve(__dirname, '../examples/correct/brochu_2003.json')], {\n      encoding: 'utf-8',\n      stdio: 'pipe',\n    });\n    expect(result.status).to.equal(0);\n    expect(result.stderr).to.be.empty;\n\n    expect(function () {\n      resultObj = JSON.parse(result.stdout);\n    }).to.not.throw(SyntaxError);\n\n    expect(lodash.keys(resultObj)).to.have.members([\n      'Alligatoridae',\n      'Alligatorinae',\n      'Caimaninae',\n      'Crocodyloidea',\n      'Crocodylidae',\n      'Diplocynodontinae',\n    ]);\n\n    expect(resultObj.Alligatoridae[0].resolved).to.include({\n      '@id': 'https://tree.opentreeoflife.org/opentree/argus/opentree12.3@ott195670',\n      label: 'Alligatoridae',\n    });\n    expect(resultObj.Alligatorinae[0].resolved).to.include({\n      '@id': 'https://tree.opentreeoflife.org/opentree/argus/opentree12.3@ott151255',\n      label: 'Alligatorinae',\n    });\n    expect(resultObj.Crocodylidae[0].resolved).to.include({\n      '@id': 'https://tree.opentreeoflife.org/opentree/argus/opentree12.3@ott1092501',\n      label: 'Longirostres',\n    });\n    expect(resultObj.Diplocynodontinae[0]).to.include({\n      error: 'no_mrca_found:400',\n    });\n  });\n  it('should correctly report errors with certain phyloreferences', function () {\n    var resultObj; // eslint-disable-line no-var\n\n    this.timeout(20000); // Take up to 20 seconds to run this.\n\n    const result = child.spawnSync(RESOLVE_JS, [path.resolve(__dirname, '../examples/incorrect/otl-resolution-errors.json')], {\n      encoding: 'utf-8',\n      stdio: 'pipe',\n    });\n    expect(result.status).to.equal(0);\n    expect(result.stderr).to.be.empty;\n\n    expect(function () {\n      resultObj = JSON.parse(result.stdout);\n    }).to.not.throw(SyntaxError);\n\n    expect(lodash.keys(resultObj)).to.have.members([\n      'SingleSpecifier',\n      'TaxonNameNotFound',\n      'Produces404OnOTR',\n    ]);\n\n    // console.log(JSON.stringify(resultObj, null, 2));\n\n    expect(resultObj.SingleSpecifier[0]).to.include({\n      error: 'one_internal_specifier_with_no_external_specifiers',\n    });\n\n    expect(resultObj.TaxonNameNotFound[0]).to.include({\n      error: 'internal_specifiers_missing',\n    });\n\n    expect(resultObj.Produces404OnOTR[0]).to.include({\n      error: 'no_mrca_found:404',\n    });\n  });\n});\n",
    "static": true,
    "longname": "/home/runner/work/phyx.js/phyx.js/test/scripts/resolve.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 358,
    "kind": "test",
    "name": "describe118",
    "testId": 118,
    "memberof": "test/scripts/resolve.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/scripts/resolve.js~describe118",
    "access": null,
    "description": "bin/resolve.js",
    "lineNumber": 20
  },
  {
    "__docId__": 359,
    "kind": "test",
    "name": "it119",
    "testId": 119,
    "memberof": "test/scripts/resolve.js~describe118",
    "testDepth": 1,
    "static": true,
    "longname": "test/scripts/resolve.js~describe118.it119",
    "access": null,
    "description": "should work without any arguments",
    "lineNumber": 21
  },
  {
    "__docId__": 360,
    "kind": "test",
    "name": "it120",
    "testId": 120,
    "memberof": "test/scripts/resolve.js~describe118",
    "testDepth": 1,
    "static": true,
    "longname": "test/scripts/resolve.js~describe118.it120",
    "access": null,
    "description": "should support `--help`",
    "lineNumber": 30
  },
  {
    "__docId__": 361,
    "kind": "test",
    "name": "it121",
    "testId": 121,
    "memberof": "test/scripts/resolve.js~describe118",
    "testDepth": 1,
    "static": true,
    "longname": "test/scripts/resolve.js~describe118.it121",
    "access": null,
    "description": "should provide the expected results on the `brochu_2003.json` example file",
    "lineNumber": 39
  },
  {
    "__docId__": 362,
    "kind": "test",
    "name": "it122",
    "testId": 122,
    "memberof": "test/scripts/resolve.js~describe118",
    "testDepth": 1,
    "static": true,
    "longname": "test/scripts/resolve.js~describe118.it122",
    "access": null,
    "description": "should correctly report errors with certain phyloreferences",
    "lineNumber": 80
  },
  {
    "__docId__": 363,
    "kind": "testFile",
    "name": "test/specimens.js",
    "content": "/*\n * Test specimen processing.\n */\n\nconst chai = require('chai');\nconst phyx = require('../src');\n\nconst expect = chai.expect;\n\n/*\n * Test whether SpecimenWrapper can parse specimen identifiers from simple specimen\n * identifiers, from institutionCode:catalogNumber format, and from Darwin Core triples.\n * However, URNs and HTTP URLs should not be accidentally parsed as Darwin Core triples.\n */\n\ndescribe('SpecimenWrapper', function () {\n  describe('#constructor', function () {\n    it('should be able to wrap an empty specimen', function () {\n      const wrapped = new phyx.SpecimenWrapper({});\n\n      expect(wrapped).to.be.an.instanceOf(phyx.SpecimenWrapper);\n      expect(wrapped.occurrenceID).to.be.undefined;\n    });\n    it('should be able to extract an occurenceID and catalogNumber from simple specimen IDs', function () {\n      const wrapper = new phyx.SpecimenWrapper({\n        occurrenceID: 'Wall 2527, Fiji (uc)',\n        'dwc:basisOfRecord': 'PreservedSpecimen',\n      });\n      expect(wrapper.occurrenceID).to.equal('Wall 2527, Fiji (uc)');\n      expect(wrapper.catalogNumber).to.equal('Wall 2527, Fiji (uc)');\n      expect(wrapper.basisOfRecord).to.equal('PreservedSpecimen');\n    });\n    it('should extract institutionCode and catalogNumber from a institutionCode:catalogNumber combination', function () {\n      const wrapper = new phyx.SpecimenWrapper({\n        occurrenceID: 'FMNH:PR 2081',\n        'dwc:basisOfRecord': 'PreservedSpecimen',\n      });\n      expect(wrapper.occurrenceID).to.equal('FMNH:PR 2081');\n      expect(wrapper.institutionCode).to.equal('FMNH');\n      expect(wrapper.catalogNumber).to.equal('PR 2081');\n      expect(wrapper.basisOfRecord).to.equal('PreservedSpecimen');\n    });\n    it('should extract occurenceID, institutionCode and catalogNumber from Darwin Core triples', function () {\n      const wrapper = new phyx.SpecimenWrapper({\n        occurrenceID: 'FMNH:PR:2081',\n      });\n      expect(wrapper.occurrenceID).to.equal('FMNH:PR:2081');\n      expect(wrapper.institutionCode).to.equal('FMNH');\n      expect(wrapper.collectionCode).to.equal('PR');\n      expect(wrapper.catalogNumber).to.equal('2081');\n      expect(wrapper.basisOfRecord).to.be.undefined;\n    });\n    it('should be able to extract the same occurrenceID from different representations', function () {\n      expect(new phyx.SpecimenWrapper({ occurrenceID: 'urn:catalog:::MVZ225749' }).occurrenceID)\n        .to.equal('urn:catalog:::MVZ225749');\n      expect(new phyx.SpecimenWrapper({ catalogNumber: 'MVZ225749' }).occurrenceID)\n        .to.equal('urn:catalog:::MVZ225749');\n    });\n    it('should not attempt to split a URN into occurenceID, institutionCode and catalogNumber', function () {\n      const wrapper = new phyx.SpecimenWrapper({\n        occurrenceID: 'urn:lsid:biocol.org:col:34777',\n      });\n      expect(wrapper.occurrenceID).to.equal('urn:lsid:biocol.org:col:34777');\n      expect(wrapper.institutionCode).to.be.undefined;\n      expect(wrapper.collectionCode).to.be.undefined;\n      expect(wrapper.catalogNumber).to.be.undefined;\n    });\n    it('should not attempt to split a URL into occurenceID, institutionCode and catalogNumber', function () {\n      const wrapper = new phyx.SpecimenWrapper({\n        occurrenceID: 'http://arctos.database.museum/guid/MVZ:Herp:148929?seid=886464',\n      });\n      expect(wrapper.occurrenceID).to.equal('http://arctos.database.museum/guid/MVZ:Herp:148929?seid=886464');\n      expect(wrapper.institutionCode).to.be.undefined;\n      expect(wrapper.collectionCode).to.be.undefined;\n      expect(wrapper.catalogNumber).to.be.undefined;\n    });\n    it('should be able to create a specimen JSON record from an occurrence ID', function () {\n      const specimen = phyx.SpecimenWrapper.fromOccurrenceID('FMNH:PR:2081');\n      expect(specimen.occurrenceID).to.equal('FMNH:PR:2081');\n      expect(specimen.institutionCode).to.equal('FMNH');\n      expect(specimen.collectionCode).to.equal('PR');\n      expect(specimen.catalogNumber).to.equal('2081');\n      expect(specimen['dwc:basisOfRecord']).to.equal('PreservedSpecimen');\n    });\n  });\n});\n",
    "static": true,
    "longname": "/home/runner/work/phyx.js/phyx.js/test/specimens.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 364,
    "kind": "test",
    "name": "describe123",
    "testId": 123,
    "memberof": "test/specimens.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/specimens.js~describe123",
    "access": null,
    "description": "SpecimenWrapper",
    "lineNumber": 16
  },
  {
    "__docId__": 365,
    "kind": "test",
    "name": "describe124",
    "testId": 124,
    "memberof": "test/specimens.js~describe123",
    "testDepth": 1,
    "static": true,
    "longname": "test/specimens.js~describe123.describe124",
    "access": null,
    "description": "#constructor",
    "lineNumber": 17
  },
  {
    "__docId__": 366,
    "kind": "test",
    "name": "it125",
    "testId": 125,
    "memberof": "test/specimens.js~describe123.describe124",
    "testDepth": 2,
    "static": true,
    "longname": "test/specimens.js~describe123.describe124.it125",
    "access": null,
    "description": "should be able to wrap an empty specimen",
    "lineNumber": 18
  },
  {
    "__docId__": 367,
    "kind": "test",
    "name": "it126",
    "testId": 126,
    "memberof": "test/specimens.js~describe123.describe124",
    "testDepth": 2,
    "static": true,
    "longname": "test/specimens.js~describe123.describe124.it126",
    "access": null,
    "description": "should be able to extract an occurenceID and catalogNumber from simple specimen IDs",
    "lineNumber": 24
  },
  {
    "__docId__": 368,
    "kind": "test",
    "name": "it127",
    "testId": 127,
    "memberof": "test/specimens.js~describe123.describe124",
    "testDepth": 2,
    "static": true,
    "longname": "test/specimens.js~describe123.describe124.it127",
    "access": null,
    "description": "should extract institutionCode and catalogNumber from a institutionCode:catalogNumber combination",
    "lineNumber": 33
  },
  {
    "__docId__": 369,
    "kind": "test",
    "name": "it128",
    "testId": 128,
    "memberof": "test/specimens.js~describe123.describe124",
    "testDepth": 2,
    "static": true,
    "longname": "test/specimens.js~describe123.describe124.it128",
    "access": null,
    "description": "should extract occurenceID, institutionCode and catalogNumber from Darwin Core triples",
    "lineNumber": 43
  },
  {
    "__docId__": 370,
    "kind": "test",
    "name": "it129",
    "testId": 129,
    "memberof": "test/specimens.js~describe123.describe124",
    "testDepth": 2,
    "static": true,
    "longname": "test/specimens.js~describe123.describe124.it129",
    "access": null,
    "description": "should be able to extract the same occurrenceID from different representations",
    "lineNumber": 53
  },
  {
    "__docId__": 371,
    "kind": "test",
    "name": "it130",
    "testId": 130,
    "memberof": "test/specimens.js~describe123.describe124",
    "testDepth": 2,
    "static": true,
    "longname": "test/specimens.js~describe123.describe124.it130",
    "access": null,
    "description": "should not attempt to split a URN into occurenceID, institutionCode and catalogNumber",
    "lineNumber": 59
  },
  {
    "__docId__": 372,
    "kind": "test",
    "name": "it131",
    "testId": 131,
    "memberof": "test/specimens.js~describe123.describe124",
    "testDepth": 2,
    "static": true,
    "longname": "test/specimens.js~describe123.describe124.it131",
    "access": null,
    "description": "should not attempt to split a URL into occurenceID, institutionCode and catalogNumber",
    "lineNumber": 68
  },
  {
    "__docId__": 373,
    "kind": "test",
    "name": "it132",
    "testId": 132,
    "memberof": "test/specimens.js~describe123.describe124",
    "testDepth": 2,
    "static": true,
    "longname": "test/specimens.js~describe123.describe124.it132",
    "access": null,
    "description": "should be able to create a specimen JSON record from an occurrence ID",
    "lineNumber": 77
  },
  {
    "__docId__": 374,
    "kind": "testFile",
    "name": "test/taxon-names.js",
    "content": "/*\n * Test taxon name processing.\n */\n\nconst chai = require('chai');\nconst phyx = require('../src');\nconst owlterms = require('../src/utils/owlterms');\n\nconst expect = chai.expect;\n\n/*\n * Test whether TaxonNameWrapper parses taxon names correctly.\n */\n\ndescribe('TaxonNameWrapper', function () {\n  describe('#constructor', function () {\n    it('should accept empty taxon names without errors', function () {\n      const wrapper = new phyx.TaxonNameWrapper({});\n\n      expect(wrapper).to.be.an.instanceOf(phyx.TaxonNameWrapper);\n      expect(wrapper.nameComplete).to.be.undefined;\n    });\n    it('should be able to parse uninomial names as such', function () {\n      const wrapper = new phyx.TaxonNameWrapper({\n        nameComplete: 'Mus',\n      });\n\n      expect(wrapper.uninomial).to.equal('Mus');\n      expect(wrapper.genusPart).to.be.undefined;\n      expect(wrapper.specificEpithet).to.be.undefined;\n    });\n    it('should be able to parse binomial names into genus and specific epithet', function () {\n      const wrapper = new phyx.TaxonNameWrapper({\n        nameComplete: 'Mus musculus',\n      });\n\n      expect(wrapper.genusPart).to.equal('Mus');\n      expect(wrapper.specificEpithet).to.equal('musculus');\n    });\n    it('should be able to parse trinomial names into genus, specific epithet and infraspecific epithet', function () {\n      const wrapper = new phyx.TaxonNameWrapper({\n        nameComplete: 'Mus musculus domesticus',\n      });\n\n      expect(wrapper.genusPart).to.equal('Mus');\n      expect(wrapper.specificEpithet).to.equal('musculus');\n      expect(wrapper.infraspecificEpithet).to.equal('domesticus');\n    });\n    it('should ignore authority after a binomial name', function () {\n      const taxonName = phyx.TaxonNameWrapper.fromVerbatimName('Mus musculus Linnaeus, 1758');\n      expect(taxonName.nameComplete).to.equal('Mus musculus');\n      expect(taxonName.genusPart).to.equal('Mus');\n      expect(taxonName.specificEpithet).to.equal('musculus');\n      expect(taxonName.infraspecificEpithet).to.be.undefined;\n      expect(taxonName.uninomial).to.be.undefined;\n    });\n    it('should be able to use default nomenclatural codes', function () {\n      const taxonName = phyx.TaxonNameWrapper.fromVerbatimName('Mus musculus Linnaeus, 1758', owlterms.ICZN_CODE);\n      expect(taxonName.nameComplete).to.equal('Mus musculus');\n      expect(taxonName.nomenclaturalCode).to.equal(owlterms.ICZN_CODE);\n\n      const wrappedTaxonName = new phyx.TaxonNameWrapper(taxonName);\n      expect(wrappedTaxonName.nomenclaturalCode).to.equal(owlterms.ICZN_CODE);\n      expect(wrappedTaxonName.nomenclaturalCodeDetails).to.have.own.property('title');\n      expect(wrappedTaxonName.nomenclaturalCodeDetails.title).to.equal('International Code of Zoological Nomenclature');\n    });\n  });\n});\n",
    "static": true,
    "longname": "/home/runner/work/phyx.js/phyx.js/test/taxon-names.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 375,
    "kind": "test",
    "name": "describe133",
    "testId": 133,
    "memberof": "test/taxon-names.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/taxon-names.js~describe133",
    "access": null,
    "description": "TaxonNameWrapper",
    "lineNumber": 15
  },
  {
    "__docId__": 376,
    "kind": "test",
    "name": "describe134",
    "testId": 134,
    "memberof": "test/taxon-names.js~describe133",
    "testDepth": 1,
    "static": true,
    "longname": "test/taxon-names.js~describe133.describe134",
    "access": null,
    "description": "#constructor",
    "lineNumber": 16
  },
  {
    "__docId__": 377,
    "kind": "test",
    "name": "it135",
    "testId": 135,
    "memberof": "test/taxon-names.js~describe133.describe134",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxon-names.js~describe133.describe134.it135",
    "access": null,
    "description": "should accept empty taxon names without errors",
    "lineNumber": 17
  },
  {
    "__docId__": 378,
    "kind": "test",
    "name": "it136",
    "testId": 136,
    "memberof": "test/taxon-names.js~describe133.describe134",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxon-names.js~describe133.describe134.it136",
    "access": null,
    "description": "should be able to parse uninomial names as such",
    "lineNumber": 23
  },
  {
    "__docId__": 379,
    "kind": "test",
    "name": "it137",
    "testId": 137,
    "memberof": "test/taxon-names.js~describe133.describe134",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxon-names.js~describe133.describe134.it137",
    "access": null,
    "description": "should be able to parse binomial names into genus and specific epithet",
    "lineNumber": 32
  },
  {
    "__docId__": 380,
    "kind": "test",
    "name": "it138",
    "testId": 138,
    "memberof": "test/taxon-names.js~describe133.describe134",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxon-names.js~describe133.describe134.it138",
    "access": null,
    "description": "should be able to parse trinomial names into genus, specific epithet and infraspecific epithet",
    "lineNumber": 40
  },
  {
    "__docId__": 381,
    "kind": "test",
    "name": "it139",
    "testId": 139,
    "memberof": "test/taxon-names.js~describe133.describe134",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxon-names.js~describe133.describe134.it139",
    "access": null,
    "description": "should ignore authority after a binomial name",
    "lineNumber": 49
  },
  {
    "__docId__": 382,
    "kind": "test",
    "name": "it140",
    "testId": 140,
    "memberof": "test/taxon-names.js~describe133.describe134",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxon-names.js~describe133.describe134.it140",
    "access": null,
    "description": "should be able to use default nomenclatural codes",
    "lineNumber": 57
  },
  {
    "__docId__": 383,
    "kind": "testFile",
    "name": "test/taxonomic-units.js",
    "content": "/*\n * Test taxonomic unit construction and matching.\n */\n\nconst chai = require('chai');\nconst phyx = require('../src');\n\n// Use Chai's expect API.\nconst expect = chai.expect;\n\n/*\n * We primarily test two classes here:\n *  - TaxonomicUnitWrapper, which wraps a taxonomic unit and determines if it\n *    refers to a scientific name, specimen identifier or external reference,\n *    or a combination of these.\n *  - TaxonomicUnitMatcher, which accepts two taxonomic units and determines\n *    whether and for what reason the two can be matched.\n */\n\ndescribe('TaxonomicUnitWrapper', function () {\n  describe('#constructor given no arguments', function () {\n    it('should create an empty TaxonomicUnitWrapper without a defined label', function () {\n      // Empty TU without @type.\n      let wrapper = new phyx.TaxonomicUnitWrapper({});\n      expect(wrapper).to.be.instanceOf(phyx.TaxonomicUnitWrapper);\n      expect(wrapper.label).to.be.undefined;\n\n      // Empty TU with type TYPE_TAXON_CONCEPT.\n      wrapper = new phyx.TaxonomicUnitWrapper({\n        '@type': phyx.TaxonomicUnitWrapper.TYPE_TAXON_CONCEPT,\n      });\n      expect(wrapper).to.be.instanceOf(phyx.TaxonomicUnitWrapper);\n      expect(wrapper.label).to.be.undefined;\n\n      // Empty TU with type TYPE_SPECIMEN.\n      wrapper = new phyx.TaxonomicUnitWrapper({\n        '@type': phyx.TaxonomicUnitWrapper.TYPE_SPECIMEN,\n      });\n      expect(wrapper).to.be.instanceOf(phyx.TaxonomicUnitWrapper);\n      expect(wrapper.label).to.be.undefined;\n\n      // Empty TU with type TYPE_SPECIMEN and a taxonomic name.\n      wrapper = new phyx.TaxonomicUnitWrapper({\n        '@type': phyx.TaxonomicUnitWrapper.TYPE_SPECIMEN,\n        nameString: 'Taxonomic name',\n      });\n      expect(wrapper).to.be.instanceOf(phyx.TaxonomicUnitWrapper);\n      expect(wrapper.label).to.be.undefined;\n    });\n  });\n  describe('#label given a taxonomic unit', function () {\n    it('should return a wrapped scientific name', function () {\n      const wrapper = new phyx.TaxonomicUnitWrapper({\n        '@type': phyx.TaxonomicUnitWrapper.TYPE_TAXON_CONCEPT,\n        hasName: {\n          label: 'Ornithorhynchus anatinus (Shaw, 1799)',\n          nameComplete: 'Ornithorhynchus anatinus',\n        },\n      });\n      expect(wrapper.label).to.equal('Ornithorhynchus anatinus (Shaw, 1799)');\n    });\n    it('should return a wrapped specimen identifier preceded by \"Specimen\"', function () {\n      const wrapper = new phyx.TaxonomicUnitWrapper({\n        '@type': phyx.TaxonomicUnitWrapper.TYPE_SPECIMEN,\n        occurrenceID: 'MVZ 225749',\n      });\n      expect(wrapper.label).to.equal('Specimen MVZ 225749');\n    });\n    it('should return specimens with an occurrenceID as well as a taxon concept', function () {\n      const wrapper = new phyx.TaxonomicUnitWrapper({\n        '@type': [\n          phyx.TaxonomicUnitWrapper.TYPE_SPECIMEN,\n        ],\n        nameString: 'Rana luteiventris',\n        occurrenceID: 'MVZ 225749',\n      });\n      expect(wrapper.label).to.equal('Specimen MVZ 225749 identified as Rana luteiventris');\n    });\n    it('should ignore occurrence ID if typed as a taxon concept', function () {\n      const wrapper = new phyx.TaxonomicUnitWrapper({\n        '@type': phyx.TaxonomicUnitWrapper.TYPE_TAXON_CONCEPT,\n        nameString: 'Rana luteiventris',\n        occurrenceID: 'MVZ 225749',\n      });\n      expect(wrapper.label).to.equal('Rana luteiventris');\n    });\n    it('should return a wrapped external reference by surrounding it with \"<>\"', function () {\n      const wrapper = new phyx.TaxonomicUnitWrapper({\n        '@id': [\n          'http://arctos.database.museum/guid/MVZ:Herp:225749',\n        ],\n      });\n      expect(wrapper.label).to.equal('<http://arctos.database.museum/guid/MVZ:Herp:225749>');\n    });\n    it('should provide both taxon name and occurrence ID in label, but ignore external reference', function () {\n      const wrapper = new phyx.TaxonomicUnitWrapper({\n        '@id': [\n          'http://arctos.database.museum/guid/MVZ:Herp:225749',\n        ],\n        '@type': phyx.TaxonomicUnitWrapper.TYPE_SPECIMEN,\n        nameString: 'Rana luteiventris',\n        occurrenceID: 'MVZ 225749',\n      });\n      expect(wrapper.label).to.equal('Specimen MVZ 225749 identified as Rana luteiventris');\n    });\n  });\n  describe('#fromLabel', function () {\n    it('should return empty lists when inputs are empty or undefined', function () {\n      expect(phyx.TaxonomicUnitWrapper.fromLabel()).to.be.undefined;\n      expect(phyx.TaxonomicUnitWrapper.fromLabel(undefined)).to.be.undefined;\n      expect(phyx.TaxonomicUnitWrapper.fromLabel(null)).to.be.undefined;\n      expect(phyx.TaxonomicUnitWrapper.fromLabel('')).to.be.undefined;\n      expect(phyx.TaxonomicUnitWrapper.fromLabel('    ')).to.be.undefined;\n    });\n    it('when given a scientific name, it should return a list of a single TU wrapping a scientific name', function () {\n      expect(phyx.TaxonomicUnitWrapper.fromLabel('Rana luteiventris MVZ225749'))\n        .to.be.deep.equal({\n          '@type': 'http://rs.tdwg.org/ontology/voc/TaxonConcept#TaxonConcept',\n          label: 'Rana luteiventris MVZ225749',\n          hasName: {\n            '@type': 'http://rs.tdwg.org/ontology/voc/TaxonName#TaxonName',\n            label: 'Rana luteiventris MVZ225749',\n            genusPart: 'Rana',\n            specificEpithet: 'luteiventris',\n            nameComplete: 'Rana luteiventris',\n          },\n        });\n    });\n    it('when given a scientific name separated with underscores, it should return a list of a single TU wrapping the scientific name', function () {\n      expect(phyx.TaxonomicUnitWrapper.fromLabel('Rana_luteiventris_MVZ_225749'))\n        .to.be.deep.equal({\n          '@type': 'http://rs.tdwg.org/ontology/voc/TaxonConcept#TaxonConcept',\n          label: 'Rana_luteiventris_MVZ_225749',\n          hasName: {\n            '@type': 'http://rs.tdwg.org/ontology/voc/TaxonName#TaxonName',\n            label: 'Rana_luteiventris_MVZ_225749',\n            nameComplete: 'Rana luteiventris',\n            genusPart: 'Rana',\n            specificEpithet: 'luteiventris',\n          },\n        });\n    });\n  });\n  describe('#asOWLEquivClass', function () {\n    it('when given a taxon concept, only the complete name should be present in the equivClass', function () {\n      const wrapper = new phyx.TaxonomicUnitWrapper({\n        '@type': phyx.TaxonomicUnitWrapper.TYPE_TAXON_CONCEPT,\n        nameString: 'Rana luteiventris Thompson, 1913',\n      });\n      expect(wrapper.asOWLEquivClass).to.deep.equal({\n        '@type': 'owl:Restriction',\n        onProperty: 'http://rs.tdwg.org/ontology/voc/TaxonConcept#hasName',\n        someValuesFrom: {\n          '@type': 'owl:Restriction',\n          onProperty: 'http://rs.tdwg.org/ontology/voc/TaxonName#nameComplete',\n          hasValue: 'Rana luteiventris',\n        },\n      });\n    });\n    it('when given a specimen, only the occurrence ID should be present in the equivClass', function () {\n      const wrapper = new phyx.TaxonomicUnitWrapper({\n        '@type': phyx.TaxonomicUnitWrapper.TYPE_SPECIMEN,\n        nameString: 'Rana luteiventris',\n        occurrenceID: 'MVZ 225749',\n      });\n      expect(wrapper.asOWLEquivClass).to.deep.equal({\n        '@type': 'owl:Restriction',\n        onProperty: 'http://rs.tdwg.org/dwc/terms/occurrenceID',\n        hasValue: 'MVZ 225749',\n      });\n    });\n  });\n});\n\ndescribe('TaxonomicUnitMatcher', function () {\n  // To test matching, let's set up some taxonomic units.\n  // Note that:\n  //  tunit1 and tunit2 should match by scientific name.\n  //  tunit2 and tunit3 should match by specimen identifier.\n  //  tunit3 and tunit4 should match by external references.\n  const tunit1 = {\n    '@type': phyx.TaxonomicUnitWrapper.TYPE_TAXON_CONCEPT,\n    hasName: {\n      nameComplete: 'Rana luteiventris',\n    },\n  };\n  const tunit2 = {\n    '@type': [\n      phyx.TaxonomicUnitWrapper.TYPE_SPECIMEN,\n    ],\n    nameString: 'Rana luteiventris MVZ225749',\n    occurrenceID: 'MVZ225749',\n  };\n  const tunit3 = {\n    '@type': phyx.TaxonomicUnitWrapper.TYPE_SPECIMEN,\n    occurrenceID: 'MVZ225749',\n    '@id': 'http://arctos.database.museum/guid/MVZ:Herp:225749',\n  };\n  const tunit4 = {\n    '@id': 'http://arctos.database.museum/guid/MVZ:Herp:225749',\n  };\n\n  describe('#matchByNameComplete', function () {\n    it('should be able to match tunit1 and tunit2 by complete name', function () {\n      expect(new phyx.TaxonomicUnitMatcher(tunit1, tunit2).matchByExternalReferences()).to.be.false;\n      expect(new phyx.TaxonomicUnitMatcher(tunit1, tunit2).matchByOccurrenceID()).to.be.false;\n      expect(new phyx.TaxonomicUnitMatcher(tunit1, tunit2).matchByNameComplete()).to.be.true;\n    });\n  });\n  describe('#matchByExternalReferences', function () {\n    it('should be able to match tunit3 and tunit4 by external references', function () {\n      expect(new phyx.TaxonomicUnitMatcher(tunit3, tunit4).matchByExternalReferences()).to.be.true;\n      expect(new phyx.TaxonomicUnitMatcher(tunit3, tunit4).matchByOccurrenceID()).to.be.false;\n      expect(new phyx.TaxonomicUnitMatcher(tunit3, tunit4).matchByNameComplete()).to.be.false;\n    });\n  });\n  describe('#matchByOccurrenceID', function () {\n    it('should be able to match tunit2 and tunit3 by specimen identifiers', function () {\n      expect(new phyx.TaxonomicUnitMatcher(tunit2, tunit3).matchByExternalReferences()).to.be.false;\n      expect(new phyx.TaxonomicUnitMatcher(tunit2, tunit3).matchByOccurrenceID()).to.be.true;\n      expect(new phyx.TaxonomicUnitMatcher(tunit2, tunit3).matchByNameComplete()).to.be.false;\n    });\n  });\n  describe('#matched and #matchReason', function () {\n    it('should match tunit1 and tunit2 on the basis of identical complete names', function () {\n      const matcher = new phyx.TaxonomicUnitMatcher(tunit1, tunit2);\n      expect(matcher.matched).to.be.true;\n      expect(matcher.matchReason).to.include('share the same complete name');\n    });\n\n    it('should match tunit3 and tunit4 by identical external reference', function () {\n      const matcher = new phyx.TaxonomicUnitMatcher(tunit3, tunit4);\n      expect(matcher.matched).to.be.true;\n      expect(matcher.matchReason).to.include('External reference');\n    });\n\n    it('should match tunit2 and tunit3 by identical specimen identifier', function () {\n      const matcher = new phyx.TaxonomicUnitMatcher(tunit2, tunit3);\n      expect(matcher.matched).to.be.true;\n      expect(matcher.matchReason).to.include('Specimen identifier');\n    });\n  });\n});\n",
    "static": true,
    "longname": "/home/runner/work/phyx.js/phyx.js/test/taxonomic-units.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 384,
    "kind": "test",
    "name": "describe141",
    "testId": 141,
    "memberof": "test/taxonomic-units.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/taxonomic-units.js~describe141",
    "access": null,
    "description": "TaxonomicUnitWrapper",
    "lineNumber": 20
  },
  {
    "__docId__": 385,
    "kind": "test",
    "name": "describe142",
    "testId": 142,
    "memberof": "test/taxonomic-units.js~describe141",
    "testDepth": 1,
    "static": true,
    "longname": "test/taxonomic-units.js~describe141.describe142",
    "access": null,
    "description": "#constructor given no arguments",
    "lineNumber": 21
  },
  {
    "__docId__": 386,
    "kind": "test",
    "name": "it143",
    "testId": 143,
    "memberof": "test/taxonomic-units.js~describe141.describe142",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxonomic-units.js~describe141.describe142.it143",
    "access": null,
    "description": "should create an empty TaxonomicUnitWrapper without a defined label",
    "lineNumber": 22
  },
  {
    "__docId__": 387,
    "kind": "test",
    "name": "describe144",
    "testId": 144,
    "memberof": "test/taxonomic-units.js~describe141",
    "testDepth": 1,
    "static": true,
    "longname": "test/taxonomic-units.js~describe141.describe144",
    "access": null,
    "description": "#label given a taxonomic unit",
    "lineNumber": 51
  },
  {
    "__docId__": 388,
    "kind": "test",
    "name": "it145",
    "testId": 145,
    "memberof": "test/taxonomic-units.js~describe141.describe144",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxonomic-units.js~describe141.describe144.it145",
    "access": null,
    "description": "should return a wrapped scientific name",
    "lineNumber": 52
  },
  {
    "__docId__": 389,
    "kind": "test",
    "name": "it146",
    "testId": 146,
    "memberof": "test/taxonomic-units.js~describe141.describe144",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxonomic-units.js~describe141.describe144.it146",
    "access": null,
    "description": "should return a wrapped specimen identifier preceded by \"Specimen\"",
    "lineNumber": 62
  },
  {
    "__docId__": 390,
    "kind": "test",
    "name": "it147",
    "testId": 147,
    "memberof": "test/taxonomic-units.js~describe141.describe144",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxonomic-units.js~describe141.describe144.it147",
    "access": null,
    "description": "should return specimens with an occurrenceID as well as a taxon concept",
    "lineNumber": 69
  },
  {
    "__docId__": 391,
    "kind": "test",
    "name": "it148",
    "testId": 148,
    "memberof": "test/taxonomic-units.js~describe141.describe144",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxonomic-units.js~describe141.describe144.it148",
    "access": null,
    "description": "should ignore occurrence ID if typed as a taxon concept",
    "lineNumber": 79
  },
  {
    "__docId__": 392,
    "kind": "test",
    "name": "it149",
    "testId": 149,
    "memberof": "test/taxonomic-units.js~describe141.describe144",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxonomic-units.js~describe141.describe144.it149",
    "access": null,
    "description": "should return a wrapped external reference by surrounding it with \"<>\"",
    "lineNumber": 87
  },
  {
    "__docId__": 393,
    "kind": "test",
    "name": "it150",
    "testId": 150,
    "memberof": "test/taxonomic-units.js~describe141.describe144",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxonomic-units.js~describe141.describe144.it150",
    "access": null,
    "description": "should provide both taxon name and occurrence ID in label, but ignore external reference",
    "lineNumber": 95
  },
  {
    "__docId__": 394,
    "kind": "test",
    "name": "describe151",
    "testId": 151,
    "memberof": "test/taxonomic-units.js~describe141",
    "testDepth": 1,
    "static": true,
    "longname": "test/taxonomic-units.js~describe141.describe151",
    "access": null,
    "description": "#fromLabel",
    "lineNumber": 107
  },
  {
    "__docId__": 395,
    "kind": "test",
    "name": "it152",
    "testId": 152,
    "memberof": "test/taxonomic-units.js~describe141.describe151",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxonomic-units.js~describe141.describe151.it152",
    "access": null,
    "description": "should return empty lists when inputs are empty or undefined",
    "lineNumber": 108
  },
  {
    "__docId__": 396,
    "kind": "test",
    "name": "it153",
    "testId": 153,
    "memberof": "test/taxonomic-units.js~describe141.describe151",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxonomic-units.js~describe141.describe151.it153",
    "access": null,
    "description": "when given a scientific name, it should return a list of a single TU wrapping a scientific name",
    "lineNumber": 115
  },
  {
    "__docId__": 397,
    "kind": "test",
    "name": "it154",
    "testId": 154,
    "memberof": "test/taxonomic-units.js~describe141.describe151",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxonomic-units.js~describe141.describe151.it154",
    "access": null,
    "description": "when given a scientific name separated with underscores, it should return a list of a single TU wrapping the scientific name",
    "lineNumber": 129
  },
  {
    "__docId__": 398,
    "kind": "test",
    "name": "describe155",
    "testId": 155,
    "memberof": "test/taxonomic-units.js~describe141",
    "testDepth": 1,
    "static": true,
    "longname": "test/taxonomic-units.js~describe141.describe155",
    "access": null,
    "description": "#asOWLEquivClass",
    "lineNumber": 144
  },
  {
    "__docId__": 399,
    "kind": "test",
    "name": "it156",
    "testId": 156,
    "memberof": "test/taxonomic-units.js~describe141.describe155",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxonomic-units.js~describe141.describe155.it156",
    "access": null,
    "description": "when given a taxon concept, only the complete name should be present in the equivClass",
    "lineNumber": 145
  },
  {
    "__docId__": 400,
    "kind": "test",
    "name": "it157",
    "testId": 157,
    "memberof": "test/taxonomic-units.js~describe141.describe155",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxonomic-units.js~describe141.describe155.it157",
    "access": null,
    "description": "when given a specimen, only the occurrence ID should be present in the equivClass",
    "lineNumber": 160
  },
  {
    "__docId__": 401,
    "kind": "test",
    "name": "describe158",
    "testId": 158,
    "memberof": "test/taxonomic-units.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/taxonomic-units.js~describe158",
    "access": null,
    "description": "TaxonomicUnitMatcher",
    "lineNumber": 175
  },
  {
    "__docId__": 402,
    "kind": "test",
    "name": "describe159",
    "testId": 159,
    "memberof": "test/taxonomic-units.js~describe158",
    "testDepth": 1,
    "static": true,
    "longname": "test/taxonomic-units.js~describe158.describe159",
    "access": null,
    "description": "#matchByNameComplete",
    "lineNumber": 203
  },
  {
    "__docId__": 403,
    "kind": "test",
    "name": "it160",
    "testId": 160,
    "memberof": "test/taxonomic-units.js~describe158.describe159",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxonomic-units.js~describe158.describe159.it160",
    "access": null,
    "description": "should be able to match tunit1 and tunit2 by complete name",
    "lineNumber": 204
  },
  {
    "__docId__": 404,
    "kind": "test",
    "name": "describe161",
    "testId": 161,
    "memberof": "test/taxonomic-units.js~describe158",
    "testDepth": 1,
    "static": true,
    "longname": "test/taxonomic-units.js~describe158.describe161",
    "access": null,
    "description": "#matchByExternalReferences",
    "lineNumber": 210
  },
  {
    "__docId__": 405,
    "kind": "test",
    "name": "it162",
    "testId": 162,
    "memberof": "test/taxonomic-units.js~describe158.describe161",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxonomic-units.js~describe158.describe161.it162",
    "access": null,
    "description": "should be able to match tunit3 and tunit4 by external references",
    "lineNumber": 211
  },
  {
    "__docId__": 406,
    "kind": "test",
    "name": "describe163",
    "testId": 163,
    "memberof": "test/taxonomic-units.js~describe158",
    "testDepth": 1,
    "static": true,
    "longname": "test/taxonomic-units.js~describe158.describe163",
    "access": null,
    "description": "#matchByOccurrenceID",
    "lineNumber": 217
  },
  {
    "__docId__": 407,
    "kind": "test",
    "name": "it164",
    "testId": 164,
    "memberof": "test/taxonomic-units.js~describe158.describe163",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxonomic-units.js~describe158.describe163.it164",
    "access": null,
    "description": "should be able to match tunit2 and tunit3 by specimen identifiers",
    "lineNumber": 218
  },
  {
    "__docId__": 408,
    "kind": "test",
    "name": "describe165",
    "testId": 165,
    "memberof": "test/taxonomic-units.js~describe158",
    "testDepth": 1,
    "static": true,
    "longname": "test/taxonomic-units.js~describe158.describe165",
    "access": null,
    "description": "#matched and #matchReason",
    "lineNumber": 224
  },
  {
    "__docId__": 409,
    "kind": "test",
    "name": "it166",
    "testId": 166,
    "memberof": "test/taxonomic-units.js~describe158.describe165",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxonomic-units.js~describe158.describe165.it166",
    "access": null,
    "description": "should match tunit1 and tunit2 on the basis of identical complete names",
    "lineNumber": 225
  },
  {
    "__docId__": 410,
    "kind": "test",
    "name": "it167",
    "testId": 167,
    "memberof": "test/taxonomic-units.js~describe158.describe165",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxonomic-units.js~describe158.describe165.it167",
    "access": null,
    "description": "should match tunit3 and tunit4 by identical external reference",
    "lineNumber": 231
  },
  {
    "__docId__": 411,
    "kind": "test",
    "name": "it168",
    "testId": 168,
    "memberof": "test/taxonomic-units.js~describe158.describe165",
    "testDepth": 2,
    "static": true,
    "longname": "test/taxonomic-units.js~describe158.describe165.it168",
    "access": null,
    "description": "should match tunit2 and tunit3 by identical specimen identifier",
    "lineNumber": 237
  }
]